<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Arturo Maldonado" />


<title>Clase 3: Visualización</title>

<script src="site_libs/header-attrs-2.21/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.0/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.0/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Estadística_1</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="intro.html">Introducción</a>
</li>
<li>
  <a href="basico.html">Procedimientos básicos</a>
</li>
<li>
  <a href="clase1.html">Clase 1</a>
</li>
<li>
  <a href="clase2.html">Clase 2</a>
</li>
<li>
  <a href="clase3.html">Clase 3</a>
</li>
<li>
  <a href="clase4.html">Clase 4</a>
</li>
<li>
  <a href="clase5.html">Clase 5</a>
</li>
<li>
  <a href="clase6.html">Clase 6</a>
</li>
<li>
  <a href="repaso.html">Repaso</a>
</li>
<li>
  <a href="clase7.html">Clase 10</a>
</li>
<li>
  <a href="clase9.html">Clase 11</a>
</li>
<li>
  <a href="clase12.html">Clase 12</a>
</li>
<li>
  <a href="clase13.html">Clase 13</a>
</li>
<li>
  <a href="clase14.html">Clase 14</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="https://github.com/arturomaldonado/Estadistica_1.0">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Clase 3: Visualización</h1>
<h4 class="author">Arturo Maldonado</h4>
<h4 class="date">2/4/2023</h4>

</div>


<hr />
<div id="visualización" class="section level1">
<h1>Visualización</h1>
<pre class="r"><code>library(rio)
res2016 = import(&quot;resultados2016.xlsx&quot;)</code></pre>
<p>Una de las tareas más comunes en el manejo de datos es la
visualización de los resultados. En R hay dos maneras de proceder. La
primera es usar los comandos de base de R. La otra es usar una librería
<code>ggplot2</code> que permite una mayor flexibilidad en la producción
y estética de los gráficos.</p>
<p>Para esto se carga la librería <code>ggplot2</code>. Esta tiene un
comando <code>ggplot</code> en el que se define los aspectos del
gráfico. Por ejemplo, para graficar una variable numérica, como el
porcentaje de voto a FP por provincia, se puede producir un
histograma.</p>
<p>Dentro de este comando se define la base de datos y la variable que
se va a graficar. Luego se van agregando capas. La primera define el
tipo de gráfico. Usamos <code>geom_histogram</code> para producir el
histograma y se especifica el ancho de columna. Luego se define las
etiquetas de ejes y el tema del gráfico.</p>
<p>Se observa que el gráfico de porcentaje de votos a Fuerza Popular es
aproximadamente simétrico, tal como indicaban la similitud entre media y
mediana.</p>
<pre class="r"><code>library(ggplot2)
ggplot(res2016, aes(x=fp))+
  geom_histogram(binwidth = 5)+
  xlab(&quot;% Voto PPK 2016&quot;) +
  ylab(&quot;Frecuencia&quot;)+
  theme_minimal()</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Habíamos encontrado que la media y la mediana del porcentaje de voto
al Frente Amplio diferían. Esto lo comprobamos produciendo el histograma
de esta variable.</p>
<pre class="r"><code>ggplot(res2016, aes(x=fa))+
  geom_histogram(binwidth = 5)+
  geom_vline(xintercept = 29.3, color = &quot;red&quot;)+
  geom_vline(xintercept = 24.5, color = &quot;green&quot;)+
  xlab(&quot;% Voto FA 2011&quot;)+
  ylab(&quot;Frecuencia&quot;)+
  theme_classic()</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>Otro gráfico útil en la visualización es el llamado “boxplot” o
“gráfico de cajas”. Este tipo de gráficos sirve bastante para comparar
entre grupos de otra variable.</p>
<p>Para producir un gráfico de cajas usamos la especificación
<code>geom_bloxplot()</code> y podemos definir los límites y saltos del
eje Y. Este gráfico nos muestra que el distrito con el menor porcentaje
de voto a FP tuvo un poco más de 5% y que el máximo fue de casi 80%.
También muestra que la votación mediana fue de 40%. Los límites de la
caja son el cuartil 25 y el cuartil 75.</p>
<pre class="r"><code>ggplot(res2016, aes(y=fp))+
  geom_boxplot()+
  ylab(&quot;% Voto FP 2011&quot;)</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>El aspecto más útil de los gráficos de cajas es la comparación. Por
ejemplo, si se quisiera comparar el voto a Fuerza Popular entre
departamentos del país. Para hacer esto se debe definir que la variable
en el eje Y sea el porcentaje de votos a Fuerza Popular “fp” y en el eje
X la variable que define los departamentos “dpto”. Incluimos la
especificación <code>coord_flip()</code> para voltear los ejes y que las
etiquetas de los departamentos se lean más claramente.</p>
<p>En el gráfico se pueden hacer varias comparaciones. Lo más importante
es comparar medianas y anchos de cajas entre departamentos. Los puntos
aislados son “outliers” o valores extremos, que se calculan
automáticamente y se grafican.</p>
<p>Este gráfico, sin embargo, es muy desagragado.</p>
<pre class="r"><code>ggplot(res2016, aes(y=fp, x=dpto))+
  geom_boxplot()+
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10))+
  ylab(&quot;% Voto FP 2011&quot;)+
  xlab(&quot;Departamento&quot;)+
  theme_minimal()+
  coord_flip()</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>Si se quisiera comparar entre regiones (costa, sierre y selva), se
tendría que crear esta variable, a partir de la variable “dpto”.</p>
<div id="recodificando-variables" class="section level2">
<h2>Recodificando variables</h2>
<pre class="r"><code>library(tidyverse)
res2016 = res2016 |&gt;
  mutate(region = case_when(
    dpto==&quot;AMAZONAS&quot;~3,
    dpto==&quot;ANCASH&quot;~2,
    dpto==&quot;APURIMAC&quot;~2,
    dpto==&quot;AREQUIPA&quot;~2,
    dpto==&quot;AYACUCHO&quot;~2,
    dpto==&quot;CAJAMARCA&quot;~2,
    dpto==&quot;CUSCO&quot;~2,
    dpto==&quot;CALLAO&quot;~1,
    dpto==&quot;HUANCAVELICA&quot;~2,
    dpto==&quot;HUANUCO&quot;~3,
    dpto==&quot;ICA&quot;~1,
    dpto==&quot;JUNIN&quot;~2,
    dpto==&quot;LA LIBERTAD&quot;~1,
    dpto==&quot;LAMBAYEQUE&quot;~1,
    dpto==&quot;LIMA&quot;~1,
    dpto==&quot;LORETO&quot;~3,
    dpto==&quot;MADRE DE DIOS&quot;~3,
    dpto==&quot;MOQUEGUA&quot;~1,
    dpto==&quot;PASCO&quot;~2,
    dpto==&quot;PIURA&quot;~1,
    dpto==&quot;PUNO&quot;~2,
    dpto==&quot;SAN MARTIN&quot;~3,
    dpto==&quot;TACNA&quot;~1,
    dpto==&quot;TUMBES&quot;~1,
    dpto==&quot;UCAYALI&quot;~3
  )) </code></pre>
<pre class="r"><code>res2016 |&gt;
  count(Region = region, name=&quot;Frecuencia&quot;)</code></pre>
<pre><code>##   Region Frecuencia
## 1      1         49
## 2      2        104
## 3      3         43</code></pre>
<p>La variable creada es una variable de tipo “numérico”. En R existe
otro tipo de variable llamado “factor”. Podemos convertir cualquier
variable a una de factor y etiquetar cada valor.</p>
<pre class="r"><code>library(forcats)
res2016 = res2016 |&gt;
  mutate(region2 = factor(region, labels=c(&quot;Costa&quot;, &quot;Sierra&quot;, &quot;Selva&quot;)))</code></pre>
<p>Ahora, procedemos a producir el gráfico de cajas de porcentaje de
voto a Fuerza Popular por región.</p>
<pre class="r"><code>ggplot(res2016, aes(y=fp, x=region2))+
  geom_boxplot()+
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 20))+
  ylab(&quot;% Voto FP 2016&quot;)+
  xlab(&quot;Región&quot;)+
  theme_get()</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>Se observa en este gráfico que el voto mediano a Fuerza Popular fue
mayor entre provincias de la costa, seguido por la selva y luego la
sierra. Este mismo patrón se observa si calculáramos la media del
porcentaje de voto provincial a Fuerza Popular por región.</p>
<pre class="r"><code>res2016 |&gt; 
  group_by(region2) |&gt;
  summarise(mean(fp), sd(fp))</code></pre>
<pre><code>## # A tibble: 3 × 3
##   region2 `mean(fp)` `sd(fp)`
##   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;
## 1 Costa         49.6     13.6
## 2 Sierra        32.5     14.0
## 3 Selva         45.0     13.6</code></pre>
</div>
</div>
<div id="caso-1-los-peruanos-leen" class="section level1">
<h1>Caso 1: ¿los peruanos leen?</h1>
<p><em>Pregunta: Existe un sentido común que indica que los peruanos no
leen. ¿Es aquello cierto? ¿Existen diferencias de género o
socioeconómicas en los niveles de lectura?</em></p>
<p>Para responder a esta pregunta, usaremos la Encuesta Nacional de
Lectura de 2022.</p>
<pre class="r"><code>library(rio)
enl = import(&quot;~/Library/CloudStorage/GoogleDrive-arturo.maldonado@pucp.pe/Mi unidad/A Cursos/Estadistica_1/Data/ENL2022/ENL2022.sav&quot;)</code></pre>
<p>Esta encuesta tiene una pregunta que indaga directamente (P408).
Cuando se importa los datos a R, esta variable se importa como una
variable numérica, cuando en realidad, es una variable de tipo
factor.</p>
<p>Se usa el comando <code>mutate</code> para crear una nueva variable y
el comando <code>factor</code> para transformar la variable numérica a
una de factor con sus respectivos <code>labels</code>.</p>
<pre class="r"><code>library(tidyverse)
enl = enl |&gt;
  mutate(lee = factor(P408, labels=c(&quot;Sí&quot;, &quot;No&quot;)))</code></pre>
<div id="descripción-de-variables-de-factor" class="section level2">
<h2>Descripción de variables de factor</h2>
<p>Para describir variables que no son numéricas, podemos producir
tablas de distribución de frecuencias. Por ejemplo, podemos describir la
variable “lee” de la base de datos. Podemos usar el comando
<code>count</code> para calcular la tabla de distribución de frecuencias
de esta variable. Se guarda esta tabla en un objeto “tabla1”.</p>
<pre class="r"><code>tabla1 = enl |&gt;
  filter(lee == &quot;Sí&quot; | lee == &quot;No&quot;) |&gt;
  count(Lee = lee, name=&quot;Frecuencia&quot;)
tabla1</code></pre>
<pre><code>##   Lee Frecuencia
## 1  Sí      18929
## 2  No      22714</code></pre>
<p>Para calcular los porcentajes, se puede agregar a la tabla una
columna “Porcentaje” con el cálculo de la “Frecuencia” (columna
existente) ente la suma total de las frecuencias. Se encuentra que
Fuerza Popular ganó en el 57% de provincias del Perú.</p>
<pre class="r"><code>tabla1 = tabla1 |&gt;
  mutate(Porcentaje = (Frecuencia / sum(Frecuencia)*100 ))
tabla1</code></pre>
<pre><code>##   Lee Frecuencia Porcentaje
## 1  Sí      18929   45.45542
## 2  No      22714   54.54458</code></pre>
<p>Para graficar una variable de tipo cualitativa (o de factor en el
lenguaje de R), se debe usar, por ejemplo, un gráfico de barras. Podemos
graficar estos porcentajes.</p>
<p>Para esto usamos la librería <code>ggplot2</code>, pero ahora no
realizaremos un histograma (no usaremos <code>geom_histogram</code>),
sino barras, con <code>geom_bar</code>. Dentro de este comando se añade
<code>stat="identity</code> para indicar que R no calcule nada y solo
use los datos de “tabla”.</p>
<pre class="r"><code>library(ggplot2)
graf1 = ggplot(tabla1, aes(x=Lee,y=Porcentaje))+
  geom_bar(stat=&quot;identity&quot;, width=0.5)
graf1</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>La encuesta también incluye la pregunta P209 sobre género. Esta
variable se importa como una numérica, por lo que nuevamente la
transformamos en una variable de tipo factor “sexo” con sus
etiquetas.</p>
<pre class="r"><code>enl = enl |&gt;
  mutate(sexo = factor(P209, labels=c(&quot;Hombre&quot;, &quot;Mujer&quot;)))</code></pre>
<p>Ahora usamos esta variable para calcular las frecuencias y
porcentajes por grupos de sexo.</p>
<pre class="r"><code>tabla2 = enl |&gt;
  filter(lee == &quot;Sí&quot; | lee == &quot;No&quot;) |&gt; 
  group_by(sexo) |&gt;
  count(Lee = lee, name=&quot;N&quot;)|&gt;
  mutate(total = sum(N), 
         Por = N / total * 100)
tabla2</code></pre>
<pre><code>## # A tibble: 4 × 5
## # Groups:   sexo [2]
##   sexo   Lee       N total   Por
##   &lt;fct&gt;  &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
## 1 Hombre Sí     8307 19759  42.0
## 2 Hombre No    11452 19759  58.0
## 3 Mujer  Sí    10622 21884  48.5
## 4 Mujer  No    11262 21884  51.5</code></pre>
<p>La tabla nos indica los porcentajes de los que sí leen y los que no
leen por sexo. Como solo queremos graficar los porcentajes de los que sí
leen, podemos eliminar las filas de los que no leen.</p>
<pre class="r"><code>tabla2 = tabla2[-c(2,4),]</code></pre>
<p>Con esta tabla reducida, podemos graficas usando <code>ggplot</code>.
Ahora agregamos la capa <code>geom_text</code> para incluir el dato del
porcentaje dentro del gráfico.</p>
<pre class="r"><code>graf2 = ggplot(tabla2, aes(x=sexo, y=Por))+
  geom_bar(stat=&quot;identity&quot;)+
  geom_text(aes(label=paste(round(Por, 1))), vjust=-1, size=3)+
  labs(x=&quot;Sexo&quot;, y=&quot;Porcentaje&quot;)+
  theme_classic()
graf2</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<p>La base de datos incluye una variable “nse”, que refiere al nivel
socioeconómico de la persona que responde. Este nivel socioeconómico
está categorizado en 4 niveles.</p>
<pre class="r"><code>enl = enl |&gt;
  mutate(nse = factor(nse, labels=c(&quot;Rural&quot;, &quot;Bajo&quot;, &quot;Medio&quot;, &quot;Alto&quot;)))</code></pre>
<p>Pasamos a calcular los porcentajes de lectura por los 4 niveles
socioeconómicos.</p>
<pre class="r"><code>tabla3 = enl |&gt;
  filter(lee == &quot;Sí&quot; | lee == &quot;No&quot;) |&gt; 
  group_by(nse) |&gt;
  count(Lee = lee, name=&quot;N&quot;)|&gt;
  mutate(total = sum(N), 
         Por = N / total * 100)
tabla3</code></pre>
<pre><code>## # A tibble: 8 × 5
## # Groups:   nse [4]
##   nse   Lee       N total   Por
##   &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
## 1 Rural Sí     1431  4819  29.7
## 2 Rural No     3388  4819  70.3
## 3 Bajo  Sí     8684 20815  41.7
## 4 Bajo  No    12131 20815  58.3
## 5 Medio Sí     4254  8301  51.2
## 6 Medio No     4047  8301  48.8
## 7 Alto  Sí     4560  7708  59.2
## 8 Alto  No     3148  7708  40.8</code></pre>
<p>Nuevamente eliminamos las filas de los porcentajes de aquellos que no
leen.</p>
<pre class="r"><code>tabla3 = tabla3[-c(2,4,6,8),]</code></pre>
<p>Y graficamos los porcentajes de los que sí leen por niveles
socioeconómicos.</p>
<pre class="r"><code>graf3 = ggplot(tabla3, aes(x=nse, y=Por))+
  geom_bar(stat=&quot;identity&quot;)+
  geom_text(aes(label=paste(round(Por, 1))), vjust=-1, size=3)+
  labs(x=&quot;NSE&quot;, y=&quot;Porcentaje&quot;)+
  theme_classic()
graf3</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
</div>
<div id="tarea" class="section level2">
<h2>Tarea</h2>
<p>Se encontró que una mayor proporción de mujeres que hombres lee.
¿Cuántos libros impresos y digitales lee el peruano promedio? ¿Existen
diferencias entre hombres y mujeres entre el promedio de libros impresos
y digitales que leen? ¿Entre niveles socioeconómicos?</p>
</div>
</div>
<div id="caso-2-encuesta-nacional-docente-2020" class="section level1">
<h1>Caso 2: Encuesta Nacional Docente 2020</h1>
<p>Cada dos años, el Ministerio de Educación realiza una encuesta a una
muestra de docentes de educación básica en el Perú. La última disponible
fue hecha en 2020, en medio de la pandemia del COVID-19. Las bases de
datos y cuestionarios de esta encuesta se encuentran disponibles <a
href="http://www.minedu.gob.pe/politicas/docencia/encuesta-nacional-a-docentes-endo.php">aquí</a>.</p>
<p>En esta ubicación se encuentra la base de datos, que puede ser
descargada y leída en R con el siguiente código.</p>
<pre class="r"><code>library(rio)
endo2020 = import(&quot;bases/ENDO_REMOTO_2020.dta&quot;)
#CAMBIAR A PROPIO DIRECTORIO DE TRABAJO</code></pre>
</div>
<div id="estimación-puntual" class="section level1">
<h1>Estimación puntual</h1>
<p>De una variable numérica, la medida de tendencia central más útil es
la media. La encuesta a docentes incluye la pregunta:</p>
<ol start="6" style="list-style-type: decimal">
<li>¿A cuántos estudiantes le brinda acompañamiento como docente de aula
en esta IE? (Ver cuestionario)</li>
</ol>
<p>De esta pregunta podemos preguntarnos: ¿A cuántos alumnos en promedio
acompaña el docente peruano en aula? Esta encuesta tiene una pregunta
que nos permite calcular esta media y la desviación estándar.</p>
<pre class="r"><code>library(dplyr)
library(tidyverse)
endo2020 |&gt; 
  summarize(Media =mean(P1_6, na.rm = T), Desv.Std = sd(P1_6, na.rm = T))</code></pre>
<pre><code>##      Media Desv.Std
## 1 39.98644 50.76707</code></pre>
<p>Es decir, un profesor promedio en Perú acompaña aproximadamente a 40
alumnos en aula. ¿Existen diferencias en el número promedio de alumnos
que acompañan docentes hombres y docentes mujeres?</p>
<p>Cuando se importa la base de datos, la variable sexo, P1_1, es
definida como numérica.</p>
<pre class="r"><code>str(endo2020$P1_1)</code></pre>
<pre><code>##  num [1:28216] 1 2 2 NA NA 2 1 NA NA NA ...
##  - attr(*, &quot;label&quot;)= chr &quot;Sexo&quot;
##  - attr(*, &quot;format.stata&quot;)= chr &quot;%12.0g&quot;
##  - attr(*, &quot;labels&quot;)= Named num [1:2] 1 2
##   ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;Masculino&quot; &quot;Femenino&quot;</code></pre>
<p>La podemos transformar a una variable de tipo factor.</p>
<pre class="r"><code>endo2020 = endo2020 |&gt;
  mutate(sexo = factor(P1_1, labels=c(&quot;Hombre&quot;, &quot;Mujer&quot;)))</code></pre>
<p>Calculamos los datos para hombres y mujeres.</p>
<pre class="r"><code>tabla1 = endo2020 |&gt; 
  group_by(sexo) |&gt;
  summarize(Media = mean(P1_6, na.rm = T), 
            Desv.Std = sd(P1_6, na.rm = T),
            Mediana = median(P1_6, na.rm = T))
tabla1</code></pre>
<pre><code>## # A tibble: 3 × 4
##   sexo   Media Desv.Std Mediana
##   &lt;fct&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1 Hombre  52.2     60.4      28
## 2 Mujer   34.1     44.2      22
## 3 &lt;NA&gt;   NaN       NA        NA</code></pre>
<p>Se encuentra que los docentes hombres acompañan, en promedio, a 52
alumnos, mientras que las docentes mujeres acompañan a 34 alumnos, una
diferencia de 18 alumnos en promedio.</p>
<p>Todos estos resultados son puntuales y aplican para la muestra de
28,216 profesores.</p>
<p>Para una comparación gráfica, se puede usar boxplot.</p>
<pre class="r"><code>library(ggplot2)
ggplot(endo2020, aes(y=P1_6, x=sexo))+
  geom_boxplot()</code></pre>
<pre><code>## Warning: Removed 9266 rows containing
## non-finite values (`stat_boxplot()`).</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<pre class="r"><code>endo2020 = endo2020 |&gt;
  mutate(condicion = factor(P1_7, labels=c(&quot;Nombrado&quot;, &quot;Contratado x concurso&quot;, &quot;Contratado otro&quot;)))</code></pre>
<pre class="r"><code>tabla2 = endo2020 |&gt; 
  group_by(condicion) |&gt;
  summarize(Media = mean(P1_6, na.rm = T), 
            Desv.Std = sd(P1_6, na.rm = T),
            Mediana = median(P1_6, na.rm = T))
tabla2</code></pre>
<pre><code>## # A tibble: 4 × 4
##   condicion             Media Desv.Std Mediana
##   &lt;fct&gt;                 &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1 Nombrado               36.9     48.0      23
## 2 Contratado x concurso  43.7     53.6      23
## 3 Contratado otro        50.6     66.1      23
## 4 &lt;NA&gt;                  NaN       NA        NA</code></pre>
<pre class="r"><code>library(ggplot2)
library(tidyverse)
endo2020 |&gt;
  drop_na(P1_6) |&gt;
  ggplot(aes(y=P1_6, x=condicion))+
  geom_boxplot()</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<pre class="r"><code>ggplot(subset(endo2020, !is.na(P1_6)), aes(y=P1_6, x=condicion))+
  geom_boxplot()</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>Si se quiere hacer un gráfico de barras simples para mostrar la media
del número de alumnos por sexo del profesor, se puede usar:</p>
<pre class="r"><code>ggplot(tabla1, aes(x=sexo, y=Media)) + 
  geom_bar(stat = &quot;identity&quot;) +
  ggtitle(&quot;Número de alumnos promedio por sexo del docente&quot;) +
  xlab(&quot;Sexo del docente&quot;) +
  geom_text(aes(label=round(Media,1)), vjust=1.30, color=&quot;white&quot;, size=3)+
  theme_minimal()</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing
## values (`position_stack()`).</code></pre>
<pre><code>## Warning: Removed 1 rows containing missing
## values (`geom_text()`).</code></pre>
<p><img src="clase3_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
<p>¿Cómo se pueden extrapolar estos resultados al universo de profesores
peruanos?</p>
</div>
<div id="estimación-por-intervalos" class="section level1">
<h1>Estimación por intervalos</h1>
<p>Tanto la media muestral, como la proporción muestral, son
estimaciones puntuales, basados en los resultados de la muestra. Es
decir, estas son estimaciones correspondientes a las 28,216
observaciones que son parte de este estudio. Sin embargo, esta muestra
forma parte de un universo o población (el conjunto de profesores del
Perú), del que seguramente se quiere decir algo.</p>
<p>El mismo razonamiento aplica a una encuesta de opinión convencional.
La ficha técnica de una encuesta menciona, generalmente, el tamaño de
muestra y la población a la que se busca representar. También se puede
encontrar el margen de error (+/- 2.8%) y el nivel de confianza
(generalmente de 95%).(Ver, por ejemplo, la <a
href="https://www.ipsos.com/sites/default/files/ct/news/documents/2023-08/Informe%20Encuesta%20Nacional%20Urbano%20Rural%20-%20America%20Televisión%20al%2011%20de%20agosto%202023%20Estudio%20de%20Opinión.pdf">encuesta
de opinión de agosto 2023 de Ipsos</a>.</p>
<p>El proceso mediante el cual se parte de una muestra para decir algo
de un universo o población es un proceso de inferencia y es parte de la
estadística inferencial. La estadística inferencial introduce la
<strong>incertidumbre</strong> en los estimados, debido al hecho de
estar trabajando con una muestra y no con el total de observaciones del
universo.</p>
<div id="un-breve-paseo-por-las-probabilidades" class="section level2">
<h2>Un breve paseo por las probabilidades</h2>
<p>Partimos del hecho que en el común de las investigaciones uno tiene
que seleccionar un conjunto de observaciones que son parte del total,
que es muy costoso e ineficiente hacer un estudio de la población
completa. La analogía es, por ejemplo, que para un análisis de sangre se
extrae una “muestra” de sangre y no el total de sangre del cuerpo.</p>
<p>A esto le sumamos el hecho que nuestras herramientas de recojo de
información son imperfectas. Un estudio transversal, por ejemplo,
debería recoger información de los individuos en un corte en el tiempo,
sin embargo, muchos estudios no son una “foto del momento”, pues las
observaciones toman tiempo y abarcan horas, días o semanas, sino
meses.</p>
<p>Es por este motivo que para un estudio se selecciona “una” muestra,
un conjunto de observaciones que son una fracción del total. Esta
selección se hace siguiendo procedimientos aleatorios, de tal manera que
cualquier unidad del universo tenga la misma probabilidad de ser
seleccionada.</p>
<p>El punto es que esta única muestra es solo una de las múltiples
muestras teóricas que se podrían seleccionar de un universo
determinado.</p>
<p>Partamos de un ejemplo muy simple. Para un universo de 5 personas, se
pueden extraer 10 muestras de tamaño 2 diferentes.</p>
<p><img src="muestra1.jpeg" /></p>
<p>La fórmula para calcular el número de muestras probables es la de
combinatorias, que incluye el operador factorial. Si aplicamos esta
fórmula a un ejemplo de un universo más grande, por ejemplo, un salón de
clase de 50 alumnos, donde se quiere saber cuántas muestras diferentes
de tamaño 4 se pueden extraer. Según la fórmula:</p>
<p><span class="math display">\[
\frac{50!} {(50-4)! 4!} = \frac{50!} {46! 4!} = \frac{50*49*48*47}
{4*3*2} = 230,300
\]</span></p>
<p>Para un sondeo de opinión, donde el universo son 24 millones de
individuos y se quiere saber cuántas muestras diferentes de tamaño 1,500
se pueden extraer, este número de muestras probables es muuuuy
grande.</p>
<p>Volviendo al ejemplo muy simple de 5 personas donde se quiere extraer
una muestra de 2 y se quiere inferir los datos de la muestra de dos
variables: sexo y edad.</p>
<p>Se tiene un universo de 5 individuos, cada uno con su sexo y edad. En
la población la proporción de hombres es de 60% y la media de edad es de
34 años.</p>
<p><img src="muestra2.jpeg" /></p>
<p>Si queremos extraer una muestra de tamaño de 2 de ese universo, se
tienen 10 posibles muestras, cada una tendrá una aproximación de la
proporción de hombres y de la media de edad. Dependiendo de qué muestra
de todas las posibles sea la que se observa, los estadísticos serán una
aproximación de los parámetros poblacionales.</p>
<p>En el caso de la proporción de hombres, se puede tabular los
resultados de cada muestra probable.</p>
<table>
<colgroup>
<col width="25%" />
<col width="50%" />
<col width="25%" />
</colgroup>
<thead>
<tr class="header">
<th align="center">Resultados muestrales</th>
<th align="center">Número de muestras que arrojaron ese resultado</th>
<th align="left">Frecuencia</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">0%</td>
<td align="center">1</td>
<td align="left">X</td>
</tr>
<tr class="even">
<td align="center">50%</td>
<td align="center">5</td>
<td align="left">XXXXX</td>
</tr>
<tr class="odd">
<td align="center">100%</td>
<td align="center">4</td>
<td align="left">XXXX</td>
</tr>
</tbody>
</table>
<p>Incluso se podría calcular un promedio de todas esas proporciones
muestrales (100+50+100+…+50/10), y ese resultado sería 65%, un resultado
algo cerca de la proporción poblacional de 60%.</p>
<p>Este mismo procedimiento se podría hacer para todas las 230,300
muestras probables de tamaño 4 de un universo de 50 alumnos. Cada uno de
los 50 alumnos será hombre o mujer y la proporción poblacional de
hombres se puede calcular en ese total. A su vez, cada muestra de 4,
tendrá una proporción muestral que tendrá valores (0 si no hay ningún
hombre, 25% si hay 1 hombre, 50% si hay 2 hombres, 75% si hay 3 hombres
y 100% si todos son hombres). Finalmente, se puede contar cuántas de las
230,300 muestras probables tuvieron 0%, 25%, 50%, 75% y 100% de hombres.
Esta distribución se llama “<strong>distribución de
muestreo</strong>”.</p>
<p>Si quisiéramos ampliar el tamaño de muestra a 10, entonces los
resultados posibles serían, 0, 10, 20, 30, 40, 50, 60, 70, 80, 90 y
100%. También podríamos contar cuántas muestras tienen estos
resultados.</p>
<p>De un universo más grande, se puede plantear extraer muestras de
tamaño más grande. Por ejemplo, teóricamente se puede pensar que de un
universo de 20 millones, se pueden extraer casi infinitas muestras de
tamaño 1,500. Cada una de estas muestras tendrá un estadístico que será
una aproximación del parámetro. Los estadísticos de todas estas casi
infinitas muestras se pueden tabular y graficar.</p>
</div>
<div id="teorema-del-límite-central" class="section level2">
<h2>Teorema del límite central</h2>
<p>Este teorema muestra que la <strong>distribución de muestreo se
aproxima a una distribución normal</strong>, con centro en el parámetro,
en la medida que el tamaño de muestra aumenta.</p>
<p>Esto se puede mostrar gráficamente en el Tablero de Galton, ver <a
href="https://youtu.be/AwEaHCjgeXk?si=a0-wfG-fng4HYsRQ">aquí</a></p>
<p>Por lo tanto, la distribución de muestreo de N grandes para cualquier
variable seguirá las características de cualquier curva normal. Toda
curva normal es simétrica y sabemos que si desde el centro se desplaza 1
desviación estándar en ambas direcciones, entre esos límites estarán el
68.3% de todas las observaciones. Si se desplaza 2 desviaciones estándar
en ambas direcciones, se acumularían el 95.4% de todas las
observaciones. Con 3 desviaciones estándar hacia ambos lados, se
acumularía el 99.7% de todas las observaciones.</p>
<p><img src="c3.3.png" width="510" /></p>
<p>Traduciendo a la distribución de muestreo, la idea es que si se
tabulan y se hace un gráfico de barras de los resultados de todas las
muestras probables, se tendría una curva normal con centro en el
parámetro. Sabríamos que si desde ese centro nos desplazamos 2
desviaciones estándar en ambas direcciones, entre esos límites estarían
el 95% de todas las muestra probables.</p>
<p>Es altamente probable (95% probable) que si en una investigación se
extrae una sola muestra, esta sea parte del 95% de muestras posibles a
+/- 2 desviaciones estándar del parámetro. De la misma manera, es poco
probable (5% probable) que una sola muestra no esté a +/- 2 desviaciones
estándar del parámetro.</p>
</div>
</div>
<div id="estimación-de-intervalos-de-confianza" class="section level1">
<h1>Estimación de intervalos de confianza</h1>
<p>La distribución de muestreo es teórica, muy difícilmente se puede
calcular en la realidad. Regularmente tampoco sabemos los datos del
universo. Lo que tenemos a mano es <strong>1 muestra observada</strong>.
Es decir, en un estudio de las muuuuuchas muestras probables, se
selecciona 1 muestra.</p>
<p>En el caso de la encuesta ENDO, por ejemplo, del universo de
profesores peruanos, se seleccionó 1 muestra de 28,216 observaciones, de
las muuuuchas muestras de 28,216 individuos de la población total.</p>
<p>Si teóricamente sabemos que en la distribución muestral, el 95% de
todas las muestras están a +/- 2 desviaciones estándar<a href="#fn1"
class="footnote-ref" id="fnref1"><sup>1</sup></a> del centro, que
coincide con el parámetro poblacional, es muy probable que la única
muestra que se ha observado sea parte de ese conjunto. De hecho, se
puede decir que se tiene 95% de probabilidades de que sea parte de ese
grupo.</p>
<p>Por lo tanto, si a partir del estadístico muestral, se aplica esta
distancia de +/- 2 errores estándar, se tiene 95% de probabilidades que
entre esos límites se incluya al valor del parámetro. Para verlo de
manera más visual, en la siguiente figura se tiene la distribución de
muestreo teórica (y desconocida), donde se marca la región que acumula
el 95% de todas las muestras probables.</p>
<p>Más abajo se marca los resultados de 2 muestras observadas. La
primera proporción muestral subestima la proporción poblacional. La
segunda, por el contrario, sobreestima la proporción poblacional. En el
primer caso, si a partir del estadístico muestral se aplica +/- 1.96
errores estándar (línea horizontal en negrita), se observa que el
parámetro poblacional está incluido en esos límites.</p>
<p>Es probable, como en el segundo caso, que otra muestra probable,
cuando se le aplique el intervalo de +/- 1.96 errores estándar, no
incluya al parámetro. Se observa que la línea en negrita no incluye la
linea vertical entrecortada que marca el valor del parámetro
poblacional.</p>
<p><img src="c3.4.png" width="581" /></p>
<p>Sin embargo, sabemos que es mucho más probable (95% de
probabilidades) que si una muestra observada es parte del 95% de
muestras alrededor del parámetro, este intervalo incluya al parámetro
poblacional. A estos límites le llamamos “intervalos de confianza”.</p>
<p>En cualquier investigación solo se cuenta con una muestra observada,
cuyo estadístico muestral, sea una media o un proporción, es una
aproximación del parámetro poblacional.</p>
<p>Para poder extrapolar desde la muestra hasta la población, se tiene
que construir un intervalo de confianza alrededor del estadístico
muestral. Este intervalo se construye aplicando la “distancia” de +/-
1.96 errores estándar, para tener una confianza de 95% de incluir al
parámetro poblacional.</p>
<p>Si se está extrapolando para una variable numérica, mediante la
media, el error estándar (o se) es:</p>
<p><span class="math display">\[
se = 1.96 * \frac{s} {\sqrt{n}}
\]</span></p>
<p>Si se está extrapolando para una variable categórica, mediante una
proporción, el error estándar (o se) es:</p>
<p><span class="math display">\[
se = 1.96 * \sqrt{\frac{(p * (1-p))} {n}}
\]</span></p>
<p>A manera de resumen, la siguiente tabla nos muestra el parámetro, el
estadístico puntual y el error estándar para cada tipo de variable y
cómo se forma el intervalo de confianza.</p>
<p><img src="c3.5.png" /></p>
<p>En estas fórmulas, se usa el símbolo “t” y “z” para referir a las
distribuciones teóricas que se usan. Para fines prácticos, cuando la
muestra es grande, ambas distribuciones son iguales. El valor de “t” o
“z” depende del nivel de confianza que queremos. Es decir, de la
probabilidad que queremos de que el intervalo incluya al parámetro. De
esta manera:</p>
<ul>
<li><p>Z al 90% = 1.645</p></li>
<li><p>Z al 95% = 1.96</p></li>
<li><p>Z al 98% = 2.326</p></li>
<li><p>Z al 99% = 2.576</p></li>
</ul>
<p>¿Qué pasa con el IC cuando se quiere mayor confianza? ¿Se vuelve más
o menos preciso?</p>
<p>En el ejemplo del cálculo del promedio de alumnos que atiende los
profesores, se puede añadir el cálculo de los intervalos de confianza en
ambos casos, para hombres y mujeres. El comando para hacer esto es
<code>ciMean</code> que es parte de la librería <code>lsr</code>.</p>
<pre class="r"><code>library(lsr)
ciMean(endo2020$P1_6, na.rm = T)</code></pre>
<pre><code>##          2.5%   97.5%
## [1,] 39.26358 40.7093</code></pre>
<p>Si se calculan los intervalos de confianza por grupos, estos se
pueden comparar.</p>
<pre class="r"><code>library(lsr)
ci_alumxsexo = endo2020 |&gt;
  group_by(sexo) |&gt;
  summarise(Media = mean(P1_6, na.rm=T),
            min = ciMean(P1_6, na.rm=T)[1],
            max = ciMean(P1_6, na.rm=T)[2]
            )
ci_alumxsexo</code></pre>
<pre><code>## # A tibble: 3 × 4
##   sexo   Media   min   max
##   &lt;fct&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 Hombre  52.2  50.7  53.8
## 2 Mujer   34.1  33.3  34.8
## 3 &lt;NA&gt;   NaN    NA    NA</code></pre>
<p>Se encuentra que la media de alumnos que atiende un docente hombre
esta entre 50.7 y 53.8 alumnos, mientras que en el caso de las docentes
mujeres está entre 33.3 y 34.8 alumnos en aula.</p>
<p>¿Qué más se puede decir de esta comparación entre intervalos de
confianza? ¿Cómo graficar estos intervalos de confianza?</p>
</div>
<div id="bibliografía" class="section level1">
<h1>Bibliografía</h1>
</div>
<div class="footnotes footnotes-end-of-document">
<hr />
<ol>
<li id="fn1"><p>En realidad es a +/- 2 errores estándar del centro. El
error estándar se entiende como la desviación estándar de la
distribución de muestreo.<a href="#fnref1"
class="footnote-back">↩︎</a></p></li>
</ol>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAnQ2xhc2UgMzogVmlzdWFsaXphY2nDs24nCmF1dGhvcjogIkFydHVybyBNYWxkb25hZG8iCmRhdGU6ICIyLzQvMjAyMyIKb3V0cHV0OgogIGh0bWxfZG9jdW1lbnQ6CiAgICB0b2M6IHRydWUKICAgIHRvY19mbG9hdDogdHJ1ZQogICAgY29sbGFwc2VkOiBmYWxzZQogICAgbnVtYmVyX3NlY3Rpb25zOiBmYWxzZQogICAgdG9jX2RlcHRoOiAxCiAgICBjb2RlX2Rvd25sb2FkOiB0cnVlCiAgICB0aGVtZTogY29zbW8KICAgIGhpZ2hsaWdodDogdGV4dG1hdGUKZWRpdG9yX29wdGlvbnM6CiAgbWFya2Rvd246CiAgICB3cmFwOiBzZW50ZW5jZQpiaWJsaW9ncmFwaHk6IHJlZmVyZW5jZXMuYmliCi0tLQoKYGBge3Igc2V0dXAsIGluY2x1ZGU9RkFMU0V9CmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkKYGBgCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMgVmlzdWFsaXphY2nDs24KCmBgYHtyfQpsaWJyYXJ5KHJpbykKcmVzMjAxNiA9IGltcG9ydCgicmVzdWx0YWRvczIwMTYueGxzeCIpCmBgYAoKVW5hIGRlIGxhcyB0YXJlYXMgbcOhcyBjb211bmVzIGVuIGVsIG1hbmVqbyBkZSBkYXRvcyBlcyBsYSB2aXN1YWxpemFjacOzbiBkZSBsb3MgcmVzdWx0YWRvcy4KRW4gUiBoYXkgZG9zIG1hbmVyYXMgZGUgcHJvY2VkZXIuCkxhIHByaW1lcmEgZXMgdXNhciBsb3MgY29tYW5kb3MgZGUgYmFzZSBkZSBSLgpMYSBvdHJhIGVzIHVzYXIgdW5hIGxpYnJlcsOtYSBgZ2dwbG90MmAgcXVlIHBlcm1pdGUgdW5hIG1heW9yIGZsZXhpYmlsaWRhZCBlbiBsYSBwcm9kdWNjacOzbiB5IGVzdMOpdGljYSBkZSBsb3MgZ3LDoWZpY29zLgoKUGFyYSBlc3RvIHNlIGNhcmdhIGxhIGxpYnJlcsOtYSBgZ2dwbG90MmAuCkVzdGEgdGllbmUgdW4gY29tYW5kbyBgZ2dwbG90YCBlbiBlbCBxdWUgc2UgZGVmaW5lIGxvcyBhc3BlY3RvcyBkZWwgZ3LDoWZpY28uClBvciBlamVtcGxvLCBwYXJhIGdyYWZpY2FyIHVuYSB2YXJpYWJsZSBudW3DqXJpY2EsIGNvbW8gZWwgcG9yY2VudGFqZSBkZSB2b3RvIGEgRlAgcG9yIHByb3ZpbmNpYSwgc2UgcHVlZGUgcHJvZHVjaXIgdW4gaGlzdG9ncmFtYS4KCkRlbnRybyBkZSBlc3RlIGNvbWFuZG8gc2UgZGVmaW5lIGxhIGJhc2UgZGUgZGF0b3MgeSBsYSB2YXJpYWJsZSBxdWUgc2UgdmEgYSBncmFmaWNhci4KTHVlZ28gc2UgdmFuIGFncmVnYW5kbyBjYXBhcy4KTGEgcHJpbWVyYSBkZWZpbmUgZWwgdGlwbyBkZSBncsOhZmljby4KVXNhbW9zIGBnZW9tX2hpc3RvZ3JhbWAgcGFyYSBwcm9kdWNpciBlbCBoaXN0b2dyYW1hIHkgc2UgZXNwZWNpZmljYSBlbCBhbmNobyBkZSBjb2x1bW5hLgpMdWVnbyBzZSBkZWZpbmUgbGFzIGV0aXF1ZXRhcyBkZSBlamVzIHkgZWwgdGVtYSBkZWwgZ3LDoWZpY28uCgpTZSBvYnNlcnZhIHF1ZSBlbCBncsOhZmljbyBkZSBwb3JjZW50YWplIGRlIHZvdG9zIGEgRnVlcnphIFBvcHVsYXIgZXMgYXByb3hpbWFkYW1lbnRlIHNpbcOpdHJpY28sIHRhbCBjb21vIGluZGljYWJhbiBsYSBzaW1pbGl0dWQgZW50cmUgbWVkaWEgeSBtZWRpYW5hLgoKYGBge3IgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0KbGlicmFyeShnZ3Bsb3QyKQpnZ3Bsb3QocmVzMjAxNiwgYWVzKHg9ZnApKSsKICBnZW9tX2hpc3RvZ3JhbShiaW53aWR0aCA9IDUpKwogIHhsYWIoIiUgVm90byBQUEsgMjAxNiIpICsKICB5bGFiKCJGcmVjdWVuY2lhIikrCiAgdGhlbWVfbWluaW1hbCgpCmBgYAoKSGFiw61hbW9zIGVuY29udHJhZG8gcXVlIGxhIG1lZGlhIHkgbGEgbWVkaWFuYSBkZWwgcG9yY2VudGFqZSBkZSB2b3RvIGFsIEZyZW50ZSBBbXBsaW8gZGlmZXLDrWFuLgpFc3RvIGxvIGNvbXByb2JhbW9zIHByb2R1Y2llbmRvIGVsIGhpc3RvZ3JhbWEgZGUgZXN0YSB2YXJpYWJsZS4KCmBgYHtyfQpnZ3Bsb3QocmVzMjAxNiwgYWVzKHg9ZmEpKSsKICBnZW9tX2hpc3RvZ3JhbShiaW53aWR0aCA9IDUpKwogIGdlb21fdmxpbmUoeGludGVyY2VwdCA9IDI5LjMsIGNvbG9yID0gInJlZCIpKwogIGdlb21fdmxpbmUoeGludGVyY2VwdCA9IDI0LjUsIGNvbG9yID0gImdyZWVuIikrCiAgeGxhYigiJSBWb3RvIEZBIDIwMTEiKSsKICB5bGFiKCJGcmVjdWVuY2lhIikrCiAgdGhlbWVfY2xhc3NpYygpCmBgYAoKT3RybyBncsOhZmljbyDDunRpbCBlbiBsYSB2aXN1YWxpemFjacOzbiBlcyBlbCBsbGFtYWRvICJib3hwbG90IiBvICJncsOhZmljbyBkZSBjYWphcyIuCkVzdGUgdGlwbyBkZSBncsOhZmljb3Mgc2lydmUgYmFzdGFudGUgcGFyYSBjb21wYXJhciBlbnRyZSBncnVwb3MgZGUgb3RyYSB2YXJpYWJsZS4KClBhcmEgcHJvZHVjaXIgdW4gZ3LDoWZpY28gZGUgY2FqYXMgdXNhbW9zIGxhIGVzcGVjaWZpY2FjacOzbiBgZ2VvbV9ibG94cGxvdCgpYCB5IHBvZGVtb3MgZGVmaW5pciBsb3MgbMOtbWl0ZXMgeSBzYWx0b3MgZGVsIGVqZSBZLgpFc3RlIGdyw6FmaWNvIG5vcyBtdWVzdHJhIHF1ZSBlbCBkaXN0cml0byBjb24gZWwgbWVub3IgcG9yY2VudGFqZSBkZSB2b3RvIGEgRlAgdHV2byB1biBwb2NvIG3DoXMgZGUgNSUgeSBxdWUgZWwgbcOheGltbyBmdWUgZGUgY2FzaSA4MCUuClRhbWJpw6luIG11ZXN0cmEgcXVlIGxhIHZvdGFjacOzbiBtZWRpYW5hIGZ1ZSBkZSA0MCUuCkxvcyBsw61taXRlcyBkZSBsYSBjYWphIHNvbiBlbCBjdWFydGlsIDI1IHkgZWwgY3VhcnRpbCA3NS4KCmBgYHtyfQpnZ3Bsb3QocmVzMjAxNiwgYWVzKHk9ZnApKSsKICBnZW9tX2JveHBsb3QoKSsKICB5bGFiKCIlIFZvdG8gRlAgMjAxMSIpCmBgYAoKRWwgYXNwZWN0byBtw6FzIMO6dGlsIGRlIGxvcyBncsOhZmljb3MgZGUgY2FqYXMgZXMgbGEgY29tcGFyYWNpw7NuLgpQb3IgZWplbXBsbywgc2kgc2UgcXVpc2llcmEgY29tcGFyYXIgZWwgdm90byBhIEZ1ZXJ6YSBQb3B1bGFyIGVudHJlIGRlcGFydGFtZW50b3MgZGVsIHBhw61zLgpQYXJhIGhhY2VyIGVzdG8gc2UgZGViZSBkZWZpbmlyIHF1ZSBsYSB2YXJpYWJsZSBlbiBlbCBlamUgWSBzZWEgZWwgcG9yY2VudGFqZSBkZSB2b3RvcyBhIEZ1ZXJ6YSBQb3B1bGFyICJmcCIgeSBlbiBlbCBlamUgWCBsYSB2YXJpYWJsZSBxdWUgZGVmaW5lIGxvcyBkZXBhcnRhbWVudG9zICJkcHRvIi4KSW5jbHVpbW9zIGxhIGVzcGVjaWZpY2FjacOzbiBgY29vcmRfZmxpcCgpYCBwYXJhIHZvbHRlYXIgbG9zIGVqZXMgeSBxdWUgbGFzIGV0aXF1ZXRhcyBkZSBsb3MgZGVwYXJ0YW1lbnRvcyBzZSBsZWFuIG3DoXMgY2xhcmFtZW50ZS4KCkVuIGVsIGdyw6FmaWNvIHNlIHB1ZWRlbiBoYWNlciB2YXJpYXMgY29tcGFyYWNpb25lcy4KTG8gbcOhcyBpbXBvcnRhbnRlIGVzIGNvbXBhcmFyIG1lZGlhbmFzIHkgYW5jaG9zIGRlIGNhamFzIGVudHJlIGRlcGFydGFtZW50b3MuCkxvcyBwdW50b3MgYWlzbGFkb3Mgc29uICJvdXRsaWVycyIgbyB2YWxvcmVzIGV4dHJlbW9zLCBxdWUgc2UgY2FsY3VsYW4gYXV0b23DoXRpY2FtZW50ZSB5IHNlIGdyYWZpY2FuLgoKRXN0ZSBncsOhZmljbywgc2luIGVtYmFyZ28sIGVzIG11eSBkZXNhZ3JhZ2Fkby4KCmBgYHtyfQpnZ3Bsb3QocmVzMjAxNiwgYWVzKHk9ZnAsIHg9ZHB0bykpKwogIGdlb21fYm94cGxvdCgpKwogIHNjYWxlX3lfY29udGludW91cyhsaW1pdHMgPSBjKDAsIDEwMCksIGJyZWFrcyA9IHNlcSgwLCAxMDAsIDEwKSkrCiAgeWxhYigiJSBWb3RvIEZQIDIwMTEiKSsKICB4bGFiKCJEZXBhcnRhbWVudG8iKSsKICB0aGVtZV9taW5pbWFsKCkrCiAgY29vcmRfZmxpcCgpCmBgYAoKU2kgc2UgcXVpc2llcmEgY29tcGFyYXIgZW50cmUgcmVnaW9uZXMgKGNvc3RhLCBzaWVycmUgeSBzZWx2YSksIHNlIHRlbmRyw61hIHF1ZSBjcmVhciBlc3RhIHZhcmlhYmxlLCBhIHBhcnRpciBkZSBsYSB2YXJpYWJsZSAiZHB0byIuCgojIyBSZWNvZGlmaWNhbmRvIHZhcmlhYmxlcwoKYGBge3J9CmxpYnJhcnkodGlkeXZlcnNlKQpyZXMyMDE2ID0gcmVzMjAxNiB8PgogIG11dGF0ZShyZWdpb24gPSBjYXNlX3doZW4oCiAgICBkcHRvPT0iQU1BWk9OQVMifjMsCiAgICBkcHRvPT0iQU5DQVNIIn4yLAogICAgZHB0bz09IkFQVVJJTUFDIn4yLAogICAgZHB0bz09IkFSRVFVSVBBIn4yLAogICAgZHB0bz09IkFZQUNVQ0hPIn4yLAogICAgZHB0bz09IkNBSkFNQVJDQSJ+MiwKICAgIGRwdG89PSJDVVNDTyJ+MiwKICAgIGRwdG89PSJDQUxMQU8ifjEsCiAgICBkcHRvPT0iSFVBTkNBVkVMSUNBIn4yLAogICAgZHB0bz09IkhVQU5VQ08ifjMsCiAgICBkcHRvPT0iSUNBIn4xLAogICAgZHB0bz09IkpVTklOIn4yLAogICAgZHB0bz09IkxBIExJQkVSVEFEIn4xLAogICAgZHB0bz09IkxBTUJBWUVRVUUifjEsCiAgICBkcHRvPT0iTElNQSJ+MSwKICAgIGRwdG89PSJMT1JFVE8ifjMsCiAgICBkcHRvPT0iTUFEUkUgREUgRElPUyJ+MywKICAgIGRwdG89PSJNT1FVRUdVQSJ+MSwKICAgIGRwdG89PSJQQVNDTyJ+MiwKICAgIGRwdG89PSJQSVVSQSJ+MSwKICAgIGRwdG89PSJQVU5PIn4yLAogICAgZHB0bz09IlNBTiBNQVJUSU4ifjMsCiAgICBkcHRvPT0iVEFDTkEifjEsCiAgICBkcHRvPT0iVFVNQkVTIn4xLAogICAgZHB0bz09IlVDQVlBTEkifjMKICApKSAKYGBgCgpgYGB7cn0KcmVzMjAxNiB8PgogIGNvdW50KFJlZ2lvbiA9IHJlZ2lvbiwgbmFtZT0iRnJlY3VlbmNpYSIpCmBgYAoKTGEgdmFyaWFibGUgY3JlYWRhIGVzIHVuYSB2YXJpYWJsZSBkZSB0aXBvICJudW3DqXJpY28iLgpFbiBSIGV4aXN0ZSBvdHJvIHRpcG8gZGUgdmFyaWFibGUgbGxhbWFkbyAiZmFjdG9yIi4KUG9kZW1vcyBjb252ZXJ0aXIgY3VhbHF1aWVyIHZhcmlhYmxlIGEgdW5hIGRlIGZhY3RvciB5IGV0aXF1ZXRhciBjYWRhIHZhbG9yLgoKYGBge3J9CmxpYnJhcnkoZm9yY2F0cykKcmVzMjAxNiA9IHJlczIwMTYgfD4KICBtdXRhdGUocmVnaW9uMiA9IGZhY3RvcihyZWdpb24sIGxhYmVscz1jKCJDb3N0YSIsICJTaWVycmEiLCAiU2VsdmEiKSkpCmBgYAoKQWhvcmEsIHByb2NlZGVtb3MgYSBwcm9kdWNpciBlbCBncsOhZmljbyBkZSBjYWphcyBkZSBwb3JjZW50YWplIGRlIHZvdG8gYSBGdWVyemEgUG9wdWxhciBwb3IgcmVnacOzbi4KCmBgYHtyfQpnZ3Bsb3QocmVzMjAxNiwgYWVzKHk9ZnAsIHg9cmVnaW9uMikpKwogIGdlb21fYm94cGxvdCgpKwogIHNjYWxlX3lfY29udGludW91cyhsaW1pdHMgPSBjKDAsIDEwMCksIGJyZWFrcyA9IHNlcSgwLCAxMDAsIDIwKSkrCiAgeWxhYigiJSBWb3RvIEZQIDIwMTYiKSsKICB4bGFiKCJSZWdpw7NuIikrCiAgdGhlbWVfZ2V0KCkKYGBgCgpTZSBvYnNlcnZhIGVuIGVzdGUgZ3LDoWZpY28gcXVlIGVsIHZvdG8gbWVkaWFubyBhIEZ1ZXJ6YSBQb3B1bGFyIGZ1ZSBtYXlvciBlbnRyZSBwcm92aW5jaWFzIGRlIGxhIGNvc3RhLCBzZWd1aWRvIHBvciBsYSBzZWx2YSB5IGx1ZWdvIGxhIHNpZXJyYS4KRXN0ZSBtaXNtbyBwYXRyw7NuIHNlIG9ic2VydmEgc2kgY2FsY3Vsw6FyYW1vcyBsYSBtZWRpYSBkZWwgcG9yY2VudGFqZSBkZSB2b3RvIHByb3ZpbmNpYWwgYSBGdWVyemEgUG9wdWxhciBwb3IgcmVnacOzbi4KCmBgYHtyfQpyZXMyMDE2IHw+IAogIGdyb3VwX2J5KHJlZ2lvbjIpIHw+CiAgc3VtbWFyaXNlKG1lYW4oZnApLCBzZChmcCkpCmBgYAoKIyBDYXNvIDE6IMK/bG9zIHBlcnVhbm9zIGxlZW4/CgoqUHJlZ3VudGE6IEV4aXN0ZSB1biBzZW50aWRvIGNvbcO6biBxdWUgaW5kaWNhIHF1ZSBsb3MgcGVydWFub3Mgbm8gbGVlbi4gwr9FcyBhcXVlbGxvIGNpZXJ0bz8gwr9FeGlzdGVuIGRpZmVyZW5jaWFzIGRlIGfDqW5lcm8gbyBzb2Npb2Vjb27Ds21pY2FzIGVuIGxvcyBuaXZlbGVzIGRlIGxlY3R1cmE/KgoKUGFyYSByZXNwb25kZXIgYSBlc3RhIHByZWd1bnRhLCB1c2FyZW1vcyBsYSBFbmN1ZXN0YSBOYWNpb25hbCBkZSBMZWN0dXJhIGRlIDIwMjIuCgpgYGB7cn0KbGlicmFyeShyaW8pCmVubCA9IGltcG9ydCgifi9MaWJyYXJ5L0Nsb3VkU3RvcmFnZS9Hb29nbGVEcml2ZS1hcnR1cm8ubWFsZG9uYWRvQHB1Y3AucGUvTWkgdW5pZGFkL0EgQ3Vyc29zL0VzdGFkaXN0aWNhXzEvRGF0YS9FTkwyMDIyL0VOTDIwMjIuc2F2IikKYGBgCgpFc3RhIGVuY3Vlc3RhIHRpZW5lIHVuYSBwcmVndW50YSBxdWUgaW5kYWdhIGRpcmVjdGFtZW50ZSAoUDQwOCkuCkN1YW5kbyBzZSBpbXBvcnRhIGxvcyBkYXRvcyBhIFIsIGVzdGEgdmFyaWFibGUgc2UgaW1wb3J0YSBjb21vIHVuYSB2YXJpYWJsZSBudW3DqXJpY2EsIGN1YW5kbyBlbiByZWFsaWRhZCwgZXMgdW5hIHZhcmlhYmxlIGRlIHRpcG8gZmFjdG9yLgoKU2UgdXNhIGVsIGNvbWFuZG8gYG11dGF0ZWAgcGFyYSBjcmVhciB1bmEgbnVldmEgdmFyaWFibGUgeSBlbCBjb21hbmRvIGBmYWN0b3JgIHBhcmEgdHJhbnNmb3JtYXIgbGEgdmFyaWFibGUgbnVtw6lyaWNhIGEgdW5hIGRlIGZhY3RvciBjb24gc3VzIHJlc3BlY3Rpdm9zIGBsYWJlbHNgLgoKYGBge3J9CmxpYnJhcnkodGlkeXZlcnNlKQplbmwgPSBlbmwgfD4KICBtdXRhdGUobGVlID0gZmFjdG9yKFA0MDgsIGxhYmVscz1jKCJTw60iLCAiTm8iKSkpCmBgYAoKIyMgRGVzY3JpcGNpw7NuIGRlIHZhcmlhYmxlcyBkZSBmYWN0b3IKClBhcmEgZGVzY3JpYmlyIHZhcmlhYmxlcyBxdWUgbm8gc29uIG51bcOpcmljYXMsIHBvZGVtb3MgcHJvZHVjaXIgdGFibGFzIGRlIGRpc3RyaWJ1Y2nDs24gZGUgZnJlY3VlbmNpYXMuClBvciBlamVtcGxvLCBwb2RlbW9zIGRlc2NyaWJpciBsYSB2YXJpYWJsZSAibGVlIiBkZSBsYSBiYXNlIGRlIGRhdG9zLgpQb2RlbW9zIHVzYXIgZWwgY29tYW5kbyBgY291bnRgIHBhcmEgY2FsY3VsYXIgbGEgdGFibGEgZGUgZGlzdHJpYnVjacOzbiBkZSBmcmVjdWVuY2lhcyBkZSBlc3RhIHZhcmlhYmxlLgpTZSBndWFyZGEgZXN0YSB0YWJsYSBlbiB1biBvYmpldG8gInRhYmxhMSIuCgpgYGB7cn0KdGFibGExID0gZW5sIHw+CiAgZmlsdGVyKGxlZSA9PSAiU8OtIiB8IGxlZSA9PSAiTm8iKSB8PgogIGNvdW50KExlZSA9IGxlZSwgbmFtZT0iRnJlY3VlbmNpYSIpCnRhYmxhMQpgYGAKClBhcmEgY2FsY3VsYXIgbG9zIHBvcmNlbnRhamVzLCBzZSBwdWVkZSBhZ3JlZ2FyIGEgbGEgdGFibGEgdW5hIGNvbHVtbmEgIlBvcmNlbnRhamUiIGNvbiBlbCBjw6FsY3VsbyBkZSBsYSAiRnJlY3VlbmNpYSIgKGNvbHVtbmEgZXhpc3RlbnRlKSBlbnRlIGxhIHN1bWEgdG90YWwgZGUgbGFzIGZyZWN1ZW5jaWFzLgpTZSBlbmN1ZW50cmEgcXVlIEZ1ZXJ6YSBQb3B1bGFyIGdhbsOzIGVuIGVsIDU3JSBkZSBwcm92aW5jaWFzIGRlbCBQZXLDui4KCmBgYHtyfQp0YWJsYTEgPSB0YWJsYTEgfD4KICBtdXRhdGUoUG9yY2VudGFqZSA9IChGcmVjdWVuY2lhIC8gc3VtKEZyZWN1ZW5jaWEpKjEwMCApKQp0YWJsYTEKYGBgCgpQYXJhIGdyYWZpY2FyIHVuYSB2YXJpYWJsZSBkZSB0aXBvIGN1YWxpdGF0aXZhIChvIGRlIGZhY3RvciBlbiBlbCBsZW5ndWFqZSBkZSBSKSwgc2UgZGViZSB1c2FyLCBwb3IgZWplbXBsbywgdW4gZ3LDoWZpY28gZGUgYmFycmFzLgpQb2RlbW9zIGdyYWZpY2FyIGVzdG9zIHBvcmNlbnRhamVzLgoKUGFyYSBlc3RvIHVzYW1vcyBsYSBsaWJyZXLDrWEgYGdncGxvdDJgLCBwZXJvIGFob3JhIG5vIHJlYWxpemFyZW1vcyB1biBoaXN0b2dyYW1hIChubyB1c2FyZW1vcyBgZ2VvbV9oaXN0b2dyYW1gKSwgc2lubyBiYXJyYXMsIGNvbiBgZ2VvbV9iYXJgLgpEZW50cm8gZGUgZXN0ZSBjb21hbmRvIHNlIGHDsWFkZSBgc3RhdD0iaWRlbnRpdHlgIHBhcmEgaW5kaWNhciBxdWUgUiBubyBjYWxjdWxlIG5hZGEgeSBzb2xvIHVzZSBsb3MgZGF0b3MgZGUgInRhYmxhIi4KCmBgYHtyfQpsaWJyYXJ5KGdncGxvdDIpCmdyYWYxID0gZ2dwbG90KHRhYmxhMSwgYWVzKHg9TGVlLHk9UG9yY2VudGFqZSkpKwogIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5Iiwgd2lkdGg9MC41KQpncmFmMQpgYGAKCkxhIGVuY3Vlc3RhIHRhbWJpw6luIGluY2x1eWUgbGEgcHJlZ3VudGEgUDIwOSBzb2JyZSBnw6luZXJvLgpFc3RhIHZhcmlhYmxlIHNlIGltcG9ydGEgY29tbyB1bmEgbnVtw6lyaWNhLCBwb3IgbG8gcXVlIG51ZXZhbWVudGUgbGEgdHJhbnNmb3JtYW1vcyBlbiB1bmEgdmFyaWFibGUgZGUgdGlwbyBmYWN0b3IgInNleG8iIGNvbiBzdXMgZXRpcXVldGFzLgoKYGBge3J9CmVubCA9IGVubCB8PgogIG11dGF0ZShzZXhvID0gZmFjdG9yKFAyMDksIGxhYmVscz1jKCJIb21icmUiLCAiTXVqZXIiKSkpCmBgYAoKQWhvcmEgdXNhbW9zIGVzdGEgdmFyaWFibGUgcGFyYSBjYWxjdWxhciBsYXMgZnJlY3VlbmNpYXMgeSBwb3JjZW50YWplcyBwb3IgZ3J1cG9zIGRlIHNleG8uCgpgYGB7cn0KdGFibGEyID0gZW5sIHw+CiAgZmlsdGVyKGxlZSA9PSAiU8OtIiB8IGxlZSA9PSAiTm8iKSB8PiAKICBncm91cF9ieShzZXhvKSB8PgogIGNvdW50KExlZSA9IGxlZSwgbmFtZT0iTiIpfD4KICBtdXRhdGUodG90YWwgPSBzdW0oTiksIAogICAgICAgICBQb3IgPSBOIC8gdG90YWwgKiAxMDApCnRhYmxhMgpgYGAKCkxhIHRhYmxhIG5vcyBpbmRpY2EgbG9zIHBvcmNlbnRhamVzIGRlIGxvcyBxdWUgc8OtIGxlZW4geSBsb3MgcXVlIG5vIGxlZW4gcG9yIHNleG8uCkNvbW8gc29sbyBxdWVyZW1vcyBncmFmaWNhciBsb3MgcG9yY2VudGFqZXMgZGUgbG9zIHF1ZSBzw60gbGVlbiwgcG9kZW1vcyBlbGltaW5hciBsYXMgZmlsYXMgZGUgbG9zIHF1ZSBubyBsZWVuLgoKYGBge3J9CnRhYmxhMiA9IHRhYmxhMlstYygyLDQpLF0KYGBgCgpDb24gZXN0YSB0YWJsYSByZWR1Y2lkYSwgcG9kZW1vcyBncmFmaWNhcyB1c2FuZG8gYGdncGxvdGAuCkFob3JhIGFncmVnYW1vcyBsYSBjYXBhIGBnZW9tX3RleHRgIHBhcmEgaW5jbHVpciBlbCBkYXRvIGRlbCBwb3JjZW50YWplIGRlbnRybyBkZWwgZ3LDoWZpY28uCgpgYGB7cn0KZ3JhZjIgPSBnZ3Bsb3QodGFibGEyLCBhZXMoeD1zZXhvLCB5PVBvcikpKwogIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5IikrCiAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZShyb3VuZChQb3IsIDEpKSksIHZqdXN0PS0xLCBzaXplPTMpKwogIGxhYnMoeD0iU2V4byIsIHk9IlBvcmNlbnRhamUiKSsKICB0aGVtZV9jbGFzc2ljKCkKZ3JhZjIKYGBgCgpMYSBiYXNlIGRlIGRhdG9zIGluY2x1eWUgdW5hIHZhcmlhYmxlICJuc2UiLCBxdWUgcmVmaWVyZSBhbCBuaXZlbCBzb2Npb2Vjb27Ds21pY28gZGUgbGEgcGVyc29uYSBxdWUgcmVzcG9uZGUuCkVzdGUgbml2ZWwgc29jaW9lY29uw7NtaWNvIGVzdMOhIGNhdGVnb3JpemFkbyBlbiA0IG5pdmVsZXMuCgpgYGB7cn0KZW5sID0gZW5sIHw+CiAgbXV0YXRlKG5zZSA9IGZhY3Rvcihuc2UsIGxhYmVscz1jKCJSdXJhbCIsICJCYWpvIiwgIk1lZGlvIiwgIkFsdG8iKSkpCmBgYAoKUGFzYW1vcyBhIGNhbGN1bGFyIGxvcyBwb3JjZW50YWplcyBkZSBsZWN0dXJhIHBvciBsb3MgNCBuaXZlbGVzIHNvY2lvZWNvbsOzbWljb3MuCgpgYGB7cn0KdGFibGEzID0gZW5sIHw+CiAgZmlsdGVyKGxlZSA9PSAiU8OtIiB8IGxlZSA9PSAiTm8iKSB8PiAKICBncm91cF9ieShuc2UpIHw+CiAgY291bnQoTGVlID0gbGVlLCBuYW1lPSJOIil8PgogIG11dGF0ZSh0b3RhbCA9IHN1bShOKSwgCiAgICAgICAgIFBvciA9IE4gLyB0b3RhbCAqIDEwMCkKdGFibGEzCmBgYAoKTnVldmFtZW50ZSBlbGltaW5hbW9zIGxhcyBmaWxhcyBkZSBsb3MgcG9yY2VudGFqZXMgZGUgYXF1ZWxsb3MgcXVlIG5vIGxlZW4uCgpgYGB7cn0KdGFibGEzID0gdGFibGEzWy1jKDIsNCw2LDgpLF0KYGBgCgpZIGdyYWZpY2Ftb3MgbG9zIHBvcmNlbnRhamVzIGRlIGxvcyBxdWUgc8OtIGxlZW4gcG9yIG5pdmVsZXMgc29jaW9lY29uw7NtaWNvcy4KCmBgYHtyfQpncmFmMyA9IGdncGxvdCh0YWJsYTMsIGFlcyh4PW5zZSwgeT1Qb3IpKSsKICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIpKwogIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUocm91bmQoUG9yLCAxKSkpLCB2anVzdD0tMSwgc2l6ZT0zKSsKICBsYWJzKHg9Ik5TRSIsIHk9IlBvcmNlbnRhamUiKSsKICB0aGVtZV9jbGFzc2ljKCkKZ3JhZjMKYGBgCgojIyBUYXJlYQoKU2UgZW5jb250csOzIHF1ZSB1bmEgbWF5b3IgcHJvcG9yY2nDs24gZGUgbXVqZXJlcyBxdWUgaG9tYnJlcyBsZWUuCsK/Q3XDoW50b3MgbGlicm9zIGltcHJlc29zIHkgZGlnaXRhbGVzIGxlZSBlbCBwZXJ1YW5vIHByb21lZGlvPwrCv0V4aXN0ZW4gZGlmZXJlbmNpYXMgZW50cmUgaG9tYnJlcyB5IG11amVyZXMgZW50cmUgZWwgcHJvbWVkaW8gZGUgbGlicm9zIGltcHJlc29zIHkgZGlnaXRhbGVzIHF1ZSBsZWVuPwrCv0VudHJlIG5pdmVsZXMgc29jaW9lY29uw7NtaWNvcz8KCiMgQ2FzbyAyOiBFbmN1ZXN0YSBOYWNpb25hbCBEb2NlbnRlIDIwMjAKCkNhZGEgZG9zIGHDsW9zLCBlbCBNaW5pc3RlcmlvIGRlIEVkdWNhY2nDs24gcmVhbGl6YSB1bmEgZW5jdWVzdGEgYSB1bmEgbXVlc3RyYSBkZSBkb2NlbnRlcyBkZSBlZHVjYWNpw7NuIGLDoXNpY2EgZW4gZWwgUGVyw7ouCkxhIMO6bHRpbWEgZGlzcG9uaWJsZSBmdWUgaGVjaGEgZW4gMjAyMCwgZW4gbWVkaW8gZGUgbGEgcGFuZGVtaWEgZGVsIENPVklELTE5LgpMYXMgYmFzZXMgZGUgZGF0b3MgeSBjdWVzdGlvbmFyaW9zIGRlIGVzdGEgZW5jdWVzdGEgc2UgZW5jdWVudHJhbiBkaXNwb25pYmxlcyBbYXF1w61dKGh0dHA6Ly93d3cubWluZWR1LmdvYi5wZS9wb2xpdGljYXMvZG9jZW5jaWEvZW5jdWVzdGEtbmFjaW9uYWwtYS1kb2NlbnRlcy1lbmRvLnBocCkuCgpFbiBlc3RhIHViaWNhY2nDs24gc2UgZW5jdWVudHJhIGxhIGJhc2UgZGUgZGF0b3MsIHF1ZSBwdWVkZSBzZXIgZGVzY2FyZ2FkYSB5IGxlw61kYSBlbiBSIGNvbiBlbCBzaWd1aWVudGUgY8OzZGlnby4KCmBgYHtyIGVuZG99CmxpYnJhcnkocmlvKQplbmRvMjAyMCA9IGltcG9ydCgiYmFzZXMvRU5ET19SRU1PVE9fMjAyMC5kdGEiKQojQ0FNQklBUiBBIFBST1BJTyBESVJFQ1RPUklPIERFIFRSQUJBSk8KYGBgCgojIEVzdGltYWNpw7NuIHB1bnR1YWwKCkRlIHVuYSB2YXJpYWJsZSBudW3DqXJpY2EsIGxhIG1lZGlkYSBkZSB0ZW5kZW5jaWEgY2VudHJhbCBtw6FzIMO6dGlsIGVzIGxhIG1lZGlhLgpMYSBlbmN1ZXN0YSBhIGRvY2VudGVzIGluY2x1eWUgbGEgcHJlZ3VudGE6Cgo2LiAgwr9BIGN1w6FudG9zIGVzdHVkaWFudGVzIGxlIGJyaW5kYSBhY29tcGHDsWFtaWVudG8gY29tbyBkb2NlbnRlIGRlIGF1bGEgZW4gZXN0YSBJRT8gKFZlciBjdWVzdGlvbmFyaW8pCgpEZSBlc3RhIHByZWd1bnRhIHBvZGVtb3MgcHJlZ3VudGFybm9zOiDCv0EgY3XDoW50b3MgYWx1bW5vcyBlbiBwcm9tZWRpbyBhY29tcGHDsWEgZWwgZG9jZW50ZSBwZXJ1YW5vIGVuIGF1bGE/CkVzdGEgZW5jdWVzdGEgdGllbmUgdW5hIHByZWd1bnRhIHF1ZSBub3MgcGVybWl0ZSBjYWxjdWxhciBlc3RhIG1lZGlhIHkgbGEgZGVzdmlhY2nDs24gZXN0w6FuZGFyLgoKYGBge3IgZGVzYyBhbHVtbm9zLCBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQpsaWJyYXJ5KGRwbHlyKQpsaWJyYXJ5KHRpZHl2ZXJzZSkKZW5kbzIwMjAgfD4gCiAgc3VtbWFyaXplKE1lZGlhID1tZWFuKFAxXzYsIG5hLnJtID0gVCksIERlc3YuU3RkID0gc2QoUDFfNiwgbmEucm0gPSBUKSkKYGBgCgpFcyBkZWNpciwgdW4gcHJvZmVzb3IgcHJvbWVkaW8gZW4gUGVyw7ogYWNvbXBhw7FhIGFwcm94aW1hZGFtZW50ZSBhIDQwIGFsdW1ub3MgZW4gYXVsYS4Kwr9FeGlzdGVuIGRpZmVyZW5jaWFzIGVuIGVsIG7Dum1lcm8gcHJvbWVkaW8gZGUgYWx1bW5vcyBxdWUgYWNvbXBhw7FhbiBkb2NlbnRlcyBob21icmVzIHkgZG9jZW50ZXMgbXVqZXJlcz8KCkN1YW5kbyBzZSBpbXBvcnRhIGxhIGJhc2UgZGUgZGF0b3MsIGxhIHZhcmlhYmxlIHNleG8sIFAxXzEsIGVzIGRlZmluaWRhIGNvbW8gbnVtw6lyaWNhLgoKYGBge3J9CnN0cihlbmRvMjAyMCRQMV8xKQpgYGAKCkxhIHBvZGVtb3MgdHJhbnNmb3JtYXIgYSB1bmEgdmFyaWFibGUgZGUgdGlwbyBmYWN0b3IuCgpgYGB7cn0KZW5kbzIwMjAgPSBlbmRvMjAyMCB8PgogIG11dGF0ZShzZXhvID0gZmFjdG9yKFAxXzEsIGxhYmVscz1jKCJIb21icmUiLCAiTXVqZXIiKSkpCmBgYAoKQ2FsY3VsYW1vcyBsb3MgZGF0b3MgcGFyYSBob21icmVzIHkgbXVqZXJlcy4KCmBgYHtyIGRvY2VudGVzIGhvbWJyZX0KdGFibGExID0gZW5kbzIwMjAgfD4gCiAgZ3JvdXBfYnkoc2V4bykgfD4KICBzdW1tYXJpemUoTWVkaWEgPSBtZWFuKFAxXzYsIG5hLnJtID0gVCksIAogICAgICAgICAgICBEZXN2LlN0ZCA9IHNkKFAxXzYsIG5hLnJtID0gVCksCiAgICAgICAgICAgIE1lZGlhbmEgPSBtZWRpYW4oUDFfNiwgbmEucm0gPSBUKSkKdGFibGExCmBgYAoKU2UgZW5jdWVudHJhIHF1ZSBsb3MgZG9jZW50ZXMgaG9tYnJlcyBhY29tcGHDsWFuLCBlbiBwcm9tZWRpbywgYSA1MiBhbHVtbm9zLCBtaWVudHJhcyBxdWUgbGFzIGRvY2VudGVzIG11amVyZXMgYWNvbXBhw7FhbiBhIDM0IGFsdW1ub3MsIHVuYSBkaWZlcmVuY2lhIGRlIDE4IGFsdW1ub3MgZW4gcHJvbWVkaW8uCgpUb2RvcyBlc3RvcyByZXN1bHRhZG9zIHNvbiBwdW50dWFsZXMgeSBhcGxpY2FuIHBhcmEgbGEgbXVlc3RyYSBkZSAyOCwyMTYgcHJvZmVzb3Jlcy4KClBhcmEgdW5hIGNvbXBhcmFjacOzbiBncsOhZmljYSwgc2UgcHVlZGUgdXNhciBib3hwbG90LgoKYGBge3J9CmxpYnJhcnkoZ2dwbG90MikKZ2dwbG90KGVuZG8yMDIwLCBhZXMoeT1QMV82LCB4PXNleG8pKSsKICBnZW9tX2JveHBsb3QoKQpgYGAKCmBgYHtyfQplbmRvMjAyMCA9IGVuZG8yMDIwIHw+CiAgbXV0YXRlKGNvbmRpY2lvbiA9IGZhY3RvcihQMV83LCBsYWJlbHM9YygiTm9tYnJhZG8iLCAiQ29udHJhdGFkbyB4IGNvbmN1cnNvIiwgIkNvbnRyYXRhZG8gb3RybyIpKSkKYGBgCgpgYGB7cn0KdGFibGEyID0gZW5kbzIwMjAgfD4gCiAgZ3JvdXBfYnkoY29uZGljaW9uKSB8PgogIHN1bW1hcml6ZShNZWRpYSA9IG1lYW4oUDFfNiwgbmEucm0gPSBUKSwgCiAgICAgICAgICAgIERlc3YuU3RkID0gc2QoUDFfNiwgbmEucm0gPSBUKSwKICAgICAgICAgICAgTWVkaWFuYSA9IG1lZGlhbihQMV82LCBuYS5ybSA9IFQpKQp0YWJsYTIKYGBgCgpgYGB7cn0KbGlicmFyeShnZ3Bsb3QyKQpsaWJyYXJ5KHRpZHl2ZXJzZSkKZW5kbzIwMjAgfD4KICBkcm9wX25hKFAxXzYpIHw+CiAgZ2dwbG90KGFlcyh5PVAxXzYsIHg9Y29uZGljaW9uKSkrCiAgZ2VvbV9ib3hwbG90KCkKYGBgCgpgYGB7cn0KZ2dwbG90KHN1YnNldChlbmRvMjAyMCwgIWlzLm5hKFAxXzYpKSwgYWVzKHk9UDFfNiwgeD1jb25kaWNpb24pKSsKICBnZW9tX2JveHBsb3QoKQpgYGAKClNpIHNlIHF1aWVyZSBoYWNlciB1biBncsOhZmljbyBkZSBiYXJyYXMgc2ltcGxlcyBwYXJhIG1vc3RyYXIgbGEgbWVkaWEgZGVsIG7Dum1lcm8gZGUgYWx1bW5vcyBwb3Igc2V4byBkZWwgcHJvZmVzb3IsIHNlIHB1ZWRlIHVzYXI6CgpgYGB7cn0KZ2dwbG90KHRhYmxhMSwgYWVzKHg9c2V4bywgeT1NZWRpYSkpICsgCiAgZ2VvbV9iYXIoc3RhdCA9ICJpZGVudGl0eSIpICsKICBnZ3RpdGxlKCJOw7ptZXJvIGRlIGFsdW1ub3MgcHJvbWVkaW8gcG9yIHNleG8gZGVsIGRvY2VudGUiKSArCiAgeGxhYigiU2V4byBkZWwgZG9jZW50ZSIpICsKICBnZW9tX3RleHQoYWVzKGxhYmVsPXJvdW5kKE1lZGlhLDEpKSwgdmp1c3Q9MS4zMCwgY29sb3I9IndoaXRlIiwgc2l6ZT0zKSsKICB0aGVtZV9taW5pbWFsKCkKYGBgCgrCv0PDs21vIHNlIHB1ZWRlbiBleHRyYXBvbGFyIGVzdG9zIHJlc3VsdGFkb3MgYWwgdW5pdmVyc28gZGUgcHJvZmVzb3JlcyBwZXJ1YW5vcz8KCiMgRXN0aW1hY2nDs24gcG9yIGludGVydmFsb3MKClRhbnRvIGxhIG1lZGlhIG11ZXN0cmFsLCBjb21vIGxhIHByb3BvcmNpw7NuIG11ZXN0cmFsLCBzb24gZXN0aW1hY2lvbmVzIHB1bnR1YWxlcywgYmFzYWRvcyBlbiBsb3MgcmVzdWx0YWRvcyBkZSBsYSBtdWVzdHJhLgpFcyBkZWNpciwgZXN0YXMgc29uIGVzdGltYWNpb25lcyBjb3JyZXNwb25kaWVudGVzIGEgbGFzIDI4LDIxNiBvYnNlcnZhY2lvbmVzIHF1ZSBzb24gcGFydGUgZGUgZXN0ZSBlc3R1ZGlvLgpTaW4gZW1iYXJnbywgZXN0YSBtdWVzdHJhIGZvcm1hIHBhcnRlIGRlIHVuIHVuaXZlcnNvIG8gcG9ibGFjacOzbiAoZWwgY29uanVudG8gZGUgcHJvZmVzb3JlcyBkZWwgUGVyw7opLCBkZWwgcXVlIHNlZ3VyYW1lbnRlIHNlIHF1aWVyZSBkZWNpciBhbGdvLgoKRWwgbWlzbW8gcmF6b25hbWllbnRvIGFwbGljYSBhIHVuYSBlbmN1ZXN0YSBkZSBvcGluacOzbiBjb252ZW5jaW9uYWwuCkxhIGZpY2hhIHTDqWNuaWNhIGRlIHVuYSBlbmN1ZXN0YSBtZW5jaW9uYSwgZ2VuZXJhbG1lbnRlLCBlbCB0YW1hw7FvIGRlIG11ZXN0cmEgeSBsYSBwb2JsYWNpw7NuIGEgbGEgcXVlIHNlIGJ1c2NhIHJlcHJlc2VudGFyLgpUYW1iacOpbiBzZSBwdWVkZSBlbmNvbnRyYXIgZWwgbWFyZ2VuIGRlIGVycm9yICgrLy0gMi44JSkgeSBlbCBuaXZlbCBkZSBjb25maWFuemEgKGdlbmVyYWxtZW50ZSBkZSA5NSUpLihWZXIsIHBvciBlamVtcGxvLCBsYSBbZW5jdWVzdGEgZGUgb3BpbmnDs24gZGUgYWdvc3RvIDIwMjMgZGUgSXBzb3NdKGh0dHBzOi8vd3d3Lmlwc29zLmNvbS9zaXRlcy9kZWZhdWx0L2ZpbGVzL2N0L25ld3MvZG9jdW1lbnRzLzIwMjMtMDgvSW5mb3JtZSUyMEVuY3Vlc3RhJTIwTmFjaW9uYWwlMjBVcmJhbm8lMjBSdXJhbCUyMC0lMjBBbWVyaWNhJTIwVGVsZXZpc2nDs24lMjBhbCUyMDExJTIwZGUlMjBhZ29zdG8lMjAyMDIzJTIwRXN0dWRpbyUyMGRlJTIwT3BpbmnDs24ucGRmKS4KCkVsIHByb2Nlc28gbWVkaWFudGUgZWwgY3VhbCBzZSBwYXJ0ZSBkZSB1bmEgbXVlc3RyYSBwYXJhIGRlY2lyIGFsZ28gZGUgdW4gdW5pdmVyc28gbyBwb2JsYWNpw7NuIGVzIHVuIHByb2Nlc28gZGUgaW5mZXJlbmNpYSB5IGVzIHBhcnRlIGRlIGxhIGVzdGFkw61zdGljYSBpbmZlcmVuY2lhbC4KTGEgZXN0YWTDrXN0aWNhIGluZmVyZW5jaWFsIGludHJvZHVjZSBsYSAqKmluY2VydGlkdW1icmUqKiBlbiBsb3MgZXN0aW1hZG9zLCBkZWJpZG8gYWwgaGVjaG8gZGUgZXN0YXIgdHJhYmFqYW5kbyBjb24gdW5hIG11ZXN0cmEgeSBubyBjb24gZWwgdG90YWwgZGUgb2JzZXJ2YWNpb25lcyBkZWwgdW5pdmVyc28uCgojIyBVbiBicmV2ZSBwYXNlbyBwb3IgbGFzIHByb2JhYmlsaWRhZGVzCgpQYXJ0aW1vcyBkZWwgaGVjaG8gcXVlIGVuIGVsIGNvbcO6biBkZSBsYXMgaW52ZXN0aWdhY2lvbmVzIHVubyB0aWVuZSBxdWUgc2VsZWNjaW9uYXIgdW4gY29uanVudG8gZGUgb2JzZXJ2YWNpb25lcyBxdWUgc29uIHBhcnRlIGRlbCB0b3RhbCwgcXVlIGVzIG11eSBjb3N0b3NvIGUgaW5lZmljaWVudGUgaGFjZXIgdW4gZXN0dWRpbyBkZSBsYSBwb2JsYWNpw7NuIGNvbXBsZXRhLgpMYSBhbmFsb2fDrWEgZXMsIHBvciBlamVtcGxvLCBxdWUgcGFyYSB1biBhbsOhbGlzaXMgZGUgc2FuZ3JlIHNlIGV4dHJhZSB1bmEgIm11ZXN0cmEiIGRlIHNhbmdyZSB5IG5vIGVsIHRvdGFsIGRlIHNhbmdyZSBkZWwgY3VlcnBvLgoKQSBlc3RvIGxlIHN1bWFtb3MgZWwgaGVjaG8gcXVlIG51ZXN0cmFzIGhlcnJhbWllbnRhcyBkZSByZWNvam8gZGUgaW5mb3JtYWNpw7NuIHNvbiBpbXBlcmZlY3Rhcy4KVW4gZXN0dWRpbyB0cmFuc3ZlcnNhbCwgcG9yIGVqZW1wbG8sIGRlYmVyw61hIHJlY29nZXIgaW5mb3JtYWNpw7NuIGRlIGxvcyBpbmRpdmlkdW9zIGVuIHVuIGNvcnRlIGVuIGVsIHRpZW1wbywgc2luIGVtYmFyZ28sIG11Y2hvcyBlc3R1ZGlvcyBubyBzb24gdW5hICJmb3RvIGRlbCBtb21lbnRvIiwgcHVlcyBsYXMgb2JzZXJ2YWNpb25lcyB0b21hbiB0aWVtcG8geSBhYmFyY2FuIGhvcmFzLCBkw61hcyBvIHNlbWFuYXMsIHNpbm8gbWVzZXMuCgpFcyBwb3IgZXN0ZSBtb3Rpdm8gcXVlIHBhcmEgdW4gZXN0dWRpbyBzZSBzZWxlY2Npb25hICJ1bmEiIG11ZXN0cmEsIHVuIGNvbmp1bnRvIGRlIG9ic2VydmFjaW9uZXMgcXVlIHNvbiB1bmEgZnJhY2Npw7NuIGRlbCB0b3RhbC4KRXN0YSBzZWxlY2Npw7NuIHNlIGhhY2Ugc2lndWllbmRvIHByb2NlZGltaWVudG9zIGFsZWF0b3Jpb3MsIGRlIHRhbCBtYW5lcmEgcXVlIGN1YWxxdWllciB1bmlkYWQgZGVsIHVuaXZlcnNvIHRlbmdhIGxhIG1pc21hIHByb2JhYmlsaWRhZCBkZSBzZXIgc2VsZWNjaW9uYWRhLgoKRWwgcHVudG8gZXMgcXVlIGVzdGEgw7puaWNhIG11ZXN0cmEgZXMgc29sbyB1bmEgZGUgbGFzIG3Dumx0aXBsZXMgbXVlc3RyYXMgdGXDs3JpY2FzIHF1ZSBzZSBwb2Ryw61hbiBzZWxlY2Npb25hciBkZSB1biB1bml2ZXJzbyBkZXRlcm1pbmFkby4KClBhcnRhbW9zIGRlIHVuIGVqZW1wbG8gbXV5IHNpbXBsZS4KUGFyYSB1biB1bml2ZXJzbyBkZSA1IHBlcnNvbmFzLCBzZSBwdWVkZW4gZXh0cmFlciAxMCBtdWVzdHJhcyBkZSB0YW1hw7FvIDIgZGlmZXJlbnRlcy4KCiFbXShtdWVzdHJhMS5qcGVnKQoKTGEgZsOzcm11bGEgcGFyYSBjYWxjdWxhciBlbCBuw7ptZXJvIGRlIG11ZXN0cmFzIHByb2JhYmxlcyBlcyBsYSBkZSBjb21iaW5hdG9yaWFzLCBxdWUgaW5jbHV5ZSBlbCBvcGVyYWRvciBmYWN0b3JpYWwuClNpIGFwbGljYW1vcyBlc3RhIGbDs3JtdWxhIGEgdW4gZWplbXBsbyBkZSB1biB1bml2ZXJzbyBtw6FzIGdyYW5kZSwgcG9yIGVqZW1wbG8sIHVuIHNhbMOzbiBkZSBjbGFzZSBkZSA1MCBhbHVtbm9zLCBkb25kZSBzZSBxdWllcmUgc2FiZXIgY3XDoW50YXMgbXVlc3RyYXMgZGlmZXJlbnRlcyBkZSB0YW1hw7FvIDQgc2UgcHVlZGVuIGV4dHJhZXIuClNlZ8O6biBsYSBmw7NybXVsYToKCiQkClxmcmFjezUwIX0geyg1MC00KSEgNCF9ID0gXGZyYWN7NTAhfSB7NDYhIDQhfSA9IFxmcmFjezUwKjQ5KjQ4KjQ3fSB7NCozKjJ9ID0gMjMwLDMwMAokJAoKUGFyYSB1biBzb25kZW8gZGUgb3BpbmnDs24sIGRvbmRlIGVsIHVuaXZlcnNvIHNvbiAyNCBtaWxsb25lcyBkZSBpbmRpdmlkdW9zIHkgc2UgcXVpZXJlIHNhYmVyIGN1w6FudGFzIG11ZXN0cmFzIGRpZmVyZW50ZXMgZGUgdGFtYcOxbyAxLDUwMCBzZSBwdWVkZW4gZXh0cmFlciwgZXN0ZSBuw7ptZXJvIGRlIG11ZXN0cmFzIHByb2JhYmxlcyBlcyBtdXV1dXkgZ3JhbmRlLgoKVm9sdmllbmRvIGFsIGVqZW1wbG8gbXV5IHNpbXBsZSBkZSA1IHBlcnNvbmFzIGRvbmRlIHNlIHF1aWVyZSBleHRyYWVyIHVuYSBtdWVzdHJhIGRlIDIgeSBzZSBxdWllcmUgaW5mZXJpciBsb3MgZGF0b3MgZGUgbGEgbXVlc3RyYSBkZSBkb3MgdmFyaWFibGVzOiBzZXhvIHkgZWRhZC4KClNlIHRpZW5lIHVuIHVuaXZlcnNvIGRlIDUgaW5kaXZpZHVvcywgY2FkYSB1bm8gY29uIHN1IHNleG8geSBlZGFkLgpFbiBsYSBwb2JsYWNpw7NuIGxhIHByb3BvcmNpw7NuIGRlIGhvbWJyZXMgZXMgZGUgNjAlIHkgbGEgbWVkaWEgZGUgZWRhZCBlcyBkZSAzNCBhw7Fvcy4KCiFbXShtdWVzdHJhMi5qcGVnKQoKU2kgcXVlcmVtb3MgZXh0cmFlciB1bmEgbXVlc3RyYSBkZSB0YW1hw7FvIGRlIDIgZGUgZXNlIHVuaXZlcnNvLCBzZSB0aWVuZW4gMTAgcG9zaWJsZXMgbXVlc3RyYXMsIGNhZGEgdW5hIHRlbmRyw6EgdW5hIGFwcm94aW1hY2nDs24gZGUgbGEgcHJvcG9yY2nDs24gZGUgaG9tYnJlcyB5IGRlIGxhIG1lZGlhIGRlIGVkYWQuCkRlcGVuZGllbmRvIGRlIHF1w6kgbXVlc3RyYSBkZSB0b2RhcyBsYXMgcG9zaWJsZXMgc2VhIGxhIHF1ZSBzZSBvYnNlcnZhLCBsb3MgZXN0YWTDrXN0aWNvcyBzZXLDoW4gdW5hIGFwcm94aW1hY2nDs24gZGUgbG9zIHBhcsOhbWV0cm9zIHBvYmxhY2lvbmFsZXMuCgpFbiBlbCBjYXNvIGRlIGxhIHByb3BvcmNpw7NuIGRlIGhvbWJyZXMsIHNlIHB1ZWRlIHRhYnVsYXIgbG9zIHJlc3VsdGFkb3MgZGUgY2FkYSBtdWVzdHJhIHByb2JhYmxlLgoKfCBSZXN1bHRhZG9zIG11ZXN0cmFsZXMgfCBOw7ptZXJvIGRlIG11ZXN0cmFzIHF1ZSBhcnJvamFyb24gZXNlIHJlc3VsdGFkbyB8IEZyZWN1ZW5jaWEgfAp8Oi0tLS0tLS0tLS0tLS0tLS06fDotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tOnw6LS0tLS0tLS0tLS0tLS0tLS18CnwgICAgICAgICAgMCUgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICAgIDEgICAgICAgICAgICAgICAgICAgICAgICB8IFggICAgICAgICAgfAp8ICAgICAgICAgIDUwJSAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICA1ICAgICAgICAgICAgICAgICAgICAgICAgfCBYWFhYWCAgICAgIHwKfCAgICAgICAgIDEwMCUgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgNCAgICAgICAgICAgICAgICAgICAgICAgIHwgWFhYWCAgICAgICB8CgpJbmNsdXNvIHNlIHBvZHLDrWEgY2FsY3VsYXIgdW4gcHJvbWVkaW8gZGUgdG9kYXMgZXNhcyBwcm9wb3JjaW9uZXMgbXVlc3RyYWxlcyAoMTAwKzUwKzEwMCsuLi4rNTAvMTApLCB5IGVzZSByZXN1bHRhZG8gc2Vyw61hIDY1JSwgdW4gcmVzdWx0YWRvIGFsZ28gY2VyY2EgZGUgbGEgcHJvcG9yY2nDs24gcG9ibGFjaW9uYWwgZGUgNjAlLgoKRXN0ZSBtaXNtbyBwcm9jZWRpbWllbnRvIHNlIHBvZHLDrWEgaGFjZXIgcGFyYSB0b2RhcyBsYXMgMjMwLDMwMCBtdWVzdHJhcyBwcm9iYWJsZXMgZGUgdGFtYcOxbyA0IGRlIHVuIHVuaXZlcnNvIGRlIDUwIGFsdW1ub3MuCkNhZGEgdW5vIGRlIGxvcyA1MCBhbHVtbm9zIHNlcsOhIGhvbWJyZSBvIG11amVyIHkgbGEgcHJvcG9yY2nDs24gcG9ibGFjaW9uYWwgZGUgaG9tYnJlcyBzZSBwdWVkZSBjYWxjdWxhciBlbiBlc2UgdG90YWwuCkEgc3UgdmV6LCBjYWRhIG11ZXN0cmEgZGUgNCwgdGVuZHLDoSB1bmEgcHJvcG9yY2nDs24gbXVlc3RyYWwgcXVlIHRlbmRyw6EgdmFsb3JlcyAoMCBzaSBubyBoYXkgbmluZ8O6biBob21icmUsIDI1JSBzaSBoYXkgMSBob21icmUsIDUwJSBzaSBoYXkgMiBob21icmVzLCA3NSUgc2kgaGF5IDMgaG9tYnJlcyB5IDEwMCUgc2kgdG9kb3Mgc29uIGhvbWJyZXMpLgpGaW5hbG1lbnRlLCBzZSBwdWVkZSBjb250YXIgY3XDoW50YXMgZGUgbGFzIDIzMCwzMDAgbXVlc3RyYXMgcHJvYmFibGVzIHR1dmllcm9uIDAlLCAyNSUsIDUwJSwgNzUlIHkgMTAwJSBkZSBob21icmVzLgpFc3RhIGRpc3RyaWJ1Y2nDs24gc2UgbGxhbWEgIioqZGlzdHJpYnVjacOzbiBkZSBtdWVzdHJlbyoqIi4KClNpIHF1aXNpw6lyYW1vcyBhbXBsaWFyIGVsIHRhbWHDsW8gZGUgbXVlc3RyYSBhIDEwLCBlbnRvbmNlcyBsb3MgcmVzdWx0YWRvcyBwb3NpYmxlcyBzZXLDrWFuLCAwLCAxMCwgMjAsIDMwLCA0MCwgNTAsIDYwLCA3MCwgODAsIDkwIHkgMTAwJS4KVGFtYmnDqW4gcG9kcsOtYW1vcyBjb250YXIgY3XDoW50YXMgbXVlc3RyYXMgdGllbmVuIGVzdG9zIHJlc3VsdGFkb3MuCgpEZSB1biB1bml2ZXJzbyBtw6FzIGdyYW5kZSwgc2UgcHVlZGUgcGxhbnRlYXIgZXh0cmFlciBtdWVzdHJhcyBkZSB0YW1hw7FvIG3DoXMgZ3JhbmRlLgpQb3IgZWplbXBsbywgdGXDs3JpY2FtZW50ZSBzZSBwdWVkZSBwZW5zYXIgcXVlIGRlIHVuIHVuaXZlcnNvIGRlIDIwIG1pbGxvbmVzLCBzZSBwdWVkZW4gZXh0cmFlciBjYXNpIGluZmluaXRhcyBtdWVzdHJhcyBkZSB0YW1hw7FvIDEsNTAwLgpDYWRhIHVuYSBkZSBlc3RhcyBtdWVzdHJhcyB0ZW5kcsOhIHVuIGVzdGFkw61zdGljbyBxdWUgc2Vyw6EgdW5hIGFwcm94aW1hY2nDs24gZGVsIHBhcsOhbWV0cm8uCkxvcyBlc3RhZMOtc3RpY29zIGRlIHRvZGFzIGVzdGFzIGNhc2kgaW5maW5pdGFzIG11ZXN0cmFzIHNlIHB1ZWRlbiB0YWJ1bGFyIHkgZ3JhZmljYXIuCgojIyBUZW9yZW1hIGRlbCBsw61taXRlIGNlbnRyYWwKCkVzdGUgdGVvcmVtYSBtdWVzdHJhIHF1ZSBsYSAqKmRpc3RyaWJ1Y2nDs24gZGUgbXVlc3RyZW8gc2UgYXByb3hpbWEgYSB1bmEgZGlzdHJpYnVjacOzbiBub3JtYWwqKiwgY29uIGNlbnRybyBlbiBlbCBwYXLDoW1ldHJvLCBlbiBsYSBtZWRpZGEgcXVlIGVsIHRhbWHDsW8gZGUgbXVlc3RyYSBhdW1lbnRhLgoKRXN0byBzZSBwdWVkZSBtb3N0cmFyIGdyw6FmaWNhbWVudGUgZW4gZWwgVGFibGVybyBkZSBHYWx0b24sIHZlciBbYXF1w61dKGh0dHBzOi8veW91dHUuYmUvQXdFYUhDamdlWGs/c2k9YTAtd2ZHLWZuZzRIWXNSUSkKClBvciBsbyB0YW50bywgbGEgZGlzdHJpYnVjacOzbiBkZSBtdWVzdHJlbyBkZSBOIGdyYW5kZXMgcGFyYSBjdWFscXVpZXIgdmFyaWFibGUgc2VndWlyw6EgbGFzIGNhcmFjdGVyw61zdGljYXMgZGUgY3VhbHF1aWVyIGN1cnZhIG5vcm1hbC4KVG9kYSBjdXJ2YSBub3JtYWwgZXMgc2ltw6l0cmljYSB5IHNhYmVtb3MgcXVlIHNpIGRlc2RlIGVsIGNlbnRybyBzZSBkZXNwbGF6YSAxIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBlbiBhbWJhcyBkaXJlY2Npb25lcywgZW50cmUgZXNvcyBsw61taXRlcyBlc3RhcsOhbiBlbCA2OC4zJSBkZSB0b2RhcyBsYXMgb2JzZXJ2YWNpb25lcy4KU2kgc2UgZGVzcGxhemEgMiBkZXN2aWFjaW9uZXMgZXN0w6FuZGFyIGVuIGFtYmFzIGRpcmVjY2lvbmVzLCBzZSBhY3VtdWxhcsOtYW4gZWwgOTUuNCUgZGUgdG9kYXMgbGFzIG9ic2VydmFjaW9uZXMuCkNvbiAzIGRlc3ZpYWNpb25lcyBlc3TDoW5kYXIgaGFjaWEgYW1ib3MgbGFkb3MsIHNlIGFjdW11bGFyw61hIGVsIDk5LjclIGRlIHRvZGFzIGxhcyBvYnNlcnZhY2lvbmVzLgoKIVtdKGMzLjMucG5nKXt3aWR0aD0iNTEwIn0KClRyYWR1Y2llbmRvIGEgbGEgZGlzdHJpYnVjacOzbiBkZSBtdWVzdHJlbywgbGEgaWRlYSBlcyBxdWUgc2kgc2UgdGFidWxhbiB5IHNlIGhhY2UgdW4gZ3LDoWZpY28gZGUgYmFycmFzIGRlIGxvcyByZXN1bHRhZG9zIGRlIHRvZGFzIGxhcyBtdWVzdHJhcyBwcm9iYWJsZXMsIHNlIHRlbmRyw61hIHVuYSBjdXJ2YSBub3JtYWwgY29uIGNlbnRybyBlbiBlbCBwYXLDoW1ldHJvLgpTYWJyw61hbW9zIHF1ZSBzaSBkZXNkZSBlc2UgY2VudHJvIG5vcyBkZXNwbGF6YW1vcyAyIGRlc3ZpYWNpb25lcyBlc3TDoW5kYXIgZW4gYW1iYXMgZGlyZWNjaW9uZXMsIGVudHJlIGVzb3MgbMOtbWl0ZXMgZXN0YXLDrWFuIGVsIDk1JSBkZSB0b2RhcyBsYXMgbXVlc3RyYSBwcm9iYWJsZXMuCgpFcyBhbHRhbWVudGUgcHJvYmFibGUgKDk1JSBwcm9iYWJsZSkgcXVlIHNpIGVuIHVuYSBpbnZlc3RpZ2FjacOzbiBzZSBleHRyYWUgdW5hIHNvbGEgbXVlc3RyYSwgZXN0YSBzZWEgcGFydGUgZGVsIDk1JSBkZSBtdWVzdHJhcyBwb3NpYmxlcyBhICsvLSAyIGRlc3ZpYWNpb25lcyBlc3TDoW5kYXIgZGVsIHBhcsOhbWV0cm8uCkRlIGxhIG1pc21hIG1hbmVyYSwgZXMgcG9jbyBwcm9iYWJsZSAoNSUgcHJvYmFibGUpIHF1ZSB1bmEgc29sYSBtdWVzdHJhIG5vIGVzdMOpIGEgKy8tIDIgZGVzdmlhY2lvbmVzIGVzdMOhbmRhciBkZWwgcGFyw6FtZXRyby4KCiMgRXN0aW1hY2nDs24gZGUgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEKCkxhIGRpc3RyaWJ1Y2nDs24gZGUgbXVlc3RyZW8gZXMgdGXDs3JpY2EsIG11eSBkaWbDrWNpbG1lbnRlIHNlIHB1ZWRlIGNhbGN1bGFyIGVuIGxhIHJlYWxpZGFkLgpSZWd1bGFybWVudGUgdGFtcG9jbyBzYWJlbW9zIGxvcyBkYXRvcyBkZWwgdW5pdmVyc28uCkxvIHF1ZSB0ZW5lbW9zIGEgbWFubyBlcyAqKjEgbXVlc3RyYSBvYnNlcnZhZGEqKi4KRXMgZGVjaXIsIGVuIHVuIGVzdHVkaW8gZGUgbGFzIG11dXV1dWNoYXMgbXVlc3RyYXMgcHJvYmFibGVzLCBzZSBzZWxlY2Npb25hIDEgbXVlc3RyYS4KCkVuIGVsIGNhc28gZGUgbGEgZW5jdWVzdGEgRU5ETywgcG9yIGVqZW1wbG8sIGRlbCB1bml2ZXJzbyBkZSBwcm9mZXNvcmVzIHBlcnVhbm9zLCBzZSBzZWxlY2Npb27DsyAxIG11ZXN0cmEgZGUgMjgsMjE2IG9ic2VydmFjaW9uZXMsIGRlIGxhcyBtdXV1dWNoYXMgbXVlc3RyYXMgZGUgMjgsMjE2IGluZGl2aWR1b3MgZGUgbGEgcG9ibGFjacOzbiB0b3RhbC4KClNpIHRlw7NyaWNhbWVudGUgc2FiZW1vcyBxdWUgZW4gbGEgZGlzdHJpYnVjacOzbiBtdWVzdHJhbCwgZWwgOTUlIGRlIHRvZGFzIGxhcyBtdWVzdHJhcyBlc3TDoW4gYSArLy0gMiBkZXN2aWFjaW9uZXMgZXN0w6FuZGFyW14xXSBkZWwgY2VudHJvLCBxdWUgY29pbmNpZGUgY29uIGVsIHBhcsOhbWV0cm8gcG9ibGFjaW9uYWwsIGVzIG11eSBwcm9iYWJsZSBxdWUgbGEgw7puaWNhIG11ZXN0cmEgcXVlIHNlIGhhIG9ic2VydmFkbyBzZWEgcGFydGUgZGUgZXNlIGNvbmp1bnRvLgpEZSBoZWNobywgc2UgcHVlZGUgZGVjaXIgcXVlIHNlIHRpZW5lIDk1JSBkZSBwcm9iYWJpbGlkYWRlcyBkZSBxdWUgc2VhIHBhcnRlIGRlIGVzZSBncnVwby4KClteMV06IEVuIHJlYWxpZGFkIGVzIGEgKy8tIDIgZXJyb3JlcyBlc3TDoW5kYXIgZGVsIGNlbnRyby4KICAgIEVsIGVycm9yIGVzdMOhbmRhciBzZSBlbnRpZW5kZSBjb21vIGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBkZSBsYSBkaXN0cmlidWNpw7NuIGRlIG11ZXN0cmVvLgoKUG9yIGxvIHRhbnRvLCBzaSBhIHBhcnRpciBkZWwgZXN0YWTDrXN0aWNvIG11ZXN0cmFsLCBzZSBhcGxpY2EgZXN0YSBkaXN0YW5jaWEgZGUgKy8tIDIgZXJyb3JlcyBlc3TDoW5kYXIsIHNlIHRpZW5lIDk1JSBkZSBwcm9iYWJpbGlkYWRlcyBxdWUgZW50cmUgZXNvcyBsw61taXRlcyBzZSBpbmNsdXlhIGFsIHZhbG9yIGRlbCBwYXLDoW1ldHJvLgpQYXJhIHZlcmxvIGRlIG1hbmVyYSBtw6FzIHZpc3VhbCwgZW4gbGEgc2lndWllbnRlIGZpZ3VyYSBzZSB0aWVuZSBsYSBkaXN0cmlidWNpw7NuIGRlIG11ZXN0cmVvIHRlw7NyaWNhICh5IGRlc2Nvbm9jaWRhKSwgZG9uZGUgc2UgbWFyY2EgbGEgcmVnacOzbiBxdWUgYWN1bXVsYSBlbCA5NSUgZGUgdG9kYXMgbGFzIG11ZXN0cmFzIHByb2JhYmxlcy4KCk3DoXMgYWJham8gc2UgbWFyY2EgbG9zIHJlc3VsdGFkb3MgZGUgMiBtdWVzdHJhcyBvYnNlcnZhZGFzLgpMYSBwcmltZXJhIHByb3BvcmNpw7NuIG11ZXN0cmFsIHN1YmVzdGltYSBsYSBwcm9wb3JjacOzbiBwb2JsYWNpb25hbC4KTGEgc2VndW5kYSwgcG9yIGVsIGNvbnRyYXJpbywgc29icmVlc3RpbWEgbGEgcHJvcG9yY2nDs24gcG9ibGFjaW9uYWwuCkVuIGVsIHByaW1lciBjYXNvLCBzaSBhIHBhcnRpciBkZWwgZXN0YWTDrXN0aWNvIG11ZXN0cmFsIHNlIGFwbGljYSArLy0gMS45NiBlcnJvcmVzIGVzdMOhbmRhciAobMOtbmVhIGhvcml6b250YWwgZW4gbmVncml0YSksIHNlIG9ic2VydmEgcXVlIGVsIHBhcsOhbWV0cm8gcG9ibGFjaW9uYWwgZXN0w6EgaW5jbHVpZG8gZW4gZXNvcyBsw61taXRlcy4KCkVzIHByb2JhYmxlLCBjb21vIGVuIGVsIHNlZ3VuZG8gY2FzbywgcXVlIG90cmEgbXVlc3RyYSBwcm9iYWJsZSwgY3VhbmRvIHNlIGxlIGFwbGlxdWUgZWwgaW50ZXJ2YWxvIGRlICsvLSAxLjk2IGVycm9yZXMgZXN0w6FuZGFyLCBubyBpbmNsdXlhIGFsIHBhcsOhbWV0cm8uClNlIG9ic2VydmEgcXVlIGxhIGzDrW5lYSBlbiBuZWdyaXRhIG5vIGluY2x1eWUgbGEgbGluZWEgdmVydGljYWwgZW50cmVjb3J0YWRhIHF1ZSBtYXJjYSBlbCB2YWxvciBkZWwgcGFyw6FtZXRybyBwb2JsYWNpb25hbC4KCiFbXShjMy40LnBuZyl7d2lkdGg9IjU4MSJ9CgpTaW4gZW1iYXJnbywgc2FiZW1vcyBxdWUgZXMgbXVjaG8gbcOhcyBwcm9iYWJsZSAoOTUlIGRlIHByb2JhYmlsaWRhZGVzKSBxdWUgc2kgdW5hIG11ZXN0cmEgb2JzZXJ2YWRhIGVzIHBhcnRlIGRlbCA5NSUgZGUgbXVlc3RyYXMgYWxyZWRlZG9yIGRlbCBwYXLDoW1ldHJvLCBlc3RlIGludGVydmFsbyBpbmNsdXlhIGFsIHBhcsOhbWV0cm8gcG9ibGFjaW9uYWwuCkEgZXN0b3MgbMOtbWl0ZXMgbGUgbGxhbWFtb3MgImludGVydmFsb3MgZGUgY29uZmlhbnphIi4KCkVuIGN1YWxxdWllciBpbnZlc3RpZ2FjacOzbiBzb2xvIHNlIGN1ZW50YSBjb24gdW5hIG11ZXN0cmEgb2JzZXJ2YWRhLCBjdXlvIGVzdGFkw61zdGljbyBtdWVzdHJhbCwgc2VhIHVuYSBtZWRpYSBvIHVuIHByb3BvcmNpw7NuLCBlcyB1bmEgYXByb3hpbWFjacOzbiBkZWwgcGFyw6FtZXRybyBwb2JsYWNpb25hbC4KClBhcmEgcG9kZXIgZXh0cmFwb2xhciBkZXNkZSBsYSBtdWVzdHJhIGhhc3RhIGxhIHBvYmxhY2nDs24sIHNlIHRpZW5lIHF1ZSBjb25zdHJ1aXIgdW4gaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBhbHJlZGVkb3IgZGVsIGVzdGFkw61zdGljbyBtdWVzdHJhbC4KRXN0ZSBpbnRlcnZhbG8gc2UgY29uc3RydXllIGFwbGljYW5kbyBsYSAiZGlzdGFuY2lhIiBkZSArLy0gMS45NiBlcnJvcmVzIGVzdMOhbmRhciwgcGFyYSB0ZW5lciB1bmEgY29uZmlhbnphIGRlIDk1JSBkZSBpbmNsdWlyIGFsIHBhcsOhbWV0cm8gcG9ibGFjaW9uYWwuCgpTaSBzZSBlc3TDoSBleHRyYXBvbGFuZG8gcGFyYSB1bmEgdmFyaWFibGUgbnVtw6lyaWNhLCBtZWRpYW50ZSBsYSBtZWRpYSwgZWwgZXJyb3IgZXN0w6FuZGFyIChvIHNlKSBlczoKCiQkCnNlID0gMS45NiAqIFxmcmFje3N9IHtcc3FydHtufX0KJCQKClNpIHNlIGVzdMOhIGV4dHJhcG9sYW5kbyBwYXJhIHVuYSB2YXJpYWJsZSBjYXRlZ8OzcmljYSwgbWVkaWFudGUgdW5hIHByb3BvcmNpw7NuLCBlbCBlcnJvciBlc3TDoW5kYXIgKG8gc2UpIGVzOgoKJCQKc2UgPSAxLjk2ICogXHNxcnR7XGZyYWN7KHAgKiAoMS1wKSl9IHtufX0KJCQKCkEgbWFuZXJhIGRlIHJlc3VtZW4sIGxhIHNpZ3VpZW50ZSB0YWJsYSBub3MgbXVlc3RyYSBlbCBwYXLDoW1ldHJvLCBlbCBlc3RhZMOtc3RpY28gcHVudHVhbCB5IGVsIGVycm9yIGVzdMOhbmRhciBwYXJhIGNhZGEgdGlwbyBkZSB2YXJpYWJsZSB5IGPDs21vIHNlIGZvcm1hIGVsIGludGVydmFsbyBkZSBjb25maWFuemEuCgohW10oYzMuNS5wbmcpCgpFbiBlc3RhcyBmw7NybXVsYXMsIHNlIHVzYSBlbCBzw61tYm9sbyAidCIgeSAieiIgcGFyYSByZWZlcmlyIGEgbGFzIGRpc3RyaWJ1Y2lvbmVzIHRlw7NyaWNhcyBxdWUgc2UgdXNhbi4KUGFyYSBmaW5lcyBwcsOhY3RpY29zLCBjdWFuZG8gbGEgbXVlc3RyYSBlcyBncmFuZGUsIGFtYmFzIGRpc3RyaWJ1Y2lvbmVzIHNvbiBpZ3VhbGVzLgpFbCB2YWxvciBkZSAidCIgbyAieiIgZGVwZW5kZSBkZWwgbml2ZWwgZGUgY29uZmlhbnphIHF1ZSBxdWVyZW1vcy4KRXMgZGVjaXIsIGRlIGxhIHByb2JhYmlsaWRhZCBxdWUgcXVlcmVtb3MgZGUgcXVlIGVsIGludGVydmFsbyBpbmNsdXlhIGFsIHBhcsOhbWV0cm8uCkRlIGVzdGEgbWFuZXJhOgoKLSAgIFogYWwgOTAlID0gMS42NDUKCi0gICBaIGFsIDk1JSA9IDEuOTYKCi0gICBaIGFsIDk4JSA9IDIuMzI2CgotICAgWiBhbCA5OSUgPSAyLjU3NgoKwr9RdcOpIHBhc2EgY29uIGVsIElDIGN1YW5kbyBzZSBxdWllcmUgbWF5b3IgY29uZmlhbnphPwrCv1NlIHZ1ZWx2ZSBtw6FzIG8gbWVub3MgcHJlY2lzbz8KCkVuIGVsIGVqZW1wbG8gZGVsIGPDoWxjdWxvIGRlbCBwcm9tZWRpbyBkZSBhbHVtbm9zIHF1ZSBhdGllbmRlIGxvcyBwcm9mZXNvcmVzLCBzZSBwdWVkZSBhw7FhZGlyIGVsIGPDoWxjdWxvIGRlIGxvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YSBlbiBhbWJvcyBjYXNvcywgcGFyYSBob21icmVzIHkgbXVqZXJlcy4KRWwgY29tYW5kbyBwYXJhIGhhY2VyIGVzdG8gZXMgYGNpTWVhbmAgcXVlIGVzIHBhcnRlIGRlIGxhIGxpYnJlcsOtYSBgbHNyYC4KCmBgYHtyfQpsaWJyYXJ5KGxzcikKY2lNZWFuKGVuZG8yMDIwJFAxXzYsIG5hLnJtID0gVCkKYGBgCgpTaSBzZSBjYWxjdWxhbiBsb3MgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgcG9yIGdydXBvcywgZXN0b3Mgc2UgcHVlZGVuIGNvbXBhcmFyLgoKYGBge3IgSUMgZG9jZW50ZXN9CmxpYnJhcnkobHNyKQpjaV9hbHVteHNleG8gPSBlbmRvMjAyMCB8PgogIGdyb3VwX2J5KHNleG8pIHw+CiAgc3VtbWFyaXNlKE1lZGlhID0gbWVhbihQMV82LCBuYS5ybT1UKSwKICAgICAgICAgICAgbWluID0gY2lNZWFuKFAxXzYsIG5hLnJtPVQpWzFdLAogICAgICAgICAgICBtYXggPSBjaU1lYW4oUDFfNiwgbmEucm09VClbMl0KICAgICAgICAgICAgKQpjaV9hbHVteHNleG8KYGBgCgpTZSBlbmN1ZW50cmEgcXVlIGxhIG1lZGlhIGRlIGFsdW1ub3MgcXVlIGF0aWVuZGUgdW4gZG9jZW50ZSBob21icmUgZXN0YSBlbnRyZSA1MC43IHkgNTMuOCBhbHVtbm9zLCBtaWVudHJhcyBxdWUgZW4gZWwgY2FzbyBkZSBsYXMgZG9jZW50ZXMgbXVqZXJlcyBlc3TDoSBlbnRyZSAzMy4zIHkgMzQuOCBhbHVtbm9zIGVuIGF1bGEuCgrCv1F1w6kgbcOhcyBzZSBwdWVkZSBkZWNpciBkZSBlc3RhIGNvbXBhcmFjacOzbiBlbnRyZSBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YT8Kwr9Dw7NtbyBncmFmaWNhciBlc3RvcyBpbnRlcnZhbG9zIGRlIGNvbmZpYW56YT8KCiMgQmlibGlvZ3JhZsOtYQo=</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("clase3.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
