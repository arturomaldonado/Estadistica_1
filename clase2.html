<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Arturo Maldonado" />


<title>Clase 2: descripción y visualización</title>

<script src="site_libs/header-attrs-2.21/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.0/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.0/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Estadística_1</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="intro.html">Introducción</a>
</li>
<li>
  <a href="basico.html">Procedimientos básicos</a>
</li>
<li>
  <a href="clase1.html">Clase 1</a>
</li>
<li>
  <a href="clase2.html">Clase 2</a>
</li>
<li>
  <a href="clase3.html">Clase 3 y 4</a>
</li>
<li>
  <a href="clase4.html">Clase 5</a>
</li>
<li>
  <a href="clase5.html">Clase 6</a>
</li>
<li>
  <a href="clase6.html">Clase 7</a>
</li>
<li>
  <a href="repaso.html">Repaso</a>
</li>
<li>
  <a href="clase7.html">Clase 10</a>
</li>
<li>
  <a href="clase9.html">Clase 11</a>
</li>
<li>
  <a href="clase12.html">Clase 12</a>
</li>
<li>
  <a href="clase13.html">Clase 13</a>
</li>
<li>
  <a href="clase14.html">Clase 14</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="https://github.com/arturomaldonado/Estadistica_1.0">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Clase 2: descripción y visualización</h1>
<h4 class="author">Arturo Maldonado</h4>
<h4 class="date">26/03/2024</h4>

</div>


<hr />
<div id="caso-1-apoyo-a-la-democracia-en-américa-latina"
class="section level1">
<h1>Caso 1: Apoyo a la democracia en América Latina</h1>
<p><em>Pregunta: ¿existe una erosión del apoyo a la democracia entre los
ciudadanos en América Latina?</em></p>
<div id="leer-una-base-de-datos" class="section level2">
<h2>Leer una base de datos</h2>
<p>Usamos la librería <code>rio</code>. Activamos la librería con el
comando <code>library</code> y usamos el comando <code>import</code>
para leer la base de datos (un archivo Excel). Ojo: el nombre del
archivo tiene que estar entre comillas. En este caso, el archivo está
dentro de mi directorio de trabajo, por lo que se le llama con el
nombre. Si no estuviera en el directorio de trabajo se tendría que
especificar la ruta del archivo.</p>
<p>Guardamos esta base de datos en un nuevo objeto (dataframe) llamado
apoyoAL. Se sugiere siempre trabajar con nombres cortos de bases de
datos y de variables.</p>
<pre class="r"><code>library(rio)
apoyoAL = import(&quot;apoyoAL.xlsx&quot;)</code></pre>
</div>
<div id="descripción-para-variables-numéricas" class="section level2">
<h2>Descripción para variables numéricas</h2>
<p>Usamos las medidas de tendencia central para describir una variable
numérica. Podemos usar el comando <code>mean</code> para calcular el
promedio de apoyo a la democracia en 2023. Este comando asume que se
tienen datos completos. Como existe un dato perdido, el comando no
corre, y se tiene que añadir la especificación
<code>, na.rm = T</code>.</p>
<pre class="r"><code>library(tidyverse)
apoyoAL |&gt;
  summarise(Apoyo2023=mean(apoyo2023, na.rm=T))</code></pre>
<pre><code>##   Apoyo2023
## 1  58.56522</code></pre>
<p>También se puede calcular la mediana, con el comando
<code>median</code> y presentar ambas medidas juntas.</p>
<pre class="r"><code>apoyoAL |&gt;
  summarise(Promedio_Apoyo2023=mean(apoyo2023, na.rm=T), 
            Mediana_Apoyo2023=median(apoyo2023, na.rm=T))</code></pre>
<pre><code>##   Promedio_Apoyo2023 Mediana_Apoyo2023
## 1           58.56522                57</code></pre>
<p>Ahora lo que queremos averiguar es si el apoyo a la democracia ha
disminuido, aumentado o permanecido igual entre 2021 y 2023. Para esto,
podemos comparar la media del apoyo a la democracia en 2021 con la media
en 2023.</p>
<pre class="r"><code>apoyoAL |&gt;
  summarise(Promedio_Apoyo2021=mean(apoyo2021, na.rm=T), 
            Promedio_Apoyo2023=mean(apoyo2023, na.rm=T))</code></pre>
<pre><code>##   Promedio_Apoyo2021 Promedio_Apoyo2023
## 1               61.2           58.56522</code></pre>
<p>Según estos resultados, el apoyo a la democracia ha disminuido de
61.2% a 58.6%; es decir, una disminución de 2.6 puntos porcentuales.</p>
<p>Los datos de 2023 incluyen países caribeños (Bahamas, Granada, TyT y
Surinám) que no estaban en el gráfico de 2021. Es posible que el menor
promedio de apoyo a la democracia en 2023 sea por la incorporación de
estos países. Se podría argumentar que si se tuviera los datos de estos
países para 2021, quizá no existiría una erosión del apoyo a la
democracia.</p>
<p>Una forma de lidiar con esta observación es comparar los resultados
2023 y 2021 solo de los países que tienen datos en ambos años.</p>
</div>
<div id="dataframes" class="section level2">
<h2>Dataframes</h2>
<p>Antes de ver cómo eliminar los países, una nota sobre la estructura
de una base de datos. El dataframe apoyoAL tiene 24 observaciones (24
filas, en cada una, un país) y 4 variables (4 columnas, en cada una, una
variable). Por lo tanto, este dataframe tiene una dimensión [24, 4]. En
general, un dataframe tiene dimensión [#filas, #columnas].</p>
<p>Por lo tanto, se puede llamar a los elementos de un dataframe
indicando la fila y la columna. Por ejemplo, para llamar al elemento de
la primera fila y segunda columna.</p>
<pre class="r"><code>apoyoAL[4,2]</code></pre>
<pre><code>## [1] &quot;Argentina&quot;</code></pre>
<p>También se puede llamar toda una fila. En este caso, la primera
fila.</p>
<pre class="r"><code>apoyoAL[1,]</code></pre>
<pre><code>##   pais country apoyo2021 apoyo2023
## 1   UY Uruguay        80        75</code></pre>
<p>O la segunda columna</p>
<pre class="r"><code>apoyoAL[,2]</code></pre>
<pre><code>##  [1] &quot;Uruguay&quot;              &quot;El Salvador&quot;          &quot;Costa Rica&quot;          
##  [4] &quot;Argentina&quot;            &quot;Chile&quot;                &quot;Brasil&quot;              
##  [7] &quot;Guyana&quot;               &quot;México&quot;               &quot;Ecuador&quot;             
## [10] &quot;Nicaragua&quot;            &quot;República Dominicana&quot; &quot;Panamá&quot;              
## [13] &quot;Bolivia&quot;              &quot;Jamaica&quot;              &quot;Colombia&quot;            
## [16] &quot;Guatemala&quot;            &quot;Paraguay&quot;             &quot;Perú&quot;                
## [19] &quot;Honduras&quot;             &quot;Haití&quot;                &quot;Bahamas&quot;             
## [22] &quot;Granada&quot;              &quot;Trinidad y Tobago&quot;    &quot;Surinám&quot;</code></pre>
<p>Esto nos permite seleccionar filas (países) o columnas (variables)
bajo ciertas condiciones. En general, nos interesa más seleccionar
filas.</p>
<p>Por ejemplo, si queremos seleccionar los países por encima de la
media de apoyo 2023, podemos decir</p>
<pre class="r"><code>apoyoAL[apoyoAL$apoyo2023&gt;mean(apoyoAL$apoyo2023, na.rm = T), c(1,4)]</code></pre>
<pre><code>##    pais apoyo2023
## 1    UY        75
## 2    SV        67
## 3    CR        72
## 4    AR        68
## 5    CL        70
## 6    BR        64
## NA &lt;NA&gt;        NA
## 8    MX        62
## 11   DO        64
## 12   PN        62
## 21   BS        65
## 22   GD        59</code></pre>
<p>En R existe un comando para seleccionar observaciones. Se puede usar
<code>subset</code> para hacer este filtro. Este filtro se puede
almacenar en otro dataframe.</p>
<pre class="r"><code>apoyo_mayor_media = subset(apoyoAL, apoyo2023 &gt; mean(apoyo2023, na.rm=T))</code></pre>
</div>
<div id="lidiando-con-valores-perdidos" class="section level2">
<h2>Lidiando con valores perdidos</h2>
<p>Volviendo al ejemplo y a la respuesta a la observación de comparar
países con mediciones en ambos años. Si se abre la base de datos
“apoyoAL”, se observa que apoyo2021 tiene 4 NAs y apoyo2023 tiene 1
NA.</p>
<p>Se puede eliminar los países que tienen NAs en la variable
“apoyo2021”.</p>
<pre class="r"><code>apoyoSinNA2021 = apoyoAL[!(is.na(apoyoAL$apoyo2021)),]</code></pre>
<p>Se puede eliminar los países que tienen NAs en la variable
“apoyo2023”.</p>
<pre class="r"><code>apoyoSinNA2023 = apoyoAL[!(is.na(apoyoAL$apoyo2023)),]</code></pre>
<p>Pero, queremos eliminar ambos; es decir, tanto los países con NAs en
2023 Y los países con NAs en 2021. Para esto usamos el operador lógico
“&amp;”.</p>
<p>En R tenemos los siguientes operadores lógicos:</p>
<table>
<thead>
<tr class="header">
<th align="center">Operador</th>
<th align="center">Descripción</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="center">==</td>
<td align="center">es igual a</td>
</tr>
<tr class="even">
<td align="center">!=</td>
<td align="center">es diferente de</td>
</tr>
<tr class="odd">
<td align="center">&gt;</td>
<td align="center">es mayor de</td>
</tr>
<tr class="even">
<td align="center">&lt;</td>
<td align="center">es menor de</td>
</tr>
<tr class="odd">
<td align="center">&gt;=</td>
<td align="center">es mayor o igual a</td>
</tr>
<tr class="even">
<td align="center">&lt;=</td>
<td align="center">es menor o igual a</td>
</tr>
<tr class="odd">
<td align="center">&amp;</td>
<td align="center">intersección (Y)</td>
</tr>
<tr class="even">
<td align="center">|</td>
<td align="center">unión (O)</td>
</tr>
</tbody>
</table>
<pre class="r"><code>apoyoSinNA = apoyoAL[!(is.na(apoyoAL$apoyo2021)) &amp; !(is.na(apoyoAL$apoyo2023)),]</code></pre>
<p>Esto mismo se puede lograr con el comando <code>subset</code>.</p>
<pre class="r"><code>apoyoSinNA2 = subset(apoyoAL, 
                     !(is.na(apoyoAL$apoyo2021)) &amp; !(is.na(apoyoAL$apoyo2023)))</code></pre>
<p>Y también se puede hacer, usando el tidyverse. En este curso tenemos
una preferencia por este estilo de código. Pero, como pueden ver se
puede lograr los mismos resultados de muchas maneras en R.</p>
<pre class="r"><code>apoyoSinNa3 = apoyoAL |&gt; 
  filter(!(is.na(apoyoAL$apoyo2021)) &amp; !(is.na(apoyoAL$apoyo2023))) </code></pre>
<p>Con este nuevo dataframe, que contiene solo los países que tienen el
dato de apoyo a la democracia tanto en 2021 como en 2023, se puede
responder a la observación. Podemos comparar la media de ambos añós
usando este nuevo dataframe.</p>
<pre class="r"><code>apoyoSinNa3 |&gt;
  summarise(PromedioApoyo2021=mean(apoyo2021, na.rm=T), 
            PromedioApoyo2023=mean(apoyo2023, na.rm=T))</code></pre>
<pre><code>##   PromedioApoyo2021 PromedioApoyo2023
## 1          60.94737          58.84211</code></pre>
<p>Los resultados indican que hay una disminución de 2.1 puntos
porcentuales, resultados un poco menor que el anterior (2.6 pp), pero
que va en la misma dirección de decir que hay una erosión del apoyo
ciudadanos a la democracia.</p>
</div>
</div>
<div id="caso-2-resultados-electorales-2016" class="section level1">
<h1>Caso 2: Resultados electorales 2016</h1>
<p><em>Pregunta: Algunos politólogos consideran que un partido más
institucionalizado es el que es capaz de tener un mayor enraizamiento
territorial y, por lo tanto, tener un apoyo electoral relativamente
constante a lo largo del territorio. Por el contrario, un partido menos
institucionalizado, solo lograría apoyos electorales diferenciados,
mayores en algunos territorios y menores en otros.</em></p>
<p><em>Siguiendo esta idea, ¿cuál fue el partido mas o menos
institucionalizado de acuerdo a los resultados electorales de
2016?</em></p>
<div id="leer-una-base-de-datos-1" class="section level2">
<h2>Leer una base de datos</h2>
<pre class="r"><code>library(rio)
res2016 = import(&quot;resultados2016.xlsx&quot;)</code></pre>
<p>Si se hace doble click en el objeto, se abre la base de datos como
una pestaña en la zona de scripts / RMarkdowns. Este objeto dataframe
tiene vectores de datos de tipo “caracter” y otros vectores de datos de
tipo “numérico”.</p>
</div>
<div id="descripción-de-la-heterogeneidad" class="section level2">
<h2>Descripción de la heterogeneidad</h2>
<p>Usamos las medidas de dispersión para describir una variable
numérica. Podemos usar el comando <code>sd</code> para calcular la
desviación estándar del voto provincial a Fuerza Popular, a Peruanos por
el Kambio y al Frente Amplio en 2016. Este comando asume que se tienen
datos completos. Si existiera un dato perdido, el comando no correría, y
se tendría que añadir la especificación <code>, na.rm = T</code>.</p>
<pre class="r"><code>library(dplyr)
library(tidyverse)
res2016 |&gt;
  summarise(sd(fp), sd(ppk), sd(fa))</code></pre>
<pre><code>##     sd(fp)  sd(ppk)   sd(fa)
## 1 15.71665 28.89695 17.34935</code></pre>
<p>También se puede calcular la media para grupos de observaciones, es
decir para filas específicas de una base de datos. Una opción sería
agregar un nuevo dataframe con el filtrado de las observaciones. Si no
queremos llenarnos de bases de datos parciales, tenemos otras
opciones.</p>
<p>Por ejemplo, si quisiéramos saber si la heterogeneidad del voto fue
mayor o menor que aquella del voto provincial general de Fuerza Popular,
podríamos calcular la desviación estándar del voto provincial solo en
las provincias de Lima.</p>
<p>Esto se puede hacer de múltiples maneras. En este curso comenzaremos
a usar las funciones del mundo del Tidyverse.</p>
<p>En cualquier caso, se tiene que seleccionar algunas filas de un
dataframe usando operadores lógicos. En nuestro caso vamos a seleccionar
las observaciones, con el comando <code>filter</code> y con la condición
que en el vector o variable “dpto” sean igual a “LIMA”. Ojo, en
mayúsculas, dado que así está en la base de datos y entre comillas
porque es una cadena de caracteres.</p>
<pre class="r"><code>res2016 |&gt; 
  filter(dpto ==&quot;LIMA&quot;) |&gt;
  summarise(sd(fp), sd(ppk), sd(fa))</code></pre>
<pre><code>##     sd(fp)  sd(ppk)   sd(fa)
## 1 6.853293 6.539157 4.175478</code></pre>
<p>Encontramos que en Lima la desviación estándar del voto provincial a
Fuerza Popular es mayor que la de otros partidos. También se puede
calcular los mismo para el caso de Cusco.</p>
<pre class="r"><code>res2016 |&gt; 
  filter(dpto ==&quot;CUSCO&quot;) |&gt;
  summarize(sd(fp), sd(ppk), sd(fa))</code></pre>
<pre><code>##     sd(fp)  sd(ppk)   sd(fa)
## 1 7.083839 3.913559 11.03639</code></pre>
<pre class="r"><code>#Cómo calcularían esta media usando la variable &quot;id&quot;?</code></pre>
</div>
<div id="tarea" class="section level2">
<h2>Tarea</h2>
<p>La base de datos también incluye el voto provincial a Fuerza Popular
en la elección de 2021.</p>
<p>¿Calcule si el voto promedio de Fuerza Popular ha aumentado o
disminuido entre 2011 y 2016?</p>
<p>¿Calcule lo mismo para el departamento de Tumbes?</p>
<p>¿Calcule si Fuerza Popular ha aumento o disminuido su nivel de
institucionalización?</p>
</div>
</div>
<div id="visualización" class="section level1">
<h1>Visualización</h1>
<p>Una de las tareas más comunes en el manejo de datos es la
visualización de los resultados. En R hay dos maneras de proceder. La
primera es usar los comandos de base de R. La otra es usar una librería
<code>ggplot2</code> que permite una mayor flexibilidad en la producción
y estética de los gráficos.</p>
<p>Para esto se carga la librería <code>ggplot2</code>. Esta tiene un
comando <code>ggplot</code> en el que se define los aspectos del
gráfico. Por ejemplo, para graficar una variable numérica, como el
porcentaje de voto a FP por provincia, se puede producir un
histograma.</p>
<p>Dentro de este comando se define la base de datos y la variable que
se va a graficar. Luego se van agregando capas. La primera define el
tipo de gráfico. Usamos <code>geom_histogram</code> para producir el
histograma y se especifica el ancho de columna. Luego se define las
etiquetas de ejes y el tema del gráfico.</p>
<p>Se observa que el gráfico de porcentaje de votos a Fuerza Popular es
aproximadamente simétrico, tal como indicaban la similitud entre media y
mediana.</p>
<pre class="r"><code>library(ggplot2)
ggplot(res2016, aes(x=fp))+
  geom_histogram(binwidth = 5)+
  xlab(&quot;% Voto PPK 2016&quot;) +
  ylab(&quot;Frecuencia&quot;)+
  theme_minimal()</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>Habíamos encontrado que la media y la mediana del porcentaje de voto
al Frente Amplio diferían. Esto lo comprobamos produciendo el histograma
de esta variable.</p>
<pre class="r"><code>ggplot(res2016, aes(x=fa))+
  geom_histogram(binwidth = 5)+
  geom_vline(xintercept = 29.3, color = &quot;red&quot;)+
  geom_vline(xintercept = 24.5, color = &quot;green&quot;)+
  xlab(&quot;% Voto FA 2011&quot;)+
  ylab(&quot;Frecuencia&quot;)+
  theme_classic()</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Otro gráfico útil en la visualización es el llamado “boxplot” o
“gráfico de cajas”. Este tipo de gráficos sirve bastante para comparar
entre grupos de otra variable.</p>
<p>Para producir un gráfico de cajas usamos la especificación
<code>geom_bloxplot()</code> y podemos definir los límites y saltos del
eje Y. Este gráfico nos muestra que el distrito con el menor porcentaje
de voto a FP tuvo un poco más de 5% y que el máximo fue de casi 80%.
También muestra que la votación mediana fue de 40%. Los límites de la
caja son el cuartil 25 y el cuartil 75.</p>
<pre class="r"><code>ggplot(res2016, aes(y=fp))+
  geom_boxplot()+
  ylab(&quot;% Voto FP 2011&quot;)</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<p>El aspecto más útil de los gráficos de cajas es la comparación. Por
ejemplo, si se quisiera comparar el voto a Fuerza Popular entre
departamentos del país. Para hacer esto se debe definir que la variable
en el eje Y sea el porcentaje de votos a Fuerza Popular “fp” y en el eje
X la variable que define los departamentos “dpto”. Incluimos la
especificación <code>coord_flip()</code> para voltear los ejes y que las
etiquetas de los departamentos se lean más claramente.</p>
<p>En el gráfico se pueden hacer varias comparaciones. Lo más importante
es comparar medianas y anchos de cajas entre departamentos. Los puntos
aislados son “outliers” o valores extremos, que se calculan
automáticamente y se grafican.</p>
<p>Este gráfico, sin embargo, es muy desagragado.</p>
<pre class="r"><code>ggplot(res2016, aes(y=fp, x=dpto))+
  geom_boxplot()+
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 10))+
  ylab(&quot;% Voto FP 2011&quot;)+
  xlab(&quot;Departamento&quot;)+
  theme_minimal()+
  coord_flip()</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
<p>Si se quisiera comparar entre regiones (costa, sierre y selva), se
tendría que crear esta variable, a partir de la variable “dpto”.</p>
<div id="recodificando-variables" class="section level2">
<h2>Recodificando variables</h2>
<pre class="r"><code>res2016 = res2016 |&gt;
  mutate(region = case_when(
    dpto==&quot;AMAZONAS&quot;~&quot;Selva&quot;,
    dpto==&quot;ANCASH&quot;~&quot;Sierra&quot;,
    dpto==&quot;APURIMAC&quot;~&quot;Sierra&quot;,
    dpto==&quot;AREQUIPA&quot;~&quot;Sierra&quot;,
    dpto==&quot;AYACUCHO&quot;~&quot;Sierra&quot;,
    dpto==&quot;CAJAMARCA&quot;~&quot;Sierra&quot;,
    dpto==&quot;CUSCO&quot;~&quot;Sierra&quot;,
    dpto==&quot;CALLAO&quot;~&quot;Costa&quot;,
    dpto==&quot;HUANCAVELICA&quot;~&quot;Sierra&quot;,
    dpto==&quot;HUANUCO&quot;~&quot;Selva&quot;,
    dpto==&quot;ICA&quot;~&quot;Costa&quot;,
    dpto==&quot;JUNIN&quot;~&quot;Sierra&quot;,
    dpto==&quot;LA LIBERTAD&quot;~&quot;Costa&quot;,
    dpto==&quot;LAMBAYEQUE&quot;~&quot;Costa&quot;,
    dpto==&quot;LIMA&quot;~&quot;Costa&quot;,
    dpto==&quot;LORETO&quot;~&quot;Selva&quot;,
    dpto==&quot;MADRE DE DIOS&quot;~&quot;Selva&quot;,
    dpto==&quot;MOQUEGUA&quot;~&quot;Costa&quot;,
    dpto==&quot;PASCO&quot;~&quot;Sierra&quot;,
    dpto==&quot;PIURA&quot;~&quot;Costa&quot;,
    dpto==&quot;PUNO&quot;~&quot;Sierra&quot;,
    dpto==&quot;SAN MARTIN&quot;~&quot;Selva&quot;,
    dpto==&quot;TACNA&quot;~&quot;Costa&quot;,
    dpto==&quot;TUMBES&quot;~&quot;Costa&quot;,
    dpto==&quot;UCAYALI&quot;~&quot;Selva&quot;
  )) </code></pre>
<pre class="r"><code>res2016 |&gt;
  count(Region = region, name=&quot;Frecuencia&quot;)</code></pre>
<pre><code>##   Region Frecuencia
## 1  Costa         49
## 2  Selva         43
## 3 Sierra        104</code></pre>
<p>La variable creada es una variable de tipo “caracter”. En R existe
otro tipo de variable llamado “factor”. Podemos convertir cualquier
variable a una de factor y etiquetar cada valor.</p>
<pre class="r"><code>library(forcats)
res2016 = res2016 |&gt;
  mutate(region2 = factor(region))</code></pre>
<p>Ahora, procedemos a producir el gráfico de cajas de porcentaje de
voto a Fuerza Popular por región.</p>
<pre class="r"><code>ggplot(res2016, aes(y=fp, x=region))+
  geom_boxplot()+
  scale_y_continuous(limits = c(0, 100), breaks = seq(0, 100, 20))+
  ylab(&quot;% Voto FP 2016&quot;)+
  xlab(&quot;Región&quot;)+
  theme_get()</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
<p>Se observa en este gráfico que el voto mediano a Fuerza Popular fue
mayor entre provincias de la costa, seguido por la selva y luego la
sierra. Este mismo patrón se observa si calculáramos la media del
porcentaje de voto provincial a Fuerza Popular por región.</p>
<pre class="r"><code>res2016 |&gt; 
  group_by(region2) |&gt;
  summarise(mean(fp), sd(fp))</code></pre>
<pre><code>## # A tibble: 3 × 3
##   region2 `mean(fp)` `sd(fp)`
##   &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;
## 1 Costa         49.6     13.6
## 2 Selva         45.0     13.6
## 3 Sierra        32.5     14.0</code></pre>
</div>
<div id="descripción-de-variables-de-factor" class="section level2">
<h2>Descripción de variables de factor</h2>
<p>Para describir variables que no son numéricas, podemos producir
tablas de distribución de frecuencias. Por ejemplo, la base de datos
incluye una variable de qué partido ganó la mayoría de votos en una
provincia. La variable “gana” de la base de datos recoge este dato.
Podemos usar el comando <code>count</code> para calcular la tabla de
distribución de frecuencias de esta variable. Se guarda esta tabla en un
objeto “tabla”.</p>
<p>Se encuentra que del total de provincias, Fuerza Popular ganó en la
mayoría de ellas.</p>
<pre class="r"><code>tabla = res2016 |&gt;
  count(Ganador = gana, name=&quot;Frecuencia&quot;)
tabla</code></pre>
<pre><code>##              Ganador Frecuencia
## 1 DEMOCRACIA DIRECTA         10
## 2      FRENTE AMPLIO         69
## 3     FUERZA POPULAR        112
## 4       PERÚ POSIBLE          2
## 5                PPK          3</code></pre>
<p>Para calcular los porcentajes, se puede agregar a la tabla una
columna “Porcentaje” con el cálculo de la “Frecuencia” (columna
existente) ente la suma total de las frecuencias. Se encuentra que
Fuerza Popular ganó en el 57% de provincias del Perú.</p>
<pre class="r"><code>tabla = tabla |&gt;
  mutate(Porcentaje = (Frecuencia / sum(Frecuencia)*100 ))
tabla</code></pre>
<pre><code>##              Ganador Frecuencia Porcentaje
## 1 DEMOCRACIA DIRECTA         10   5.102041
## 2      FRENTE AMPLIO         69  35.204082
## 3     FUERZA POPULAR        112  57.142857
## 4       PERÚ POSIBLE          2   1.020408
## 5                PPK          3   1.530612</code></pre>
<p>Para graficar una variable de tipo cualitativa (o de factor en el
lenguaje de R), se debe usar, por ejemplo, un gráfico de barras. Podemos
graficar el porcentaje de provincias que cada partido ganó en 2021.</p>
<p>Para esto seguimos usando la librería <code>ggplot</code>, pero ahora
no realizaremos un histograma (no usaremos <code>geom_histogram</code>),
sino barras, con <code>geom_bar</code>. Dentro de este comando se añade
<code>stat="identity</code> para indicar que R no calcule nada y solo
use los datos de “tabla”.</p>
<pre class="r"><code>ggplot(tabla, aes(x=Porcentaje,y=Ganador))+
  geom_bar(stat=&quot;identity&quot;, width=0.5)</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
</div>
</div>
<div id="caso-3-comisarias-en-el-perú" class="section level1">
<h1>Caso 3: Comisarias en el Perú</h1>
<div id="medidas-de-tendencia-central" class="section level2">
<h2>Medidas de tendencia central</h2>
<ul>
<li><p>Resumen de un conjunto de datos.</p></li>
<li><p>Se resume mediante un valor “representativo”.</p></li>
<li><p>Cada observación se puede comparar con este valor de resumen. Se
puede estar por debajo o por encima de este valor.</p></li>
</ul>
<hr />
</div>
<div id="moda" class="section level2">
<h2>Moda</h2>
<ul>
<li><p>Valor mas frecuente de un conjunto de datos</p></li>
<li><p>Es apropiada para todo tipo de datos</p></li>
<li><p>Se puede observar directamente en una tabla de distribución de
frecuencias.</p></li>
</ul>
<p>Por ejemplo si se mide en cada comisaria del Perú, a cuánta población
atiende cada comisaria de acuerdo a la codificación.</p>
<p><img src="comi17_pob.png" width="734" /></p>
<p>La base de datos o “dataframe” se vería así</p>
<p><img src="comi17_pob2.png" /></p>
<hr />
<p>Para esta clase se usará la base de datos de comisarias del Perú, que
puede ser descargada de la sección microdatos de la web del INEI (ver <a
href="https://proyectos.inei.gob.pe/microdatos/">aquí</a>). Esta base
tiene información para 1495 comisarias y de 281 variables. Esta base se
puede cargar también desde el repositorio Github de este curso. La base
de datos puede ser guardada en el directorio de trabajo.</p>
<p>En primer lugar, se llama a la librería “rio” y se usa el comando
<code>import</code> que permite leer bases de datos en muchos
formatos.</p>
<pre class="r"><code>library(rio) 
comi17 = import(&quot;bases/comi2017.sav&quot;)</code></pre>
<pre class="r"><code>str(comi17$INF109)</code></pre>
<pre><code>##  num [1:1495] 5 2 4 2 2 1 4 3 3 6 ...
##  - attr(*, &quot;label&quot;)= chr &quot;¿A CUÁNTA POBLACIÓN ATIENDE LA COMISARÍA/UNIDAD ESPECIALIZADA DENTRO DE SU JURISDICCIÓN?&quot;
##  - attr(*, &quot;format.spss&quot;)= chr &quot;F11.0&quot;
##  - attr(*, &quot;display_width&quot;)= int 11
##  - attr(*, &quot;labels&quot;)= Named num [1:6] 1 2 3 4 5 6
##   ..- attr(*, &quot;names&quot;)= chr [1:6] &quot;Menos de 5000 Hab&quot; &quot;De 5000 - 10000 Hab&quot; &quot;De 10001 - 20000 Hab&quot; &quot;De 20001 - 40000 Hab&quot; ...</code></pre>
<pre class="r"><code>class(comi17$INF109)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>library(tidyverse)
library(dplyr)
comi17 = comi17 |&gt;
  mutate(tipo = factor(INF109, labels=c(&quot;Menos de 5000 Hab&quot;, 
                                        &quot;De 5000 - 10000 Hab&quot;, 
                                        &quot;De 10001 - 20000 Hab&quot;, 
                                        &quot;De 20001 - 40000 Hab&quot;,
                                        &quot;De 40001 a 80000&quot;, &quot;De 80001 a más&quot;)))</code></pre>
<p>Esta base de datos incluye a la variable “INF109” (ojo: R es “case
sensitive”, es decir, diferencia mayúsculas de minúsculas). La tabla de
distribución de frecuencias de esa variable se puede obtener con el
siguiente código:</p>
<pre class="r"><code>tabla1 = comi17 |&gt;
  count(Tipo = tipo, name=&quot;Frecuencia&quot;)
tabla1</code></pre>
<pre><code>##                   Tipo Frecuencia
## 1    Menos de 5000 Hab        288
## 2  De 5000 - 10000 Hab        329
## 3 De 10001 - 20000 Hab        290
## 4 De 20001 - 40000 Hab        248
## 5     De 40001 a 80000        196
## 6       De 80001 a más        144</code></pre>
<p>En este caso, la moda es el valor más frecuente, que sería el código
“2”, que significa “De 5,000 a 10,000 hab”.</p>
<pre class="r"><code>tabla1 = comi17 |&gt;
  count(Tipo = tipo, name=&quot;Frecuencia&quot;) |&gt;
  mutate(Porc = (Frecuencia / sum(Frecuencia)*100 ))
tabla1</code></pre>
<pre><code>##                   Tipo Frecuencia      Porc
## 1    Menos de 5000 Hab        288 19.264214
## 2  De 5000 - 10000 Hab        329 22.006689
## 3 De 10001 - 20000 Hab        290 19.397993
## 4 De 20001 - 40000 Hab        248 16.588629
## 5     De 40001 a 80000        196 13.110368
## 6       De 80001 a más        144  9.632107</code></pre>
<pre class="r"><code>library(ggplot2)
ggplot(tabla1, aes(x=Tipo, y=Porc)) + 
  geom_bar(stat = &quot;identity&quot;) +
  xlab(&quot;Población a la que atiende la comisaria&quot;) +
  ylab(&quot;Porcentaje&quot;) +
  geom_text(aes(label=round(Porc,1)), vjust=1.30, color=&quot;white&quot;, size=3)+
  theme_minimal()</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-35-1.png" width="672" /></p>
</div>
<div id="mediana" class="section level2">
<h2>Mediana</h2>
<ul>
<li>El valor de la observación central de un conjunto de datos ordenados
de menor a mayor.</li>
</ul>
<p><img src="mediana1.png" width="497" /></p>
<p><img src="mediana2.png" width="498" /></p>
<p>Para calcular la mediana de la variable “INF109” se puede usar el
comando <code>median</code>. Este comando internamente ordena los
valores de la variable “INF109” de menor a mayor y encuentra el código
numérico de la observación que se encuentra en medio de la distribución
ordenada.</p>
<pre class="r"><code>comi17 |&gt;
  summarise(median(INF109))</code></pre>
<pre><code>##   median(INF109)
## 1              3</code></pre>
<p>La mediana es el código numérico 3, que significa “De 10,001 a 20,000
hab.”.</p>
<hr />
</div>
<div id="media" class="section level2">
<h2>Media</h2>
<ul>
<li><p>Medida más conocida y “útil”.</p></li>
<li><p>Suma del valor de las observaciones dividida entre el número de
observaciones</p></li>
</ul>
<p><span class="math display">\[
\sum \frac{x_i} {n} = \frac{(x_1 + x_2 +x_3 +...+ x_n)} {n}
\]</span></p>
<p>En una base de datos, se puede calcular la media sumando los valores
de una variable (columna de una base de datos) y dividiendo entre el
número de casos (# total de filas).</p>
<p><img src="comi17_media.png" width="258" /></p>
<hr />
</div>
<div id="resumen" class="section level2">
<h2>Resumen</h2>
<table>
<thead>
<tr class="header">
<th>TC</th>
<th align="center">Nominales</th>
<th align="center">Ordinales</th>
<th align="center">Numéricas</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Moda</td>
<td align="center">Sí</td>
<td align="center">Sí</td>
<td align="center">Sí</td>
</tr>
<tr class="even">
<td>Mediana</td>
<td align="center">No</td>
<td align="center">Sí</td>
<td align="center">Sí</td>
</tr>
<tr class="odd">
<td>Media</td>
<td align="center">No</td>
<td align="center">No</td>
<td align="center">Sí</td>
</tr>
</tbody>
</table>
<ul>
<li><p>Moda aplica para cualquier tipo de variable, pero menos
útil.</p></li>
<li><p>Media aplica solo para variables numéricas, pero más
útil.</p></li>
</ul>
<hr />
<p>¿Cuál es la media (o el promedio) de policías por comisaria de
acuerdo a estos datos?</p>
<pre class="r"><code>comi17 |&gt;
  summarise(mean(INF110_TOT))</code></pre>
<pre><code>##   mean(INF110_TOT)
## 1         31.61538</code></pre>
<p>¿Es una representación adecuada de la realidad? Podemos fijarnos en
el gráfico de distribución de esta variable para ver si se tiene
comisarias que son “atípicas” de la distribución general.</p>
<p>Esto se puede hacer presentando el histograma de esta variable, que
es como un gráfico de barras de una variable numérica.</p>
<pre class="r"><code>library(ggplot2)
ggplot(comi17, aes(x=INF110_TOT))+
  geom_histogram()+
  xlab(&quot;Número de efectivos&quot;) +
  ylab(&quot;Frecuencia&quot;)+
  theme_light()</code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick
## better value with `binwidth`.</code></pre>
<p><img src="clase2_files/figure-html/hist-1.png" width="672" /></p>
<p>¿Qué se puede concluir del gráfico?</p>
<pre class="r"><code>comi17 |&gt;
  summarise(median(INF110_TOT))</code></pre>
<pre><code>##   median(INF110_TOT)
## 1                 19</code></pre>
<p>¿Qué significa esta diferencia entre la media de 31.6 y la mediana de
19?</p>
<pre class="r"><code>comi17 |&gt;
  summarise(min(INF110_TOT), median(INF110_TOT), 
            mean(INF110_TOT), max(INF110_TOT))</code></pre>
<pre><code>##   min(INF110_TOT) median(INF110_TOT) mean(INF110_TOT) max(INF110_TOT)
## 1               3                 19         31.61538             259</code></pre>
<pre class="r"><code>ggplot(comi17, aes(x=INF110_TOT))+
  geom_histogram()+
  geom_vline(xintercept = 19, color = &quot;red&quot;)+
  geom_vline(xintercept = 31.6, color = &quot;green&quot;)+
  xlab(&quot;Número de efectivos&quot;) +
  ylab(&quot;Frecuencia&quot;)+
  theme_light()</code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick
## better value with `binwidth`.</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<p>¿Qué se puede comentar de estos datos?</p>
</div>
<div id="medidas-de-dispersión" class="section level2">
<h2>Medidas de dispersión</h2>
<ul>
<li><p>Describir la centralidad no es suficiente. Dos distribuciones
pueden tener la misma medida de tendencia central, pero diferentes
realidades.</p></li>
<li><p>Ejemplo: distribución de puntaje en área matemática de prueba
PISA aplicada en 2 países pueden tener la misma media, pero diferente
variación.</p></li>
<li><p>¿Cómo describiría las diferencias entre en los puntajes de la
prueba el País A y el País B?</p></li>
</ul>
<p><img src="distr.png" width="631" /></p>
<hr />
</div>
<div id="rango" class="section level2">
<h2>Rango</h2>
<ul>
<li><p>Diferencia entre el valor máximo y el mínimo. En ejemplo de
policías: 259-3 = 256. Es la diferencia entre la comisaría con más
efectivos y la comisaría con menor número de efectivos.</p></li>
<li><p>No un una medida muy útil.</p></li>
</ul>
<hr />
</div>
<div id="rango-intercuartil" class="section level2">
<h2>Rango intercuartil</h2>
<ul>
<li>Se verá cuando se vean percentiles.</li>
</ul>
<hr />
</div>
<div id="desviación-estándar" class="section level2">
<h2>Desviación estándar</h2>
<ul>
<li><p>Cada observación está a una “distancia” de la media. Esta
distancia se llama desviación <span
class="math inline">\((x_i-\bar{x})\)</span></p></li>
<li><p>Observaciones por encima de la media tendrán desviaciones
positivas. Observaciones por debajo de la media tendrán desviaciones
negativas.</p></li>
<li><p>No se puede calcular un promedio de desviaciones porque valores
positivos se cancelan con negativos.</p></li>
<li><p>Se eleva al cuadrado las observaciones para que todas sean
positivas. Se promedian esas desviaciones al cuadrado.</p></li>
<li><p>La desviación estándar es la raíz cuadrada de ese promedio de
desviaciones al cuadrado.</p></li>
<li><p>Se divide entre n-1 por un tema técnico.</p></li>
</ul>
<p><span class="math display">\[
\sum \frac{(x_i-\bar{x})^2} {n-1}
\]</span></p>
<p>Para ver un cálculo básico de la desviación estándar en Excel, puede
entrar <a
href="https://docs.google.com/spreadsheets/d/1CCzOtfXf7Igz_KcbcpItzU71fWeMtTli?rtpof=true&amp;authuser=arturo.maldonado%40pucp.pe&amp;usp=drive_fs">aquí</a>.</p>
<ul>
<li>Como se observa en el gráfico anterior, la desviación estándar es
más útil cuando se comparar dos distribuciones. Se compara la
centralidad y la dispersión de una variable entre dos grupos (o dos
distribuciones).</li>
</ul>
<pre class="r"><code>comi17 |&gt;
  summarise(sd(INF110_TOT))</code></pre>
<pre><code>##   sd(INF110_TOT)
## 1        32.1814</code></pre>
<p>Siguiendo con la base de datos de comisarías del Perú, queremos
evaluar si el número de policías (INF110_TOT) aumenta a medida que la
comisaría atienda a una población mayor (INF109).</p>
<p>Como se vio antes, la variable de población a la que atiende está
codificada en 6 grupos, desde 1 que significa “Menos de 5000 hab” a 6
que significa “De 80000 a más hab”.</p>
<pre class="r"><code>tabla1</code></pre>
<pre><code>##                   Tipo Frecuencia      Porc
## 1    Menos de 5000 Hab        288 19.264214
## 2  De 5000 - 10000 Hab        329 22.006689
## 3 De 10001 - 20000 Hab        290 19.397993
## 4 De 20001 - 40000 Hab        248 16.588629
## 5     De 40001 a 80000        196 13.110368
## 6       De 80001 a más        144  9.632107</code></pre>
<p>Lo que se quiere calcular es el promedio y la desviación estándar de
policías por cada grupo de población a la que atiende. Esta operación se
puede hacer de múltiples maneras en R.</p>
<pre class="r"><code>comi17 |&gt;
  group_by(tipo) |&gt;
  summarise(mean(INF110_TOT))</code></pre>
<pre><code>## # A tibble: 6 × 2
##   tipo                 `mean(INF110_TOT)`
##   &lt;fct&gt;                             &lt;dbl&gt;
## 1 Menos de 5000 Hab                  13.4
## 2 De 5000 - 10000 Hab                16.3
## 3 De 10001 - 20000 Hab               21.0
## 4 De 20001 - 40000 Hab               33.2
## 5 De 40001 a 80000                   62.8
## 6 De 80001 a más                     79.3</code></pre>
<p>Efectivamente, como se esperaba, el número promedio de policías
aumenta a medida que la comisaría atiende a una población mayor.</p>
<p>También se puede comparar la desviación estándar en cada grupo. El
comando para el cálculo de la desviación estándar es
<code>sd</code>.</p>
<pre class="r"><code>mediaxtipo = comi17 |&gt;
  group_by(Tipo = tipo) |&gt;
  summarise(Media = mean(INF110_TOT), Desv = sd(INF110_TOT))
mediaxtipo</code></pre>
<pre><code>## # A tibble: 6 × 3
##   Tipo                 Media  Desv
##   &lt;fct&gt;                &lt;dbl&gt; &lt;dbl&gt;
## 1 Menos de 5000 Hab     13.4  7.75
## 2 De 5000 - 10000 Hab   16.3 10.2 
## 3 De 10001 - 20000 Hab  21.0 16.6 
## 4 De 20001 - 40000 Hab  33.2 22.7 
## 5 De 40001 a 80000      62.8 38.5 
## 6 De 80001 a más        79.3 44.0</code></pre>
<p>La desviación estándar también aumenta a medida que las comisarías
atienden a una población mayor. Es decir, las comisarías que atienden a
una población pequeña son más homogéneas que las que atienden a una
población mayor, donde hay mayores diferencias en el número de efectivos
entre comisarías.</p>
<p>¿A qué puede deberse este resultado? Una posible explicación es la
complejidad de ciudades más grandes, por lo que podría requerir
comisarias especializadas, además de las comisarias estándar. Por el
contrario, centros urbanos más pequeños solo requerirían comisarías
pequeñas.</p>
<p>En R hay diferentes maneras de hacer lo mismo. Para los gráficos
existe una librería especializada llamada <code>ggplot2</code>. Con esa
librería se tiene más opciones gráficas que con los comandos de base.
También existe una forma de codificación llamado <code>tidyverse</code>
que usa el operador <code>%&gt;%</code>. Aquí se presenta un ejemplo que
produce el histograma del número de policías por cada grupo de tamaño de
población.</p>
<pre class="r"><code>library(ggplot2)
library(dplyr)
comi17 |&gt;
  ggplot(aes(x=INF110_TOT))+
  geom_histogram()+
  facet_wrap(~tipo)+
  xlab(&quot;Número de policías&quot;)+
  ylab(&quot;Frecuencia&quot;)</code></pre>
<pre><code>## `stat_bin()` using `bins = 30`. Pick
## better value with `binwidth`.</code></pre>
<p><img src="clase2_files/figure-html/histgrupos-1.png" width="672" /></p>
<p>¿Qué otras preguntas se pueden responder con los datos de
comisarías?</p>
<pre class="r"><code>ggplot(mediaxtipo, aes(x=Tipo, y=Media)) + 
  geom_bar(stat = &quot;identity&quot;) +
  ggtitle(&quot;Número de efectivos promedio por tipo de comisaría&quot;) +
  xlab(&quot;Tipo de comisaría&quot;) +
  geom_text(aes(label=round(Media,1)), vjust=1.30, color=&quot;white&quot;, size=3)+
  theme_minimal()</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<p>Otra forma de describir descriptivamente esta variable mediante un
gráfico es mediante el gráfico de cajas o “boxplot”. Este gráfico
muestra el mínimo, los cuartiles y el máximo. Los cuartiles dividen el
número de observaciones en cuatro grupos de igual tamaño, aunque sus
límites difieren. El segundo cuartil es la mediana.</p>
<pre class="r"><code>ggplot(comi17, aes(y=INF110_TOT, x=tipo))+
  geom_boxplot()+
  scale_y_continuous(limits = c(0, 300), breaks = seq(0, 300, 50))+
  ylab(&quot;Número de efectivos&quot;)+
  xlab(&quot;Tipo de comisaría&quot;)+
  theme_get()</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-40-1.png" width="672" /></p>
<hr />
<p>Se pueden calcular los cuartiles para toda la distribución con el
comando <code>quantile</code>. Estos datos muestran que entre el 25% de
todas las comisarías tienen entre 3 y 11 efectivos. El segundo 25% de
comisarías tiene entre 11 y 19 efectivos. El tercer 25% tiene entre 19 7
37 efectivos, y el último 25% tiene entre 37 y 259 efectivos.</p>
<pre class="r"><code>comi17 |&gt; 
  summarise(Cuartiles = quantile(INF110_TOT))</code></pre>
<pre><code>## Warning: Returning more (or less) than 1 row
## per `summarise()` group was
## deprecated in dplyr 1.1.0.
## ℹ Please use `reframe()` instead.
## ℹ When switching from `summarise()`
##   to `reframe()`, remember that
##   `reframe()` always returns an
##   ungrouped data frame and adjust
##   accordingly.
## Call
## `lifecycle::last_lifecycle_warnings()`
## to see where this warning was
## generated.</code></pre>
<pre><code>##   Cuartiles
## 1         3
## 2        11
## 3        19
## 4        37
## 5       259</code></pre>
<p>Los cuartiles también se pueden calcular por tipo de comisaría. Este
código nos muestra los cuartiles por tipo de comisaría en cada fila.</p>
<pre class="r"><code>cuartilesxtipo = comi17 |&gt; 
  group_by(tipo) |&gt;
  summarise(quantile(INF110_TOT))</code></pre>
<pre><code>## Warning: Returning more (or less) than 1 row
## per `summarise()` group was
## deprecated in dplyr 1.1.0.
## ℹ Please use `reframe()` instead.
## ℹ When switching from `summarise()`
##   to `reframe()`, remember that
##   `reframe()` always returns an
##   ungrouped data frame and adjust
##   accordingly.
## Call
## `lifecycle::last_lifecycle_warnings()`
## to see where this warning was
## generated.</code></pre>
<pre><code>## `summarise()` has grouped output by
## &#39;tipo&#39;. You can override using the
## `.groups` argument.</code></pre>
<pre class="r"><code>cuartilesxtipo</code></pre>
<pre><code>## # A tibble: 30 × 2
## # Groups:   tipo [6]
##    tipo                `quantile(INF110_TOT)`
##    &lt;fct&gt;                                &lt;dbl&gt;
##  1 Menos de 5000 Hab                        4
##  2 Menos de 5000 Hab                        9
##  3 Menos de 5000 Hab                       11
##  4 Menos de 5000 Hab                       15
##  5 Menos de 5000 Hab                       43
##  6 De 5000 - 10000 Hab                      4
##  7 De 5000 - 10000 Hab                     10
##  8 De 5000 - 10000 Hab                     14
##  9 De 5000 - 10000 Hab                     18
## 10 De 5000 - 10000 Hab                     72
## # ℹ 20 more rows</code></pre>
<p>El ancho de cada caja es un estadístico de dispersión. Este
estadístico se llama rango intercuartil y formalmente es la resta del
cuartil 75 menos el cuartil 25.</p>
<p>La tabla nos muestra los dos estadísticos de dispersión, el rango
intercuartil y la desviación estándar. Para comparar entre grupos se
puede comparar medianas contra medianas y rangos intercuartiles. Esto se
puede hacer en un gráfico de cajas. Otra forma de comparar es medias
contra medias y desviaciones estándar por grupo.</p>
<pre class="r"><code>ricxtipo = comi17 |&gt;
  group_by(tipo) |&gt;
  summarise(Media= mean(INF110_TOT), Desv.Estd = sd(INF110_TOT), 
            Mediana = median(INF110_TOT), RIC= IQR(INF110_TOT))
ricxtipo</code></pre>
<pre><code>## # A tibble: 6 × 5
##   tipo                 Media Desv.Estd Mediana   RIC
##   &lt;fct&gt;                &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 Menos de 5000 Hab     13.4      7.75    11     6  
## 2 De 5000 - 10000 Hab   16.3     10.2     14     8  
## 3 De 10001 - 20000 Hab  21.0     16.6     17    13  
## 4 De 20001 - 40000 Hab  33.2     22.7     26    25  
## 5 De 40001 a 80000      62.8     38.5     58.5  53.5
## 6 De 80001 a más        79.3     44.0     80.5  67</code></pre>
<p>Regularmente ambas comparaciones son consistentes.</p>
</div>
<div id="descripción-de-variable-de-tipo-factor" class="section level2">
<h2>Descripción de variable de tipo factor</h2>
<pre class="r"><code>library(rio) 
comi17_2 = import(&quot;bases/comi2017_2.sav&quot;)</code></pre>
<pre class="r"><code>comi17_2 = comi17_2 |&gt;
  mutate(agua = recode(INF264_A, &#39;1&#39; = &#39;1&#39;, &#39;2&#39; = &#39;1&#39;, &#39;3&#39; = &#39;1&#39;, &#39;4&#39; = &#39;0&#39;))</code></pre>
<pre class="r"><code>comi17_2 = comi17_2 |&gt;
  mutate(luz = recode(INF264_B, &#39;1&#39; = &#39;1&#39;, &#39;2&#39; = &#39;1&#39;, &#39;3&#39; = &#39;1&#39;, &#39;4&#39; = &#39;0&#39;))</code></pre>
<pre class="r"><code>comi17_2 = comi17_2 |&gt;
  mutate(telefono = recode(INF264_C, &#39;1&#39; = &#39;1&#39;, &#39;2&#39; = &#39;1&#39;, &#39;3&#39; = &#39;1&#39;, &#39;4&#39; = &#39;0&#39;))</code></pre>
<pre class="r"><code>comi17_2 = comi17_2 |&gt;
  mutate(internet = recode(INF264_E, &#39;1&#39; = &#39;1&#39;, &#39;2&#39; = &#39;1&#39;, &#39;3&#39; = &#39;1&#39;, &#39;4&#39; = &#39;0&#39;))</code></pre>
<pre class="r"><code>comi17_2 = comi17_2 |&gt;
  mutate(internet = factor(internet, labels=c(&quot;No&quot;, &quot;Sí&quot;)))</code></pre>
<pre class="r"><code>tabla2 = comi17_2 |&gt;
  count(Tiene = internet, name=&quot;Frecuencia&quot;) |&gt;
  mutate(Porcentaje = (Frecuencia / sum(Frecuencia)*100 ))
tabla2</code></pre>
<pre><code>##   Tiene Frecuencia Porcentaje
## 1    No        286   19.13043
## 2    Sí       1209   80.86957</code></pre>
<pre class="r"><code>ggplot(tabla2, aes(x=Tiene, y=Porcentaje)) + 
  geom_bar(stat = &quot;identity&quot;) +
  ggtitle(&quot;Comisaría tiene internet&quot;) +
  xlab(&quot;Cuenta con servicio de internet&quot;) +
  geom_text(aes(label=round(Porcentaje,1)), vjust=1.30, color=&quot;white&quot;, size=3)+
  theme_minimal()</code></pre>
<p><img src="clase2_files/figure-html/unnamed-chunk-51-1.png" width="672" /></p>
</div>
</div>
<div id="bibliografía" class="section level1">
<h1>Bibliografía</h1>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAnQ2xhc2UgMjogZGVzY3JpcGNpw7NuIHkgdmlzdWFsaXphY2nDs24nCmF1dGhvcjogIkFydHVybyBNYWxkb25hZG8iCmRhdGU6ICIyNi8wMy8yMDI0IgpvdXRwdXQ6CiAgaHRtbF9kb2N1bWVudDoKICAgIHRvYzogdHJ1ZQogICAgdG9jX2Zsb2F0OiB0cnVlCiAgICBjb2xsYXBzZWQ6IGZhbHNlCiAgICBudW1iZXJfc2VjdGlvbnM6IGZhbHNlCiAgICB0b2NfZGVwdGg6IDEKICAgIGNvZGVfZG93bmxvYWQ6IHRydWUKICAgIHRoZW1lOiBjb3NtbwogICAgaGlnaGxpZ2h0OiB0ZXh0bWF0ZQplZGl0b3Jfb3B0aW9uczoKICBtYXJrZG93bjoKICAgIHdyYXA6IHNlbnRlbmNlCmJpYmxpb2dyYXBoeTogcmVmZXJlbmNlcy5iaWIKLS0tCgpgYGB7ciBzZXR1cCwgaW5jbHVkZT1GQUxTRX0Ka25pdHI6Om9wdHNfY2h1bmskc2V0KGVjaG8gPSBUUlVFKQpgYGAKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKIyBDYXNvIDE6IEFwb3lvIGEgbGEgZGVtb2NyYWNpYSBlbiBBbcOpcmljYSBMYXRpbmEKCipQcmVndW50YTogwr9leGlzdGUgdW5hIGVyb3Npw7NuIGRlbCBhcG95byBhIGxhIGRlbW9jcmFjaWEgZW50cmUgbG9zIGNpdWRhZGFub3MgZW4gQW3DqXJpY2EgTGF0aW5hPyoKCiMjIExlZXIgdW5hIGJhc2UgZGUgZGF0b3MKClVzYW1vcyBsYSBsaWJyZXLDrWEgYHJpb2AuCkFjdGl2YW1vcyBsYSBsaWJyZXLDrWEgY29uIGVsIGNvbWFuZG8gYGxpYnJhcnlgIHkgdXNhbW9zIGVsIGNvbWFuZG8gYGltcG9ydGAgcGFyYSBsZWVyIGxhIGJhc2UgZGUgZGF0b3MgKHVuIGFyY2hpdm8gRXhjZWwpLgpPam86IGVsIG5vbWJyZSBkZWwgYXJjaGl2byB0aWVuZSBxdWUgZXN0YXIgZW50cmUgY29taWxsYXMuCkVuIGVzdGUgY2FzbywgZWwgYXJjaGl2byBlc3TDoSBkZW50cm8gZGUgbWkgZGlyZWN0b3JpbyBkZSB0cmFiYWpvLCBwb3IgbG8gcXVlIHNlIGxlIGxsYW1hIGNvbiBlbCBub21icmUuClNpIG5vIGVzdHV2aWVyYSBlbiBlbCBkaXJlY3RvcmlvIGRlIHRyYWJham8gc2UgdGVuZHLDrWEgcXVlIGVzcGVjaWZpY2FyIGxhIHJ1dGEgZGVsIGFyY2hpdm8uCgpHdWFyZGFtb3MgZXN0YSBiYXNlIGRlIGRhdG9zIGVuIHVuIG51ZXZvIG9iamV0byAoZGF0YWZyYW1lKSBsbGFtYWRvIGFwb3lvQUwuClNlIHN1Z2llcmUgc2llbXByZSB0cmFiYWphciBjb24gbm9tYnJlcyBjb3J0b3MgZGUgYmFzZXMgZGUgZGF0b3MgeSBkZSB2YXJpYWJsZXMuCgpgYGB7cn0KbGlicmFyeShyaW8pCmFwb3lvQUwgPSBpbXBvcnQoImFwb3lvQUwueGxzeCIpCmBgYAoKIyMgRGVzY3JpcGNpw7NuIHBhcmEgdmFyaWFibGVzIG51bcOpcmljYXMKClVzYW1vcyBsYXMgbWVkaWRhcyBkZSB0ZW5kZW5jaWEgY2VudHJhbCBwYXJhIGRlc2NyaWJpciB1bmEgdmFyaWFibGUgbnVtw6lyaWNhLgpQb2RlbW9zIHVzYXIgZWwgY29tYW5kbyBgbWVhbmAgcGFyYSBjYWxjdWxhciBlbCBwcm9tZWRpbyBkZSBhcG95byBhIGxhIGRlbW9jcmFjaWEgZW4gMjAyMy4KRXN0ZSBjb21hbmRvIGFzdW1lIHF1ZSBzZSB0aWVuZW4gZGF0b3MgY29tcGxldG9zLgpDb21vIGV4aXN0ZSB1biBkYXRvIHBlcmRpZG8sIGVsIGNvbWFuZG8gbm8gY29ycmUsIHkgc2UgdGllbmUgcXVlIGHDsWFkaXIgbGEgZXNwZWNpZmljYWNpw7NuIGAsIG5hLnJtID0gVGAuCgpgYGB7cn0KbGlicmFyeSh0aWR5dmVyc2UpCmFwb3lvQUwgfD4KICBzdW1tYXJpc2UoQXBveW8yMDIzPW1lYW4oYXBveW8yMDIzLCBuYS5ybT1UKSkKYGBgCgpUYW1iacOpbiBzZSBwdWVkZSBjYWxjdWxhciBsYSBtZWRpYW5hLCBjb24gZWwgY29tYW5kbyBgbWVkaWFuYCB5IHByZXNlbnRhciBhbWJhcyBtZWRpZGFzIGp1bnRhcy4KCmBgYHtyfQphcG95b0FMIHw+CiAgc3VtbWFyaXNlKFByb21lZGlvX0Fwb3lvMjAyMz1tZWFuKGFwb3lvMjAyMywgbmEucm09VCksIAogICAgICAgICAgICBNZWRpYW5hX0Fwb3lvMjAyMz1tZWRpYW4oYXBveW8yMDIzLCBuYS5ybT1UKSkKYGBgCgpBaG9yYSBsbyBxdWUgcXVlcmVtb3MgYXZlcmlndWFyIGVzIHNpIGVsIGFwb3lvIGEgbGEgZGVtb2NyYWNpYSBoYSBkaXNtaW51aWRvLCBhdW1lbnRhZG8gbyBwZXJtYW5lY2lkbyBpZ3VhbCBlbnRyZSAyMDIxIHkgMjAyMy4KUGFyYSBlc3RvLCBwb2RlbW9zIGNvbXBhcmFyIGxhIG1lZGlhIGRlbCBhcG95byBhIGxhIGRlbW9jcmFjaWEgZW4gMjAyMSBjb24gbGEgbWVkaWEgZW4gMjAyMy4KCmBgYHtyfQphcG95b0FMIHw+CiAgc3VtbWFyaXNlKFByb21lZGlvX0Fwb3lvMjAyMT1tZWFuKGFwb3lvMjAyMSwgbmEucm09VCksIAogICAgICAgICAgICBQcm9tZWRpb19BcG95bzIwMjM9bWVhbihhcG95bzIwMjMsIG5hLnJtPVQpKQpgYGAKClNlZ8O6biBlc3RvcyByZXN1bHRhZG9zLCBlbCBhcG95byBhIGxhIGRlbW9jcmFjaWEgaGEgZGlzbWludWlkbyBkZSA2MS4yJSBhIDU4LjYlOyBlcyBkZWNpciwgdW5hIGRpc21pbnVjacOzbiBkZSAyLjYgcHVudG9zIHBvcmNlbnR1YWxlcy4KCkxvcyBkYXRvcyBkZSAyMDIzIGluY2x1eWVuIHBhw61zZXMgY2FyaWJlw7FvcyAoQmFoYW1hcywgR3JhbmFkYSwgVHlUIHkgU3VyaW7DoW0pIHF1ZSBubyBlc3RhYmFuIGVuIGVsIGdyw6FmaWNvIGRlIDIwMjEuCkVzIHBvc2libGUgcXVlIGVsIG1lbm9yIHByb21lZGlvIGRlIGFwb3lvIGEgbGEgZGVtb2NyYWNpYSBlbiAyMDIzIHNlYSBwb3IgbGEgaW5jb3Jwb3JhY2nDs24gZGUgZXN0b3MgcGHDrXNlcy4KU2UgcG9kcsOtYSBhcmd1bWVudGFyIHF1ZSBzaSBzZSB0dXZpZXJhIGxvcyBkYXRvcyBkZSBlc3RvcyBwYcOtc2VzIHBhcmEgMjAyMSwgcXVpesOhIG5vIGV4aXN0aXLDrWEgdW5hIGVyb3Npw7NuIGRlbCBhcG95byBhIGxhIGRlbW9jcmFjaWEuCgpVbmEgZm9ybWEgZGUgbGlkaWFyIGNvbiBlc3RhIG9ic2VydmFjacOzbiBlcyBjb21wYXJhciBsb3MgcmVzdWx0YWRvcyAyMDIzIHkgMjAyMSBzb2xvIGRlIGxvcyBwYcOtc2VzIHF1ZSB0aWVuZW4gZGF0b3MgZW4gYW1ib3MgYcOxb3MuCgojIyBEYXRhZnJhbWVzCgpBbnRlcyBkZSB2ZXIgY8OzbW8gZWxpbWluYXIgbG9zIHBhw61zZXMsIHVuYSBub3RhIHNvYnJlIGxhIGVzdHJ1Y3R1cmEgZGUgdW5hIGJhc2UgZGUgZGF0b3MuCkVsIGRhdGFmcmFtZSBhcG95b0FMIHRpZW5lIDI0IG9ic2VydmFjaW9uZXMgKDI0IGZpbGFzLCBlbiBjYWRhIHVuYSwgdW4gcGHDrXMpIHkgNCB2YXJpYWJsZXMgKDQgY29sdW1uYXMsIGVuIGNhZGEgdW5hLCB1bmEgdmFyaWFibGUpLgpQb3IgbG8gdGFudG8sIGVzdGUgZGF0YWZyYW1lIHRpZW5lIHVuYSBkaW1lbnNpw7NuIFsyNCwgNF0uCkVuIGdlbmVyYWwsIHVuIGRhdGFmcmFtZSB0aWVuZSBkaW1lbnNpw7NuIFsjZmlsYXMsICNjb2x1bW5hc10uCgpQb3IgbG8gdGFudG8sIHNlIHB1ZWRlIGxsYW1hciBhIGxvcyBlbGVtZW50b3MgZGUgdW4gZGF0YWZyYW1lIGluZGljYW5kbyBsYSBmaWxhIHkgbGEgY29sdW1uYS4KUG9yIGVqZW1wbG8sIHBhcmEgbGxhbWFyIGFsIGVsZW1lbnRvIGRlIGxhIHByaW1lcmEgZmlsYSB5IHNlZ3VuZGEgY29sdW1uYS4KCmBgYHtyfQphcG95b0FMWzQsMl0KYGBgCgpUYW1iacOpbiBzZSBwdWVkZSBsbGFtYXIgdG9kYSB1bmEgZmlsYS4KRW4gZXN0ZSBjYXNvLCBsYSBwcmltZXJhIGZpbGEuCgpgYGB7cn0KYXBveW9BTFsxLF0KYGBgCgpPIGxhIHNlZ3VuZGEgY29sdW1uYQoKYGBge3J9CmFwb3lvQUxbLDJdCmBgYAoKRXN0byBub3MgcGVybWl0ZSBzZWxlY2Npb25hciBmaWxhcyAocGHDrXNlcykgbyBjb2x1bW5hcyAodmFyaWFibGVzKSBiYWpvIGNpZXJ0YXMgY29uZGljaW9uZXMuCkVuIGdlbmVyYWwsIG5vcyBpbnRlcmVzYSBtw6FzIHNlbGVjY2lvbmFyIGZpbGFzLgoKUG9yIGVqZW1wbG8sIHNpIHF1ZXJlbW9zIHNlbGVjY2lvbmFyIGxvcyBwYcOtc2VzIHBvciBlbmNpbWEgZGUgbGEgbWVkaWEgZGUgYXBveW8gMjAyMywgcG9kZW1vcyBkZWNpcgoKYGBge3J9CmFwb3lvQUxbYXBveW9BTCRhcG95bzIwMjM+bWVhbihhcG95b0FMJGFwb3lvMjAyMywgbmEucm0gPSBUKSwgYygxLDQpXQpgYGAKCkVuIFIgZXhpc3RlIHVuIGNvbWFuZG8gcGFyYSBzZWxlY2Npb25hciBvYnNlcnZhY2lvbmVzLgpTZSBwdWVkZSB1c2FyIGBzdWJzZXRgIHBhcmEgaGFjZXIgZXN0ZSBmaWx0cm8uCkVzdGUgZmlsdHJvIHNlIHB1ZWRlIGFsbWFjZW5hciBlbiBvdHJvIGRhdGFmcmFtZS4KCmBgYHtyfQphcG95b19tYXlvcl9tZWRpYSA9IHN1YnNldChhcG95b0FMLCBhcG95bzIwMjMgPiBtZWFuKGFwb3lvMjAyMywgbmEucm09VCkpCmBgYAoKIyMgTGlkaWFuZG8gY29uIHZhbG9yZXMgcGVyZGlkb3MKClZvbHZpZW5kbyBhbCBlamVtcGxvIHkgYSBsYSByZXNwdWVzdGEgYSBsYSBvYnNlcnZhY2nDs24gZGUgY29tcGFyYXIgcGHDrXNlcyBjb24gbWVkaWNpb25lcyBlbiBhbWJvcyBhw7Fvcy4KU2kgc2UgYWJyZSBsYSBiYXNlIGRlIGRhdG9zICJhcG95b0FMIiwgc2Ugb2JzZXJ2YSBxdWUgYXBveW8yMDIxIHRpZW5lIDQgTkFzIHkgYXBveW8yMDIzIHRpZW5lIDEgTkEuCgpTZSBwdWVkZSBlbGltaW5hciBsb3MgcGHDrXNlcyBxdWUgdGllbmVuIE5BcyBlbiBsYSB2YXJpYWJsZSAiYXBveW8yMDIxIi4KCmBgYHtyfQphcG95b1Npbk5BMjAyMSA9IGFwb3lvQUxbIShpcy5uYShhcG95b0FMJGFwb3lvMjAyMSkpLF0KYGBgCgpTZSBwdWVkZSBlbGltaW5hciBsb3MgcGHDrXNlcyBxdWUgdGllbmVuIE5BcyBlbiBsYSB2YXJpYWJsZSAiYXBveW8yMDIzIi4KCmBgYHtyfQphcG95b1Npbk5BMjAyMyA9IGFwb3lvQUxbIShpcy5uYShhcG95b0FMJGFwb3lvMjAyMykpLF0KYGBgCgpQZXJvLCBxdWVyZW1vcyBlbGltaW5hciBhbWJvczsgZXMgZGVjaXIsIHRhbnRvIGxvcyBwYcOtc2VzIGNvbiBOQXMgZW4gMjAyMyBZIGxvcyBwYcOtc2VzIGNvbiBOQXMgZW4gMjAyMS4KUGFyYSBlc3RvIHVzYW1vcyBlbCBvcGVyYWRvciBsw7NnaWNvICImIi4KCkVuIFIgdGVuZW1vcyBsb3Mgc2lndWllbnRlcyBvcGVyYWRvcmVzIGzDs2dpY29zOgoKfCBPcGVyYWRvciB8ICAgIERlc2NyaXBjacOzbiAgICAgfAp8Oi0tLS0tLS0tOnw6LS0tLS0tLS0tLS0tLS0tLS0tOnwKfCAgICA9PSAgICB8ICAgICBlcyBpZ3VhbCBhICAgICB8CnwgICAgIT0gICAgfCAgZXMgZGlmZXJlbnRlIGRlICAgfAp8ICAgIFw+ICAgIHwgICAgZXMgbWF5b3IgZGUgICAgIHwKfCAgICBcPCAgICB8ICAgIGVzIG1lbm9yIGRlICAgICB8CnwgICBcPj0gICAgfCBlcyBtYXlvciBvIGlndWFsIGEgfAp8ICAgXDw9ICAgIHwgZXMgbWVub3IgbyBpZ3VhbCBhIHwKfCAgICAmICAgICB8ICBpbnRlcnNlY2Npw7NuIChZKSAgfAp8ICAgIFx8ICAgIHwgICAgIHVuacOzbiAoTykgICAgICB8CgpgYGB7cn0KYXBveW9TaW5OQSA9IGFwb3lvQUxbIShpcy5uYShhcG95b0FMJGFwb3lvMjAyMSkpICYgIShpcy5uYShhcG95b0FMJGFwb3lvMjAyMykpLF0KYGBgCgpFc3RvIG1pc21vIHNlIHB1ZWRlIGxvZ3JhciBjb24gZWwgY29tYW5kbyBgc3Vic2V0YC4KCmBgYHtyfQphcG95b1Npbk5BMiA9IHN1YnNldChhcG95b0FMLCAKICAgICAgICAgICAgICAgICAgICAgIShpcy5uYShhcG95b0FMJGFwb3lvMjAyMSkpICYgIShpcy5uYShhcG95b0FMJGFwb3lvMjAyMykpKQpgYGAKClkgdGFtYmnDqW4gc2UgcHVlZGUgaGFjZXIsIHVzYW5kbyBlbCB0aWR5dmVyc2UuCkVuIGVzdGUgY3Vyc28gdGVuZW1vcyB1bmEgcHJlZmVyZW5jaWEgcG9yIGVzdGUgZXN0aWxvIGRlIGPDs2RpZ28uClBlcm8sIGNvbW8gcHVlZGVuIHZlciBzZSBwdWVkZSBsb2dyYXIgbG9zIG1pc21vcyByZXN1bHRhZG9zIGRlIG11Y2hhcyBtYW5lcmFzIGVuIFIuCgpgYGB7cn0KYXBveW9TaW5OYTMgPSBhcG95b0FMIHw+IAogIGZpbHRlcighKGlzLm5hKGFwb3lvQUwkYXBveW8yMDIxKSkgJiAhKGlzLm5hKGFwb3lvQUwkYXBveW8yMDIzKSkpIApgYGAKCkNvbiBlc3RlIG51ZXZvIGRhdGFmcmFtZSwgcXVlIGNvbnRpZW5lIHNvbG8gbG9zIHBhw61zZXMgcXVlIHRpZW5lbiBlbCBkYXRvIGRlIGFwb3lvIGEgbGEgZGVtb2NyYWNpYSB0YW50byBlbiAyMDIxIGNvbW8gZW4gMjAyMywgc2UgcHVlZGUgcmVzcG9uZGVyIGEgbGEgb2JzZXJ2YWNpw7NuLgpQb2RlbW9zIGNvbXBhcmFyIGxhIG1lZGlhIGRlIGFtYm9zIGHDscOzcyB1c2FuZG8gZXN0ZSBudWV2byBkYXRhZnJhbWUuCgpgYGB7cn0KYXBveW9TaW5OYTMgfD4KICBzdW1tYXJpc2UoUHJvbWVkaW9BcG95bzIwMjE9bWVhbihhcG95bzIwMjEsIG5hLnJtPVQpLCAKICAgICAgICAgICAgUHJvbWVkaW9BcG95bzIwMjM9bWVhbihhcG95bzIwMjMsIG5hLnJtPVQpKQpgYGAKCkxvcyByZXN1bHRhZG9zIGluZGljYW4gcXVlIGhheSB1bmEgZGlzbWludWNpw7NuIGRlIDIuMSBwdW50b3MgcG9yY2VudHVhbGVzLCByZXN1bHRhZG9zIHVuIHBvY28gbWVub3IgcXVlIGVsIGFudGVyaW9yICgyLjYgcHApLCBwZXJvIHF1ZSB2YSBlbiBsYSBtaXNtYSBkaXJlY2Npw7NuIGRlIGRlY2lyIHF1ZSBoYXkgdW5hIGVyb3Npw7NuIGRlbCBhcG95byBjaXVkYWRhbm9zIGEgbGEgZGVtb2NyYWNpYS4KCiMgQ2FzbyAyOiBSZXN1bHRhZG9zIGVsZWN0b3JhbGVzIDIwMTYKCipQcmVndW50YTogQWxndW5vcyBwb2xpdMOzbG9nb3MgY29uc2lkZXJhbiBxdWUgdW4gcGFydGlkbyBtw6FzIGluc3RpdHVjaW9uYWxpemFkbyBlcyBlbCBxdWUgZXMgY2FwYXogZGUgdGVuZXIgdW4gbWF5b3IgZW5yYWl6YW1pZW50byB0ZXJyaXRvcmlhbCB5LCBwb3IgbG8gdGFudG8sIHRlbmVyIHVuIGFwb3lvIGVsZWN0b3JhbCByZWxhdGl2YW1lbnRlIGNvbnN0YW50ZSBhIGxvIGxhcmdvIGRlbCB0ZXJyaXRvcmlvLiBQb3IgZWwgY29udHJhcmlvLCB1biBwYXJ0aWRvIG1lbm9zIGluc3RpdHVjaW9uYWxpemFkbywgc29sbyBsb2dyYXLDrWEgYXBveW9zIGVsZWN0b3JhbGVzIGRpZmVyZW5jaWFkb3MsIG1heW9yZXMgZW4gYWxndW5vcyB0ZXJyaXRvcmlvcyB5IG1lbm9yZXMgZW4gb3Ryb3MuKgoKKlNpZ3VpZW5kbyBlc3RhIGlkZWEsIMK/Y3XDoWwgZnVlIGVsIHBhcnRpZG8gbWFzIG8gbWVub3MgaW5zdGl0dWNpb25hbGl6YWRvIGRlIGFjdWVyZG8gYSBsb3MgcmVzdWx0YWRvcyBlbGVjdG9yYWxlcyBkZSAyMDE2PyoKCiMjIExlZXIgdW5hIGJhc2UgZGUgZGF0b3MKCmBgYHtyIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9CmxpYnJhcnkocmlvKQpyZXMyMDE2ID0gaW1wb3J0KCJyZXN1bHRhZG9zMjAxNi54bHN4IikKYGBgCgpTaSBzZSBoYWNlIGRvYmxlIGNsaWNrIGVuIGVsIG9iamV0bywgc2UgYWJyZSBsYSBiYXNlIGRlIGRhdG9zIGNvbW8gdW5hIHBlc3Rhw7FhIGVuIGxhIHpvbmEgZGUgc2NyaXB0cyAvIFJNYXJrZG93bnMuCkVzdGUgb2JqZXRvIGRhdGFmcmFtZSB0aWVuZSB2ZWN0b3JlcyBkZSBkYXRvcyBkZSB0aXBvICJjYXJhY3RlciIgeSBvdHJvcyB2ZWN0b3JlcyBkZSBkYXRvcyBkZSB0aXBvICJudW3DqXJpY28iLgoKIyMgRGVzY3JpcGNpw7NuIGRlIGxhIGhldGVyb2dlbmVpZGFkCgpVc2Ftb3MgbGFzIG1lZGlkYXMgZGUgZGlzcGVyc2nDs24gcGFyYSBkZXNjcmliaXIgdW5hIHZhcmlhYmxlIG51bcOpcmljYS4KUG9kZW1vcyB1c2FyIGVsIGNvbWFuZG8gYHNkYCBwYXJhIGNhbGN1bGFyIGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBkZWwgdm90byBwcm92aW5jaWFsIGEgRnVlcnphIFBvcHVsYXIsIGEgUGVydWFub3MgcG9yIGVsIEthbWJpbyB5IGFsIEZyZW50ZSBBbXBsaW8gZW4gMjAxNi4KRXN0ZSBjb21hbmRvIGFzdW1lIHF1ZSBzZSB0aWVuZW4gZGF0b3MgY29tcGxldG9zLgpTaSBleGlzdGllcmEgdW4gZGF0byBwZXJkaWRvLCBlbCBjb21hbmRvIG5vIGNvcnJlcsOtYSwgeSBzZSB0ZW5kcsOtYSBxdWUgYcOxYWRpciBsYSBlc3BlY2lmaWNhY2nDs24gYCwgbmEucm0gPSBUYC4KCmBgYHtyfQpsaWJyYXJ5KGRwbHlyKQpsaWJyYXJ5KHRpZHl2ZXJzZSkKcmVzMjAxNiB8PgogIHN1bW1hcmlzZShzZChmcCksIHNkKHBwayksIHNkKGZhKSkKYGBgCgpUYW1iacOpbiBzZSBwdWVkZSBjYWxjdWxhciBsYSBtZWRpYSBwYXJhIGdydXBvcyBkZSBvYnNlcnZhY2lvbmVzLCBlcyBkZWNpciBwYXJhIGZpbGFzIGVzcGVjw61maWNhcyBkZSB1bmEgYmFzZSBkZSBkYXRvcy4KVW5hIG9wY2nDs24gc2Vyw61hIGFncmVnYXIgdW4gbnVldm8gZGF0YWZyYW1lIGNvbiBlbCBmaWx0cmFkbyBkZSBsYXMgb2JzZXJ2YWNpb25lcy4KU2kgbm8gcXVlcmVtb3MgbGxlbmFybm9zIGRlIGJhc2VzIGRlIGRhdG9zIHBhcmNpYWxlcywgdGVuZW1vcyBvdHJhcyBvcGNpb25lcy4KClBvciBlamVtcGxvLCBzaSBxdWlzacOpcmFtb3Mgc2FiZXIgc2kgbGEgaGV0ZXJvZ2VuZWlkYWQgZGVsIHZvdG8gZnVlIG1heW9yIG8gbWVub3IgcXVlIGFxdWVsbGEgZGVsIHZvdG8gcHJvdmluY2lhbCBnZW5lcmFsIGRlIEZ1ZXJ6YSBQb3B1bGFyLCBwb2Ryw61hbW9zIGNhbGN1bGFyIGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBkZWwgdm90byBwcm92aW5jaWFsIHNvbG8gZW4gbGFzIHByb3ZpbmNpYXMgZGUgTGltYS4KCkVzdG8gc2UgcHVlZGUgaGFjZXIgZGUgbcO6bHRpcGxlcyBtYW5lcmFzLgpFbiBlc3RlIGN1cnNvIGNvbWVuemFyZW1vcyBhIHVzYXIgbGFzIGZ1bmNpb25lcyBkZWwgbXVuZG8gZGVsIFRpZHl2ZXJzZS4KCkVuIGN1YWxxdWllciBjYXNvLCBzZSB0aWVuZSBxdWUgc2VsZWNjaW9uYXIgYWxndW5hcyBmaWxhcyBkZSB1biBkYXRhZnJhbWUgdXNhbmRvIG9wZXJhZG9yZXMgbMOzZ2ljb3MuCkVuIG51ZXN0cm8gY2FzbyB2YW1vcyBhIHNlbGVjY2lvbmFyIGxhcyBvYnNlcnZhY2lvbmVzLCBjb24gZWwgY29tYW5kbyBgZmlsdGVyYCB5IGNvbiBsYSBjb25kaWNpw7NuIHF1ZSBlbiBlbCB2ZWN0b3IgbyB2YXJpYWJsZSAiZHB0byIgc2VhbiBpZ3VhbCBhICJMSU1BIi4KT2pvLCBlbiBtYXnDunNjdWxhcywgZGFkbyBxdWUgYXPDrSBlc3TDoSBlbiBsYSBiYXNlIGRlIGRhdG9zIHkgZW50cmUgY29taWxsYXMgcG9ycXVlIGVzIHVuYSBjYWRlbmEgZGUgY2FyYWN0ZXJlcy4KCmBgYHtyfQpyZXMyMDE2IHw+IAogIGZpbHRlcihkcHRvID09IkxJTUEiKSB8PgogIHN1bW1hcmlzZShzZChmcCksIHNkKHBwayksIHNkKGZhKSkKYGBgCgpFbmNvbnRyYW1vcyBxdWUgZW4gTGltYSBsYSBkZXN2aWFjacOzbiBlc3TDoW5kYXIgZGVsIHZvdG8gcHJvdmluY2lhbCBhIEZ1ZXJ6YSBQb3B1bGFyIGVzIG1heW9yIHF1ZSBsYSBkZSBvdHJvcyBwYXJ0aWRvcy4KVGFtYmnDqW4gc2UgcHVlZGUgY2FsY3VsYXIgbG9zIG1pc21vIHBhcmEgZWwgY2FzbyBkZSBDdXNjby4KCmBgYHtyIG1lc3NhZ2U9RkFMU0UsIHdhcm5pbmc9RkFMU0V9CnJlczIwMTYgfD4gCiAgZmlsdGVyKGRwdG8gPT0iQ1VTQ08iKSB8PgogIHN1bW1hcml6ZShzZChmcCksIHNkKHBwayksIHNkKGZhKSkKI0PDs21vIGNhbGN1bGFyw61hbiBlc3RhIG1lZGlhIHVzYW5kbyBsYSB2YXJpYWJsZSAiaWQiPwpgYGAKCiMjIFRhcmVhCgpMYSBiYXNlIGRlIGRhdG9zIHRhbWJpw6luIGluY2x1eWUgZWwgdm90byBwcm92aW5jaWFsIGEgRnVlcnphIFBvcHVsYXIgZW4gbGEgZWxlY2Npw7NuIGRlIDIwMjEuCgrCv0NhbGN1bGUgc2kgZWwgdm90byBwcm9tZWRpbyBkZSBGdWVyemEgUG9wdWxhciBoYSBhdW1lbnRhZG8gbyBkaXNtaW51aWRvIGVudHJlIDIwMTEgeSAyMDE2PwoKwr9DYWxjdWxlIGxvIG1pc21vIHBhcmEgZWwgZGVwYXJ0YW1lbnRvIGRlIFR1bWJlcz8KCsK/Q2FsY3VsZSBzaSBGdWVyemEgUG9wdWxhciBoYSBhdW1lbnRvIG8gZGlzbWludWlkbyBzdSBuaXZlbCBkZSBpbnN0aXR1Y2lvbmFsaXphY2nDs24/CgojIFZpc3VhbGl6YWNpw7NuCgpVbmEgZGUgbGFzIHRhcmVhcyBtw6FzIGNvbXVuZXMgZW4gZWwgbWFuZWpvIGRlIGRhdG9zIGVzIGxhIHZpc3VhbGl6YWNpw7NuIGRlIGxvcyByZXN1bHRhZG9zLgpFbiBSIGhheSBkb3MgbWFuZXJhcyBkZSBwcm9jZWRlci4KTGEgcHJpbWVyYSBlcyB1c2FyIGxvcyBjb21hbmRvcyBkZSBiYXNlIGRlIFIuCkxhIG90cmEgZXMgdXNhciB1bmEgbGlicmVyw61hIGBnZ3Bsb3QyYCBxdWUgcGVybWl0ZSB1bmEgbWF5b3IgZmxleGliaWxpZGFkIGVuIGxhIHByb2R1Y2Npw7NuIHkgZXN0w6l0aWNhIGRlIGxvcyBncsOhZmljb3MuCgpQYXJhIGVzdG8gc2UgY2FyZ2EgbGEgbGlicmVyw61hIGBnZ3Bsb3QyYC4KRXN0YSB0aWVuZSB1biBjb21hbmRvIGBnZ3Bsb3RgIGVuIGVsIHF1ZSBzZSBkZWZpbmUgbG9zIGFzcGVjdG9zIGRlbCBncsOhZmljby4KUG9yIGVqZW1wbG8sIHBhcmEgZ3JhZmljYXIgdW5hIHZhcmlhYmxlIG51bcOpcmljYSwgY29tbyBlbCBwb3JjZW50YWplIGRlIHZvdG8gYSBGUCBwb3IgcHJvdmluY2lhLCBzZSBwdWVkZSBwcm9kdWNpciB1biBoaXN0b2dyYW1hLgoKRGVudHJvIGRlIGVzdGUgY29tYW5kbyBzZSBkZWZpbmUgbGEgYmFzZSBkZSBkYXRvcyB5IGxhIHZhcmlhYmxlIHF1ZSBzZSB2YSBhIGdyYWZpY2FyLgpMdWVnbyBzZSB2YW4gYWdyZWdhbmRvIGNhcGFzLgpMYSBwcmltZXJhIGRlZmluZSBlbCB0aXBvIGRlIGdyw6FmaWNvLgpVc2Ftb3MgYGdlb21faGlzdG9ncmFtYCBwYXJhIHByb2R1Y2lyIGVsIGhpc3RvZ3JhbWEgeSBzZSBlc3BlY2lmaWNhIGVsIGFuY2hvIGRlIGNvbHVtbmEuCkx1ZWdvIHNlIGRlZmluZSBsYXMgZXRpcXVldGFzIGRlIGVqZXMgeSBlbCB0ZW1hIGRlbCBncsOhZmljby4KClNlIG9ic2VydmEgcXVlIGVsIGdyw6FmaWNvIGRlIHBvcmNlbnRhamUgZGUgdm90b3MgYSBGdWVyemEgUG9wdWxhciBlcyBhcHJveGltYWRhbWVudGUgc2ltw6l0cmljbywgdGFsIGNvbW8gaW5kaWNhYmFuIGxhIHNpbWlsaXR1ZCBlbnRyZSBtZWRpYSB5IG1lZGlhbmEuCgpgYGB7ciBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQpsaWJyYXJ5KGdncGxvdDIpCmdncGxvdChyZXMyMDE2LCBhZXMoeD1mcCkpKwogIGdlb21faGlzdG9ncmFtKGJpbndpZHRoID0gNSkrCiAgeGxhYigiJSBWb3RvIFBQSyAyMDE2IikgKwogIHlsYWIoIkZyZWN1ZW5jaWEiKSsKICB0aGVtZV9taW5pbWFsKCkKYGBgCgpIYWLDrWFtb3MgZW5jb250cmFkbyBxdWUgbGEgbWVkaWEgeSBsYSBtZWRpYW5hIGRlbCBwb3JjZW50YWplIGRlIHZvdG8gYWwgRnJlbnRlIEFtcGxpbyBkaWZlcsOtYW4uCkVzdG8gbG8gY29tcHJvYmFtb3MgcHJvZHVjaWVuZG8gZWwgaGlzdG9ncmFtYSBkZSBlc3RhIHZhcmlhYmxlLgoKYGBge3J9CmdncGxvdChyZXMyMDE2LCBhZXMoeD1mYSkpKwogIGdlb21faGlzdG9ncmFtKGJpbndpZHRoID0gNSkrCiAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gMjkuMywgY29sb3IgPSAicmVkIikrCiAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gMjQuNSwgY29sb3IgPSAiZ3JlZW4iKSsKICB4bGFiKCIlIFZvdG8gRkEgMjAxMSIpKwogIHlsYWIoIkZyZWN1ZW5jaWEiKSsKICB0aGVtZV9jbGFzc2ljKCkKYGBgCgpPdHJvIGdyw6FmaWNvIMO6dGlsIGVuIGxhIHZpc3VhbGl6YWNpw7NuIGVzIGVsIGxsYW1hZG8gImJveHBsb3QiIG8gImdyw6FmaWNvIGRlIGNhamFzIi4KRXN0ZSB0aXBvIGRlIGdyw6FmaWNvcyBzaXJ2ZSBiYXN0YW50ZSBwYXJhIGNvbXBhcmFyIGVudHJlIGdydXBvcyBkZSBvdHJhIHZhcmlhYmxlLgoKUGFyYSBwcm9kdWNpciB1biBncsOhZmljbyBkZSBjYWphcyB1c2Ftb3MgbGEgZXNwZWNpZmljYWNpw7NuIGBnZW9tX2Jsb3hwbG90KClgIHkgcG9kZW1vcyBkZWZpbmlyIGxvcyBsw61taXRlcyB5IHNhbHRvcyBkZWwgZWplIFkuCkVzdGUgZ3LDoWZpY28gbm9zIG11ZXN0cmEgcXVlIGVsIGRpc3RyaXRvIGNvbiBlbCBtZW5vciBwb3JjZW50YWplIGRlIHZvdG8gYSBGUCB0dXZvIHVuIHBvY28gbcOhcyBkZSA1JSB5IHF1ZSBlbCBtw6F4aW1vIGZ1ZSBkZSBjYXNpIDgwJS4KVGFtYmnDqW4gbXVlc3RyYSBxdWUgbGEgdm90YWNpw7NuIG1lZGlhbmEgZnVlIGRlIDQwJS4KTG9zIGzDrW1pdGVzIGRlIGxhIGNhamEgc29uIGVsIGN1YXJ0aWwgMjUgeSBlbCBjdWFydGlsIDc1LgoKYGBge3J9CmdncGxvdChyZXMyMDE2LCBhZXMoeT1mcCkpKwogIGdlb21fYm94cGxvdCgpKwogIHlsYWIoIiUgVm90byBGUCAyMDExIikKYGBgCgpFbCBhc3BlY3RvIG3DoXMgw7p0aWwgZGUgbG9zIGdyw6FmaWNvcyBkZSBjYWphcyBlcyBsYSBjb21wYXJhY2nDs24uClBvciBlamVtcGxvLCBzaSBzZSBxdWlzaWVyYSBjb21wYXJhciBlbCB2b3RvIGEgRnVlcnphIFBvcHVsYXIgZW50cmUgZGVwYXJ0YW1lbnRvcyBkZWwgcGHDrXMuClBhcmEgaGFjZXIgZXN0byBzZSBkZWJlIGRlZmluaXIgcXVlIGxhIHZhcmlhYmxlIGVuIGVsIGVqZSBZIHNlYSBlbCBwb3JjZW50YWplIGRlIHZvdG9zIGEgRnVlcnphIFBvcHVsYXIgImZwIiB5IGVuIGVsIGVqZSBYIGxhIHZhcmlhYmxlIHF1ZSBkZWZpbmUgbG9zIGRlcGFydGFtZW50b3MgImRwdG8iLgpJbmNsdWltb3MgbGEgZXNwZWNpZmljYWNpw7NuIGBjb29yZF9mbGlwKClgIHBhcmEgdm9sdGVhciBsb3MgZWplcyB5IHF1ZSBsYXMgZXRpcXVldGFzIGRlIGxvcyBkZXBhcnRhbWVudG9zIHNlIGxlYW4gbcOhcyBjbGFyYW1lbnRlLgoKRW4gZWwgZ3LDoWZpY28gc2UgcHVlZGVuIGhhY2VyIHZhcmlhcyBjb21wYXJhY2lvbmVzLgpMbyBtw6FzIGltcG9ydGFudGUgZXMgY29tcGFyYXIgbWVkaWFuYXMgeSBhbmNob3MgZGUgY2FqYXMgZW50cmUgZGVwYXJ0YW1lbnRvcy4KTG9zIHB1bnRvcyBhaXNsYWRvcyBzb24gIm91dGxpZXJzIiBvIHZhbG9yZXMgZXh0cmVtb3MsIHF1ZSBzZSBjYWxjdWxhbiBhdXRvbcOhdGljYW1lbnRlIHkgc2UgZ3JhZmljYW4uCgpFc3RlIGdyw6FmaWNvLCBzaW4gZW1iYXJnbywgZXMgbXV5IGRlc2FncmFnYWRvLgoKYGBge3J9CmdncGxvdChyZXMyMDE2LCBhZXMoeT1mcCwgeD1kcHRvKSkrCiAgZ2VvbV9ib3hwbG90KCkrCiAgc2NhbGVfeV9jb250aW51b3VzKGxpbWl0cyA9IGMoMCwgMTAwKSwgYnJlYWtzID0gc2VxKDAsIDEwMCwgMTApKSsKICB5bGFiKCIlIFZvdG8gRlAgMjAxMSIpKwogIHhsYWIoIkRlcGFydGFtZW50byIpKwogIHRoZW1lX21pbmltYWwoKSsKICBjb29yZF9mbGlwKCkKYGBgCgpTaSBzZSBxdWlzaWVyYSBjb21wYXJhciBlbnRyZSByZWdpb25lcyAoY29zdGEsIHNpZXJyZSB5IHNlbHZhKSwgc2UgdGVuZHLDrWEgcXVlIGNyZWFyIGVzdGEgdmFyaWFibGUsIGEgcGFydGlyIGRlIGxhIHZhcmlhYmxlICJkcHRvIi4KCiMjIFJlY29kaWZpY2FuZG8gdmFyaWFibGVzCgpgYGB7cn0KcmVzMjAxNiA9IHJlczIwMTYgfD4KICBtdXRhdGUocmVnaW9uID0gY2FzZV93aGVuKAogICAgZHB0bz09IkFNQVpPTkFTIn4iU2VsdmEiLAogICAgZHB0bz09IkFOQ0FTSCJ+IlNpZXJyYSIsCiAgICBkcHRvPT0iQVBVUklNQUMifiJTaWVycmEiLAogICAgZHB0bz09IkFSRVFVSVBBIn4iU2llcnJhIiwKICAgIGRwdG89PSJBWUFDVUNITyJ+IlNpZXJyYSIsCiAgICBkcHRvPT0iQ0FKQU1BUkNBIn4iU2llcnJhIiwKICAgIGRwdG89PSJDVVNDTyJ+IlNpZXJyYSIsCiAgICBkcHRvPT0iQ0FMTEFPIn4iQ29zdGEiLAogICAgZHB0bz09IkhVQU5DQVZFTElDQSJ+IlNpZXJyYSIsCiAgICBkcHRvPT0iSFVBTlVDTyJ+IlNlbHZhIiwKICAgIGRwdG89PSJJQ0EifiJDb3N0YSIsCiAgICBkcHRvPT0iSlVOSU4ifiJTaWVycmEiLAogICAgZHB0bz09IkxBIExJQkVSVEFEIn4iQ29zdGEiLAogICAgZHB0bz09IkxBTUJBWUVRVUUifiJDb3N0YSIsCiAgICBkcHRvPT0iTElNQSJ+IkNvc3RhIiwKICAgIGRwdG89PSJMT1JFVE8ifiJTZWx2YSIsCiAgICBkcHRvPT0iTUFEUkUgREUgRElPUyJ+IlNlbHZhIiwKICAgIGRwdG89PSJNT1FVRUdVQSJ+IkNvc3RhIiwKICAgIGRwdG89PSJQQVNDTyJ+IlNpZXJyYSIsCiAgICBkcHRvPT0iUElVUkEifiJDb3N0YSIsCiAgICBkcHRvPT0iUFVOTyJ+IlNpZXJyYSIsCiAgICBkcHRvPT0iU0FOIE1BUlRJTiJ+IlNlbHZhIiwKICAgIGRwdG89PSJUQUNOQSJ+IkNvc3RhIiwKICAgIGRwdG89PSJUVU1CRVMifiJDb3N0YSIsCiAgICBkcHRvPT0iVUNBWUFMSSJ+IlNlbHZhIgogICkpIApgYGAKCmBgYHtyfQpyZXMyMDE2IHw+CiAgY291bnQoUmVnaW9uID0gcmVnaW9uLCBuYW1lPSJGcmVjdWVuY2lhIikKYGBgCgpMYSB2YXJpYWJsZSBjcmVhZGEgZXMgdW5hIHZhcmlhYmxlIGRlIHRpcG8gImNhcmFjdGVyIi4KRW4gUiBleGlzdGUgb3RybyB0aXBvIGRlIHZhcmlhYmxlIGxsYW1hZG8gImZhY3RvciIuClBvZGVtb3MgY29udmVydGlyIGN1YWxxdWllciB2YXJpYWJsZSBhIHVuYSBkZSBmYWN0b3IgeSBldGlxdWV0YXIgY2FkYSB2YWxvci4KCmBgYHtyfQpsaWJyYXJ5KGZvcmNhdHMpCnJlczIwMTYgPSByZXMyMDE2IHw+CiAgbXV0YXRlKHJlZ2lvbjIgPSBmYWN0b3IocmVnaW9uKSkKYGBgCgpBaG9yYSwgcHJvY2VkZW1vcyBhIHByb2R1Y2lyIGVsIGdyw6FmaWNvIGRlIGNhamFzIGRlIHBvcmNlbnRhamUgZGUgdm90byBhIEZ1ZXJ6YSBQb3B1bGFyIHBvciByZWdpw7NuLgoKYGBge3J9CmdncGxvdChyZXMyMDE2LCBhZXMoeT1mcCwgeD1yZWdpb24pKSsKICBnZW9tX2JveHBsb3QoKSsKICBzY2FsZV95X2NvbnRpbnVvdXMobGltaXRzID0gYygwLCAxMDApLCBicmVha3MgPSBzZXEoMCwgMTAwLCAyMCkpKwogIHlsYWIoIiUgVm90byBGUCAyMDE2IikrCiAgeGxhYigiUmVnacOzbiIpKwogIHRoZW1lX2dldCgpCmBgYAoKU2Ugb2JzZXJ2YSBlbiBlc3RlIGdyw6FmaWNvIHF1ZSBlbCB2b3RvIG1lZGlhbm8gYSBGdWVyemEgUG9wdWxhciBmdWUgbWF5b3IgZW50cmUgcHJvdmluY2lhcyBkZSBsYSBjb3N0YSwgc2VndWlkbyBwb3IgbGEgc2VsdmEgeSBsdWVnbyBsYSBzaWVycmEuCkVzdGUgbWlzbW8gcGF0csOzbiBzZSBvYnNlcnZhIHNpIGNhbGN1bMOhcmFtb3MgbGEgbWVkaWEgZGVsIHBvcmNlbnRhamUgZGUgdm90byBwcm92aW5jaWFsIGEgRnVlcnphIFBvcHVsYXIgcG9yIHJlZ2nDs24uCgpgYGB7cn0KcmVzMjAxNiB8PiAKICBncm91cF9ieShyZWdpb24yKSB8PgogIHN1bW1hcmlzZShtZWFuKGZwKSwgc2QoZnApKQpgYGAKCiMjIERlc2NyaXBjacOzbiBkZSB2YXJpYWJsZXMgZGUgZmFjdG9yCgpQYXJhIGRlc2NyaWJpciB2YXJpYWJsZXMgcXVlIG5vIHNvbiBudW3DqXJpY2FzLCBwb2RlbW9zIHByb2R1Y2lyIHRhYmxhcyBkZSBkaXN0cmlidWNpw7NuIGRlIGZyZWN1ZW5jaWFzLgpQb3IgZWplbXBsbywgbGEgYmFzZSBkZSBkYXRvcyBpbmNsdXllIHVuYSB2YXJpYWJsZSBkZSBxdcOpIHBhcnRpZG8gZ2Fuw7MgbGEgbWF5b3LDrWEgZGUgdm90b3MgZW4gdW5hIHByb3ZpbmNpYS4KTGEgdmFyaWFibGUgImdhbmEiIGRlIGxhIGJhc2UgZGUgZGF0b3MgcmVjb2dlIGVzdGUgZGF0by4KUG9kZW1vcyB1c2FyIGVsIGNvbWFuZG8gYGNvdW50YCBwYXJhIGNhbGN1bGFyIGxhIHRhYmxhIGRlIGRpc3RyaWJ1Y2nDs24gZGUgZnJlY3VlbmNpYXMgZGUgZXN0YSB2YXJpYWJsZS4KU2UgZ3VhcmRhIGVzdGEgdGFibGEgZW4gdW4gb2JqZXRvICJ0YWJsYSIuCgpTZSBlbmN1ZW50cmEgcXVlIGRlbCB0b3RhbCBkZSBwcm92aW5jaWFzLCBGdWVyemEgUG9wdWxhciBnYW7DsyBlbiBsYSBtYXlvcsOtYSBkZSBlbGxhcy4KCmBgYHtyfQp0YWJsYSA9IHJlczIwMTYgfD4KICBjb3VudChHYW5hZG9yID0gZ2FuYSwgbmFtZT0iRnJlY3VlbmNpYSIpCnRhYmxhCmBgYAoKUGFyYSBjYWxjdWxhciBsb3MgcG9yY2VudGFqZXMsIHNlIHB1ZWRlIGFncmVnYXIgYSBsYSB0YWJsYSB1bmEgY29sdW1uYSAiUG9yY2VudGFqZSIgY29uIGVsIGPDoWxjdWxvIGRlIGxhICJGcmVjdWVuY2lhIiAoY29sdW1uYSBleGlzdGVudGUpIGVudGUgbGEgc3VtYSB0b3RhbCBkZSBsYXMgZnJlY3VlbmNpYXMuClNlIGVuY3VlbnRyYSBxdWUgRnVlcnphIFBvcHVsYXIgZ2Fuw7MgZW4gZWwgNTclIGRlIHByb3ZpbmNpYXMgZGVsIFBlcsO6LgoKYGBge3J9CnRhYmxhID0gdGFibGEgfD4KICBtdXRhdGUoUG9yY2VudGFqZSA9IChGcmVjdWVuY2lhIC8gc3VtKEZyZWN1ZW5jaWEpKjEwMCApKQp0YWJsYQpgYGAKClBhcmEgZ3JhZmljYXIgdW5hIHZhcmlhYmxlIGRlIHRpcG8gY3VhbGl0YXRpdmEgKG8gZGUgZmFjdG9yIGVuIGVsIGxlbmd1YWplIGRlIFIpLCBzZSBkZWJlIHVzYXIsIHBvciBlamVtcGxvLCB1biBncsOhZmljbyBkZSBiYXJyYXMuClBvZGVtb3MgZ3JhZmljYXIgZWwgcG9yY2VudGFqZSBkZSBwcm92aW5jaWFzIHF1ZSBjYWRhIHBhcnRpZG8gZ2Fuw7MgZW4gMjAyMS4KClBhcmEgZXN0byBzZWd1aW1vcyB1c2FuZG8gbGEgbGlicmVyw61hIGBnZ3Bsb3RgLCBwZXJvIGFob3JhIG5vIHJlYWxpemFyZW1vcyB1biBoaXN0b2dyYW1hIChubyB1c2FyZW1vcyBgZ2VvbV9oaXN0b2dyYW1gKSwgc2lubyBiYXJyYXMsIGNvbiBgZ2VvbV9iYXJgLgpEZW50cm8gZGUgZXN0ZSBjb21hbmRvIHNlIGHDsWFkZSBgc3RhdD0iaWRlbnRpdHlgIHBhcmEgaW5kaWNhciBxdWUgUiBubyBjYWxjdWxlIG5hZGEgeSBzb2xvIHVzZSBsb3MgZGF0b3MgZGUgInRhYmxhIi4KCmBgYHtyfQpnZ3Bsb3QodGFibGEsIGFlcyh4PVBvcmNlbnRhamUseT1HYW5hZG9yKSkrCiAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiLCB3aWR0aD0wLjUpCmBgYAoKIyBDYXNvIDM6IENvbWlzYXJpYXMgZW4gZWwgUGVyw7oKCiMjIE1lZGlkYXMgZGUgdGVuZGVuY2lhIGNlbnRyYWwKCi0gICBSZXN1bWVuIGRlIHVuIGNvbmp1bnRvIGRlIGRhdG9zLgoKLSAgIFNlIHJlc3VtZSBtZWRpYW50ZSB1biB2YWxvciAicmVwcmVzZW50YXRpdm8iLgoKLSAgIENhZGEgb2JzZXJ2YWNpw7NuIHNlIHB1ZWRlIGNvbXBhcmFyIGNvbiBlc3RlIHZhbG9yIGRlIHJlc3VtZW4uCiAgICBTZSBwdWVkZSBlc3RhciBwb3IgZGViYWpvIG8gcG9yIGVuY2ltYSBkZSBlc3RlIHZhbG9yLgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBNb2RhCgotICAgVmFsb3IgbWFzIGZyZWN1ZW50ZSBkZSB1biBjb25qdW50byBkZSBkYXRvcwoKLSAgIEVzIGFwcm9waWFkYSBwYXJhIHRvZG8gdGlwbyBkZSBkYXRvcwoKLSAgIFNlIHB1ZWRlIG9ic2VydmFyIGRpcmVjdGFtZW50ZSBlbiB1bmEgdGFibGEgZGUgZGlzdHJpYnVjacOzbiBkZSBmcmVjdWVuY2lhcy4KClBvciBlamVtcGxvIHNpIHNlIG1pZGUgZW4gY2FkYSBjb21pc2FyaWEgZGVsIFBlcsO6LCBhIGN1w6FudGEgcG9ibGFjacOzbiBhdGllbmRlIGNhZGEgY29taXNhcmlhIGRlIGFjdWVyZG8gYSBsYSBjb2RpZmljYWNpw7NuLgoKIVtdKGNvbWkxN19wb2IucG5nKXt3aWR0aD0iNzM0In0KCkxhIGJhc2UgZGUgZGF0b3MgbyAiZGF0YWZyYW1lIiBzZSB2ZXLDrWEgYXPDrQoKIVtdKGNvbWkxN19wb2IyLnBuZykKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKUGFyYSBlc3RhIGNsYXNlIHNlIHVzYXLDoSBsYSBiYXNlIGRlIGRhdG9zIGRlIGNvbWlzYXJpYXMgZGVsIFBlcsO6LCBxdWUgcHVlZGUgc2VyIGRlc2NhcmdhZGEgZGUgbGEgc2VjY2nDs24gbWljcm9kYXRvcyBkZSBsYSB3ZWIgZGVsIElORUkgKHZlciBbYXF1w61dKGh0dHBzOi8vcHJveWVjdG9zLmluZWkuZ29iLnBlL21pY3JvZGF0b3MvKSkuCkVzdGEgYmFzZSB0aWVuZSBpbmZvcm1hY2nDs24gcGFyYSAxNDk1IGNvbWlzYXJpYXMgeSBkZSAyODEgdmFyaWFibGVzLgpFc3RhIGJhc2Ugc2UgcHVlZGUgY2FyZ2FyIHRhbWJpw6luIGRlc2RlIGVsIHJlcG9zaXRvcmlvIEdpdGh1YiBkZSBlc3RlIGN1cnNvLgpMYSBiYXNlIGRlIGRhdG9zIHB1ZWRlIHNlciBndWFyZGFkYSBlbiBlbCBkaXJlY3RvcmlvIGRlIHRyYWJham8uCgpFbiBwcmltZXIgbHVnYXIsIHNlIGxsYW1hIGEgbGEgbGlicmVyw61hICJyaW8iIHkgc2UgdXNhIGVsIGNvbWFuZG8gYGltcG9ydGAgcXVlIHBlcm1pdGUgbGVlciBiYXNlcyBkZSBkYXRvcyBlbiBtdWNob3MgZm9ybWF0b3MuCgpgYGB7ciBiYXNlfQpsaWJyYXJ5KHJpbykgCmNvbWkxNyA9IGltcG9ydCgiYmFzZXMvY29taTIwMTcuc2F2IikKYGBgCgpgYGB7cn0Kc3RyKGNvbWkxNyRJTkYxMDkpCmNsYXNzKGNvbWkxNyRJTkYxMDkpCmBgYAoKYGBge3J9CmxpYnJhcnkodGlkeXZlcnNlKQpsaWJyYXJ5KGRwbHlyKQpjb21pMTcgPSBjb21pMTcgfD4KICBtdXRhdGUodGlwbyA9IGZhY3RvcihJTkYxMDksIGxhYmVscz1jKCJNZW5vcyBkZSA1MDAwIEhhYiIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkRlIDUwMDAgLSAxMDAwMCBIYWIiLCAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJEZSAxMDAwMSAtIDIwMDAwIEhhYiIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkRlIDIwMDAxIC0gNDAwMDAgSGFiIiwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICJEZSA0MDAwMSBhIDgwMDAwIiwgIkRlIDgwMDAxIGEgbcOhcyIpKSkKYGBgCgpFc3RhIGJhc2UgZGUgZGF0b3MgaW5jbHV5ZSBhIGxhIHZhcmlhYmxlICJJTkYxMDkiIChvam86IFIgZXMgImNhc2Ugc2Vuc2l0aXZlIiwgZXMgZGVjaXIsIGRpZmVyZW5jaWEgbWF5w7pzY3VsYXMgZGUgbWluw7pzY3VsYXMpLgpMYSB0YWJsYSBkZSBkaXN0cmlidWNpw7NuIGRlIGZyZWN1ZW5jaWFzIGRlIGVzYSB2YXJpYWJsZSBzZSBwdWVkZSBvYnRlbmVyIGNvbiBlbCBzaWd1aWVudGUgY8OzZGlnbzoKCmBgYHtyIHRhYmxhfQp0YWJsYTEgPSBjb21pMTcgfD4KICBjb3VudChUaXBvID0gdGlwbywgbmFtZT0iRnJlY3VlbmNpYSIpCnRhYmxhMQpgYGAKCkVuIGVzdGUgY2FzbywgbGEgbW9kYSBlcyBlbCB2YWxvciBtw6FzIGZyZWN1ZW50ZSwgcXVlIHNlcsOtYSBlbCBjw7NkaWdvICIyIiwgcXVlIHNpZ25pZmljYSAiRGUgNSwwMDAgYSAxMCwwMDAgaGFiIi4KCmBgYHtyfQp0YWJsYTEgPSBjb21pMTcgfD4KICBjb3VudChUaXBvID0gdGlwbywgbmFtZT0iRnJlY3VlbmNpYSIpIHw+CiAgbXV0YXRlKFBvcmMgPSAoRnJlY3VlbmNpYSAvIHN1bShGcmVjdWVuY2lhKSoxMDAgKSkKdGFibGExCmBgYAoKYGBge3J9CmxpYnJhcnkoZ2dwbG90MikKZ2dwbG90KHRhYmxhMSwgYWVzKHg9VGlwbywgeT1Qb3JjKSkgKyAKICBnZW9tX2JhcihzdGF0ID0gImlkZW50aXR5IikgKwogIHhsYWIoIlBvYmxhY2nDs24gYSBsYSBxdWUgYXRpZW5kZSBsYSBjb21pc2FyaWEiKSArCiAgeWxhYigiUG9yY2VudGFqZSIpICsKICBnZW9tX3RleHQoYWVzKGxhYmVsPXJvdW5kKFBvcmMsMSkpLCB2anVzdD0xLjMwLCBjb2xvcj0id2hpdGUiLCBzaXplPTMpKwogIHRoZW1lX21pbmltYWwoKQpgYGAKCiMjIE1lZGlhbmEKCi0gICBFbCB2YWxvciBkZSBsYSBvYnNlcnZhY2nDs24gY2VudHJhbCBkZSB1biBjb25qdW50byBkZSBkYXRvcyBvcmRlbmFkb3MgZGUgbWVub3IgYSBtYXlvci4KCiFbXShtZWRpYW5hMS5wbmcpe3dpZHRoPSI0OTcifQoKIVtdKG1lZGlhbmEyLnBuZyl7d2lkdGg9IjQ5OCJ9CgpQYXJhIGNhbGN1bGFyIGxhIG1lZGlhbmEgZGUgbGEgdmFyaWFibGUgIklORjEwOSIgc2UgcHVlZGUgdXNhciBlbCBjb21hbmRvIGBtZWRpYW5gLgpFc3RlIGNvbWFuZG8gaW50ZXJuYW1lbnRlIG9yZGVuYSBsb3MgdmFsb3JlcyBkZSBsYSB2YXJpYWJsZSAiSU5GMTA5IiBkZSBtZW5vciBhIG1heW9yIHkgZW5jdWVudHJhIGVsIGPDs2RpZ28gbnVtw6lyaWNvIGRlIGxhIG9ic2VydmFjacOzbiBxdWUgc2UgZW5jdWVudHJhIGVuIG1lZGlvIGRlIGxhIGRpc3RyaWJ1Y2nDs24gb3JkZW5hZGEuCgpgYGB7cn0KY29taTE3IHw+CiAgc3VtbWFyaXNlKG1lZGlhbihJTkYxMDkpKQpgYGAKCkxhIG1lZGlhbmEgZXMgZWwgY8OzZGlnbyBudW3DqXJpY28gMywgcXVlIHNpZ25pZmljYSAiRGUgMTAsMDAxIGEgMjAsMDAwIGhhYi4iLgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBNZWRpYQoKLSAgIE1lZGlkYSBtw6FzIGNvbm9jaWRhIHkgIsO6dGlsIi4KCi0gICBTdW1hIGRlbCB2YWxvciBkZSBsYXMgb2JzZXJ2YWNpb25lcyBkaXZpZGlkYSBlbnRyZSBlbCBuw7ptZXJvIGRlIG9ic2VydmFjaW9uZXMKCiQkClxzdW0gXGZyYWN7eF9pfSB7bn0gPSBcZnJhY3soeF8xICsgeF8yICt4XzMgKy4uLisgeF9uKX0ge259CiQkCgpFbiB1bmEgYmFzZSBkZSBkYXRvcywgc2UgcHVlZGUgY2FsY3VsYXIgbGEgbWVkaWEgc3VtYW5kbyBsb3MgdmFsb3JlcyBkZSB1bmEgdmFyaWFibGUgKGNvbHVtbmEgZGUgdW5hIGJhc2UgZGUgZGF0b3MpIHkgZGl2aWRpZW5kbyBlbnRyZSBlbCBuw7ptZXJvIGRlIGNhc29zIChcIyB0b3RhbCBkZSBmaWxhcykuCgohW10oY29taTE3X21lZGlhLnBuZyl7d2lkdGg9IjI1OCJ9CgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMjIFJlc3VtZW4KCnwgVEMgICAgICB8IE5vbWluYWxlcyB8IE9yZGluYWxlcyB8IE51bcOpcmljYXMgfAp8LS0tLS0tLS0tfDotLS0tLS0tLS06fDotLS0tLS0tLS06fDotLS0tLS0tLS06fAp8IE1vZGEgICAgfCAgICBTw60gICAgIHwgICAgU8OtICAgICB8ICAgIFPDrSAgICAgfAp8IE1lZGlhbmEgfCAgICBObyAgICAgfCAgICBTw60gICAgIHwgICAgU8OtICAgICB8CnwgTWVkaWEgICB8ICAgIE5vICAgICB8ICAgIE5vICAgICB8ICAgIFPDrSAgICAgfAoKLSAgIE1vZGEgYXBsaWNhIHBhcmEgY3VhbHF1aWVyIHRpcG8gZGUgdmFyaWFibGUsIHBlcm8gbWVub3Mgw7p0aWwuCgotICAgTWVkaWEgYXBsaWNhIHNvbG8gcGFyYSB2YXJpYWJsZXMgbnVtw6lyaWNhcywgcGVybyBtw6FzIMO6dGlsLgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgrCv0N1w6FsIGVzIGxhIG1lZGlhIChvIGVsIHByb21lZGlvKSBkZSBwb2xpY8OtYXMgcG9yIGNvbWlzYXJpYSBkZSBhY3VlcmRvIGEgZXN0b3MgZGF0b3M/CgpgYGB7ciBtZWRpYX0KY29taTE3IHw+CiAgc3VtbWFyaXNlKG1lYW4oSU5GMTEwX1RPVCkpCmBgYAoKwr9FcyB1bmEgcmVwcmVzZW50YWNpw7NuIGFkZWN1YWRhIGRlIGxhIHJlYWxpZGFkPwpQb2RlbW9zIGZpamFybm9zIGVuIGVsIGdyw6FmaWNvIGRlIGRpc3RyaWJ1Y2nDs24gZGUgZXN0YSB2YXJpYWJsZSBwYXJhIHZlciBzaSBzZSB0aWVuZSBjb21pc2FyaWFzIHF1ZSBzb24gImF0w61waWNhcyIgZGUgbGEgZGlzdHJpYnVjacOzbiBnZW5lcmFsLgoKRXN0byBzZSBwdWVkZSBoYWNlciBwcmVzZW50YW5kbyBlbCBoaXN0b2dyYW1hIGRlIGVzdGEgdmFyaWFibGUsIHF1ZSBlcyBjb21vIHVuIGdyw6FmaWNvIGRlIGJhcnJhcyBkZSB1bmEgdmFyaWFibGUgbnVtw6lyaWNhLgoKYGBge3IgaGlzdH0KbGlicmFyeShnZ3Bsb3QyKQpnZ3Bsb3QoY29taTE3LCBhZXMoeD1JTkYxMTBfVE9UKSkrCiAgZ2VvbV9oaXN0b2dyYW0oKSsKICB4bGFiKCJOw7ptZXJvIGRlIGVmZWN0aXZvcyIpICsKICB5bGFiKCJGcmVjdWVuY2lhIikrCiAgdGhlbWVfbGlnaHQoKQpgYGAKCsK/UXXDqSBzZSBwdWVkZSBjb25jbHVpciBkZWwgZ3LDoWZpY28/CgpgYGB7ciBtZWRpYW5hfQpjb21pMTcgfD4KICBzdW1tYXJpc2UobWVkaWFuKElORjExMF9UT1QpKQpgYGAKCsK/UXXDqSBzaWduaWZpY2EgZXN0YSBkaWZlcmVuY2lhIGVudHJlIGxhIG1lZGlhIGRlIDMxLjYgeSBsYSBtZWRpYW5hIGRlIDE5PwoKYGBge3IgcmVzdW1lbn0KY29taTE3IHw+CiAgc3VtbWFyaXNlKG1pbihJTkYxMTBfVE9UKSwgbWVkaWFuKElORjExMF9UT1QpLCAKICAgICAgICAgICAgbWVhbihJTkYxMTBfVE9UKSwgbWF4KElORjExMF9UT1QpKQpgYGAKCmBgYHtyfQpnZ3Bsb3QoY29taTE3LCBhZXMoeD1JTkYxMTBfVE9UKSkrCiAgZ2VvbV9oaXN0b2dyYW0oKSsKICBnZW9tX3ZsaW5lKHhpbnRlcmNlcHQgPSAxOSwgY29sb3IgPSAicmVkIikrCiAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gMzEuNiwgY29sb3IgPSAiZ3JlZW4iKSsKICB4bGFiKCJOw7ptZXJvIGRlIGVmZWN0aXZvcyIpICsKICB5bGFiKCJGcmVjdWVuY2lhIikrCiAgdGhlbWVfbGlnaHQoKQpgYGAKCsK/UXXDqSBzZSBwdWVkZSBjb21lbnRhciBkZSBlc3RvcyBkYXRvcz8KCiMjIE1lZGlkYXMgZGUgZGlzcGVyc2nDs24KCi0gICBEZXNjcmliaXIgbGEgY2VudHJhbGlkYWQgbm8gZXMgc3VmaWNpZW50ZS4KICAgIERvcyBkaXN0cmlidWNpb25lcyBwdWVkZW4gdGVuZXIgbGEgbWlzbWEgbWVkaWRhIGRlIHRlbmRlbmNpYSBjZW50cmFsLCBwZXJvIGRpZmVyZW50ZXMgcmVhbGlkYWRlcy4KCi0gICBFamVtcGxvOiBkaXN0cmlidWNpw7NuIGRlIHB1bnRhamUgZW4gw6FyZWEgbWF0ZW3DoXRpY2EgZGUgcHJ1ZWJhIFBJU0EgYXBsaWNhZGEgZW4gMiBwYcOtc2VzIHB1ZWRlbiB0ZW5lciBsYSBtaXNtYSBtZWRpYSwgcGVybyBkaWZlcmVudGUgdmFyaWFjacOzbi4KCi0gICDCv0PDs21vIGRlc2NyaWJpcsOtYSBsYXMgZGlmZXJlbmNpYXMgZW50cmUgZW4gbG9zIHB1bnRhamVzIGRlIGxhIHBydWViYSBlbCBQYcOtcyBBIHkgZWwgUGHDrXMgQj8KCiFbXShkaXN0ci5wbmcpe3dpZHRoPSI2MzEifQoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBSYW5nbwoKLSAgIERpZmVyZW5jaWEgZW50cmUgZWwgdmFsb3IgbcOheGltbyB5IGVsIG3DrW5pbW8uCiAgICBFbiBlamVtcGxvIGRlIHBvbGljw61hczogMjU5LTMgPSAyNTYuCiAgICBFcyBsYSBkaWZlcmVuY2lhIGVudHJlIGxhIGNvbWlzYXLDrWEgY29uIG3DoXMgZWZlY3Rpdm9zIHkgbGEgY29taXNhcsOtYSBjb24gbWVub3IgbsO6bWVybyBkZSBlZmVjdGl2b3MuCgotICAgTm8gdW4gdW5hIG1lZGlkYSBtdXkgw7p0aWwuCgotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KCiMjIFJhbmdvIGludGVyY3VhcnRpbAoKLSAgIFNlIHZlcsOhIGN1YW5kbyBzZSB2ZWFuIHBlcmNlbnRpbGVzLgoKLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCgojIyBEZXN2aWFjacOzbiBlc3TDoW5kYXIKCi0gICBDYWRhIG9ic2VydmFjacOzbiBlc3TDoSBhIHVuYSAiZGlzdGFuY2lhIiBkZSBsYSBtZWRpYS4KICAgIEVzdGEgZGlzdGFuY2lhIHNlIGxsYW1hIGRlc3ZpYWNpw7NuICQoeF9pLVxiYXJ7eH0pJAoKLSAgIE9ic2VydmFjaW9uZXMgcG9yIGVuY2ltYSBkZSBsYSBtZWRpYSB0ZW5kcsOhbiBkZXN2aWFjaW9uZXMgcG9zaXRpdmFzLgogICAgT2JzZXJ2YWNpb25lcyBwb3IgZGViYWpvIGRlIGxhIG1lZGlhIHRlbmRyw6FuIGRlc3ZpYWNpb25lcyBuZWdhdGl2YXMuCgotICAgTm8gc2UgcHVlZGUgY2FsY3VsYXIgdW4gcHJvbWVkaW8gZGUgZGVzdmlhY2lvbmVzIHBvcnF1ZSB2YWxvcmVzIHBvc2l0aXZvcyBzZSBjYW5jZWxhbiBjb24gbmVnYXRpdm9zLgoKLSAgIFNlIGVsZXZhIGFsIGN1YWRyYWRvIGxhcyBvYnNlcnZhY2lvbmVzIHBhcmEgcXVlIHRvZGFzIHNlYW4gcG9zaXRpdmFzLgogICAgU2UgcHJvbWVkaWFuIGVzYXMgZGVzdmlhY2lvbmVzIGFsIGN1YWRyYWRvLgoKLSAgIExhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBlcyBsYSByYcOteiBjdWFkcmFkYSBkZSBlc2UgcHJvbWVkaW8gZGUgZGVzdmlhY2lvbmVzIGFsIGN1YWRyYWRvLgoKLSAgIFNlIGRpdmlkZSBlbnRyZSBuLTEgcG9yIHVuIHRlbWEgdMOpY25pY28uCgokJApcc3VtIFxmcmFjeyh4X2ktXGJhcnt4fSleMn0ge24tMX0gCiQkCgpQYXJhIHZlciB1biBjw6FsY3VsbyBiw6FzaWNvIGRlIGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBlbiBFeGNlbCwgcHVlZGUgZW50cmFyIFthcXXDrV0oaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMUNDek90ZlhmN0lnel9LY2JjcEl0elU3MWZXZU10VGxpP3J0cG9mPXRydWUmYXV0aHVzZXI9YXJ0dXJvLm1hbGRvbmFkbyU0MHB1Y3AucGUmdXNwPWRyaXZlX2ZzKS4KCi0gICBDb21vIHNlIG9ic2VydmEgZW4gZWwgZ3LDoWZpY28gYW50ZXJpb3IsIGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBlcyBtw6FzIMO6dGlsIGN1YW5kbyBzZSBjb21wYXJhciBkb3MgZGlzdHJpYnVjaW9uZXMuIFNlIGNvbXBhcmEgbGEgY2VudHJhbGlkYWQgeSBsYSBkaXNwZXJzacOzbiBkZSB1bmEgdmFyaWFibGUgZW50cmUgZG9zIGdydXBvcyAobyBkb3MgZGlzdHJpYnVjaW9uZXMpLgoKYGBge3J9CmNvbWkxNyB8PgogIHN1bW1hcmlzZShzZChJTkYxMTBfVE9UKSkKYGBgCgpTaWd1aWVuZG8gY29uIGxhIGJhc2UgZGUgZGF0b3MgZGUgY29taXNhcsOtYXMgZGVsIFBlcsO6LCBxdWVyZW1vcyBldmFsdWFyIHNpIGVsIG7Dum1lcm8gZGUgcG9saWPDrWFzIChJTkYxMTBfVE9UKSBhdW1lbnRhIGEgbWVkaWRhIHF1ZSBsYSBjb21pc2Fyw61hIGF0aWVuZGEgYSB1bmEgcG9ibGFjacOzbiBtYXlvciAoSU5GMTA5KS4KCkNvbW8gc2UgdmlvIGFudGVzLCBsYSB2YXJpYWJsZSBkZSBwb2JsYWNpw7NuIGEgbGEgcXVlIGF0aWVuZGUgZXN0w6EgY29kaWZpY2FkYSBlbiA2IGdydXBvcywgZGVzZGUgMSBxdWUgc2lnbmlmaWNhICJNZW5vcyBkZSA1MDAwIGhhYiIgYSA2IHF1ZSBzaWduaWZpY2EgIkRlIDgwMDAwIGEgbcOhcyBoYWIiLgoKYGBge3IgdGFibGFwb2J9CnRhYmxhMQpgYGAKCkxvIHF1ZSBzZSBxdWllcmUgY2FsY3VsYXIgZXMgZWwgcHJvbWVkaW8geSBsYSBkZXN2aWFjacOzbiBlc3TDoW5kYXIgZGUgcG9saWPDrWFzIHBvciBjYWRhIGdydXBvIGRlIHBvYmxhY2nDs24gYSBsYSBxdWUgYXRpZW5kZS4KRXN0YSBvcGVyYWNpw7NuIHNlIHB1ZWRlIGhhY2VyIGRlIG3Dumx0aXBsZXMgbWFuZXJhcyBlbiBSLgoKYGBge3IgbWVkaWFncnVwb3N9CmNvbWkxNyB8PgogIGdyb3VwX2J5KHRpcG8pIHw+CiAgc3VtbWFyaXNlKG1lYW4oSU5GMTEwX1RPVCkpCmBgYAoKRWZlY3RpdmFtZW50ZSwgY29tbyBzZSBlc3BlcmFiYSwgZWwgbsO6bWVybyBwcm9tZWRpbyBkZSBwb2xpY8OtYXMgYXVtZW50YSBhIG1lZGlkYSBxdWUgbGEgY29taXNhcsOtYSBhdGllbmRlIGEgdW5hIHBvYmxhY2nDs24gbWF5b3IuCgpUYW1iacOpbiBzZSBwdWVkZSBjb21wYXJhciBsYSBkZXN2aWFjacOzbiBlc3TDoW5kYXIgZW4gY2FkYSBncnVwby4KRWwgY29tYW5kbyBwYXJhIGVsIGPDoWxjdWxvIGRlIGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciBlcyBgc2RgLgoKYGBge3IgZGVzdmdydXBvc30KbWVkaWF4dGlwbyA9IGNvbWkxNyB8PgogIGdyb3VwX2J5KFRpcG8gPSB0aXBvKSB8PgogIHN1bW1hcmlzZShNZWRpYSA9IG1lYW4oSU5GMTEwX1RPVCksIERlc3YgPSBzZChJTkYxMTBfVE9UKSkKbWVkaWF4dGlwbwpgYGAKCkxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhciB0YW1iacOpbiBhdW1lbnRhIGEgbWVkaWRhIHF1ZSBsYXMgY29taXNhcsOtYXMgYXRpZW5kZW4gYSB1bmEgcG9ibGFjacOzbiBtYXlvci4KRXMgZGVjaXIsIGxhcyBjb21pc2Fyw61hcyBxdWUgYXRpZW5kZW4gYSB1bmEgcG9ibGFjacOzbiBwZXF1ZcOxYSBzb24gbcOhcyBob21vZ8OpbmVhcyBxdWUgbGFzIHF1ZSBhdGllbmRlbiBhIHVuYSBwb2JsYWNpw7NuIG1heW9yLCBkb25kZSBoYXkgbWF5b3JlcyBkaWZlcmVuY2lhcyBlbiBlbCBuw7ptZXJvIGRlIGVmZWN0aXZvcyBlbnRyZSBjb21pc2Fyw61hcy4KCsK/QSBxdcOpIHB1ZWRlIGRlYmVyc2UgZXN0ZSByZXN1bHRhZG8/ClVuYSBwb3NpYmxlIGV4cGxpY2FjacOzbiBlcyBsYSBjb21wbGVqaWRhZCBkZSBjaXVkYWRlcyBtw6FzIGdyYW5kZXMsIHBvciBsbyBxdWUgcG9kcsOtYSByZXF1ZXJpciBjb21pc2FyaWFzIGVzcGVjaWFsaXphZGFzLCBhZGVtw6FzIGRlIGxhcyBjb21pc2FyaWFzIGVzdMOhbmRhci4KUG9yIGVsIGNvbnRyYXJpbywgY2VudHJvcyB1cmJhbm9zIG3DoXMgcGVxdWXDsW9zIHNvbG8gcmVxdWVyaXLDrWFuIGNvbWlzYXLDrWFzIHBlcXVlw7Fhcy4KCkVuIFIgaGF5IGRpZmVyZW50ZXMgbWFuZXJhcyBkZSBoYWNlciBsbyBtaXNtby4KUGFyYSBsb3MgZ3LDoWZpY29zIGV4aXN0ZSB1bmEgbGlicmVyw61hIGVzcGVjaWFsaXphZGEgbGxhbWFkYSBgZ2dwbG90MmAuCkNvbiBlc2EgbGlicmVyw61hIHNlIHRpZW5lIG3DoXMgb3BjaW9uZXMgZ3LDoWZpY2FzIHF1ZSBjb24gbG9zIGNvbWFuZG9zIGRlIGJhc2UuClRhbWJpw6luIGV4aXN0ZSB1bmEgZm9ybWEgZGUgY29kaWZpY2FjacOzbiBsbGFtYWRvIGB0aWR5dmVyc2VgIHF1ZSB1c2EgZWwgb3BlcmFkb3IgYCU+JWAuCkFxdcOtIHNlIHByZXNlbnRhIHVuIGVqZW1wbG8gcXVlIHByb2R1Y2UgZWwgaGlzdG9ncmFtYSBkZWwgbsO6bWVybyBkZSBwb2xpY8OtYXMgcG9yIGNhZGEgZ3J1cG8gZGUgdGFtYcOxbyBkZSBwb2JsYWNpw7NuLgoKYGBge3IgaGlzdGdydXBvc30KbGlicmFyeShnZ3Bsb3QyKQpsaWJyYXJ5KGRwbHlyKQpjb21pMTcgfD4KICBnZ3Bsb3QoYWVzKHg9SU5GMTEwX1RPVCkpKwogIGdlb21faGlzdG9ncmFtKCkrCiAgZmFjZXRfd3JhcCh+dGlwbykrCiAgeGxhYigiTsO6bWVybyBkZSBwb2xpY8OtYXMiKSsKICB5bGFiKCJGcmVjdWVuY2lhIikKYGBgCgrCv1F1w6kgb3RyYXMgcHJlZ3VudGFzIHNlIHB1ZWRlbiByZXNwb25kZXIgY29uIGxvcyBkYXRvcyBkZSBjb21pc2Fyw61hcz8KCmBgYHtyfQpnZ3Bsb3QobWVkaWF4dGlwbywgYWVzKHg9VGlwbywgeT1NZWRpYSkpICsgCiAgZ2VvbV9iYXIoc3RhdCA9ICJpZGVudGl0eSIpICsKICBnZ3RpdGxlKCJOw7ptZXJvIGRlIGVmZWN0aXZvcyBwcm9tZWRpbyBwb3IgdGlwbyBkZSBjb21pc2Fyw61hIikgKwogIHhsYWIoIlRpcG8gZGUgY29taXNhcsOtYSIpICsKICBnZW9tX3RleHQoYWVzKGxhYmVsPXJvdW5kKE1lZGlhLDEpKSwgdmp1c3Q9MS4zMCwgY29sb3I9IndoaXRlIiwgc2l6ZT0zKSsKICB0aGVtZV9taW5pbWFsKCkKYGBgCgpPdHJhIGZvcm1hIGRlIGRlc2NyaWJpciBkZXNjcmlwdGl2YW1lbnRlIGVzdGEgdmFyaWFibGUgbWVkaWFudGUgdW4gZ3LDoWZpY28gZXMgbWVkaWFudGUgZWwgZ3LDoWZpY28gZGUgY2FqYXMgbyAiYm94cGxvdCIuCkVzdGUgZ3LDoWZpY28gbXVlc3RyYSBlbCBtw61uaW1vLCBsb3MgY3VhcnRpbGVzIHkgZWwgbcOheGltby4KTG9zIGN1YXJ0aWxlcyBkaXZpZGVuIGVsIG7Dum1lcm8gZGUgb2JzZXJ2YWNpb25lcyBlbiBjdWF0cm8gZ3J1cG9zIGRlIGlndWFsIHRhbWHDsW8sIGF1bnF1ZSBzdXMgbMOtbWl0ZXMgZGlmaWVyZW4uCkVsIHNlZ3VuZG8gY3VhcnRpbCBlcyBsYSBtZWRpYW5hLgoKYGBge3J9CmdncGxvdChjb21pMTcsIGFlcyh5PUlORjExMF9UT1QsIHg9dGlwbykpKwogIGdlb21fYm94cGxvdCgpKwogIHNjYWxlX3lfY29udGludW91cyhsaW1pdHMgPSBjKDAsIDMwMCksIGJyZWFrcyA9IHNlcSgwLCAzMDAsIDUwKSkrCiAgeWxhYigiTsO6bWVybyBkZSBlZmVjdGl2b3MiKSsKICB4bGFiKCJUaXBvIGRlIGNvbWlzYXLDrWEiKSsKICB0aGVtZV9nZXQoKQpgYGAKCi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQoKU2UgcHVlZGVuIGNhbGN1bGFyIGxvcyBjdWFydGlsZXMgcGFyYSB0b2RhIGxhIGRpc3RyaWJ1Y2nDs24gY29uIGVsIGNvbWFuZG8gYHF1YW50aWxlYC4KRXN0b3MgZGF0b3MgbXVlc3RyYW4gcXVlIGVudHJlIGVsIDI1JSBkZSB0b2RhcyBsYXMgY29taXNhcsOtYXMgdGllbmVuIGVudHJlIDMgeSAxMSBlZmVjdGl2b3MuCkVsIHNlZ3VuZG8gMjUlIGRlIGNvbWlzYXLDrWFzIHRpZW5lIGVudHJlIDExIHkgMTkgZWZlY3Rpdm9zLgpFbCB0ZXJjZXIgMjUlIHRpZW5lIGVudHJlIDE5IDcgMzcgZWZlY3Rpdm9zLCB5IGVsIMO6bHRpbW8gMjUlIHRpZW5lIGVudHJlIDM3IHkgMjU5IGVmZWN0aXZvcy4KCmBgYHtyfQpjb21pMTcgfD4gCiAgc3VtbWFyaXNlKEN1YXJ0aWxlcyA9IHF1YW50aWxlKElORjExMF9UT1QpKQpgYGAKCkxvcyBjdWFydGlsZXMgdGFtYmnDqW4gc2UgcHVlZGVuIGNhbGN1bGFyIHBvciB0aXBvIGRlIGNvbWlzYXLDrWEuCkVzdGUgY8OzZGlnbyBub3MgbXVlc3RyYSBsb3MgY3VhcnRpbGVzIHBvciB0aXBvIGRlIGNvbWlzYXLDrWEgZW4gY2FkYSBmaWxhLgoKYGBge3J9CmN1YXJ0aWxlc3h0aXBvID0gY29taTE3IHw+IAogIGdyb3VwX2J5KHRpcG8pIHw+CiAgc3VtbWFyaXNlKHF1YW50aWxlKElORjExMF9UT1QpKQpjdWFydGlsZXN4dGlwbwpgYGAKCkVsIGFuY2hvIGRlIGNhZGEgY2FqYSBlcyB1biBlc3RhZMOtc3RpY28gZGUgZGlzcGVyc2nDs24uCkVzdGUgZXN0YWTDrXN0aWNvIHNlIGxsYW1hIHJhbmdvIGludGVyY3VhcnRpbCB5IGZvcm1hbG1lbnRlIGVzIGxhIHJlc3RhIGRlbCBjdWFydGlsIDc1IG1lbm9zIGVsIGN1YXJ0aWwgMjUuCgpMYSB0YWJsYSBub3MgbXVlc3RyYSBsb3MgZG9zIGVzdGFkw61zdGljb3MgZGUgZGlzcGVyc2nDs24sIGVsIHJhbmdvIGludGVyY3VhcnRpbCB5IGxhIGRlc3ZpYWNpw7NuIGVzdMOhbmRhci4KUGFyYSBjb21wYXJhciBlbnRyZSBncnVwb3Mgc2UgcHVlZGUgY29tcGFyYXIgbWVkaWFuYXMgY29udHJhIG1lZGlhbmFzIHkgcmFuZ29zIGludGVyY3VhcnRpbGVzLgpFc3RvIHNlIHB1ZWRlIGhhY2VyIGVuIHVuIGdyw6FmaWNvIGRlIGNhamFzLgpPdHJhIGZvcm1hIGRlIGNvbXBhcmFyIGVzIG1lZGlhcyBjb250cmEgbWVkaWFzIHkgZGVzdmlhY2lvbmVzIGVzdMOhbmRhciBwb3IgZ3J1cG8uCgpgYGB7cn0KcmljeHRpcG8gPSBjb21pMTcgfD4KICBncm91cF9ieSh0aXBvKSB8PgogIHN1bW1hcmlzZShNZWRpYT0gbWVhbihJTkYxMTBfVE9UKSwgRGVzdi5Fc3RkID0gc2QoSU5GMTEwX1RPVCksIAogICAgICAgICAgICBNZWRpYW5hID0gbWVkaWFuKElORjExMF9UT1QpLCBSSUM9IElRUihJTkYxMTBfVE9UKSkKcmljeHRpcG8KYGBgCgpSZWd1bGFybWVudGUgYW1iYXMgY29tcGFyYWNpb25lcyBzb24gY29uc2lzdGVudGVzLgoKIyMgRGVzY3JpcGNpw7NuIGRlIHZhcmlhYmxlIGRlIHRpcG8gZmFjdG9yCgpgYGB7cn0KbGlicmFyeShyaW8pIApjb21pMTdfMiA9IGltcG9ydCgiYmFzZXMvY29taTIwMTdfMi5zYXYiKQpgYGAKCmBgYHtyfQpjb21pMTdfMiA9IGNvbWkxN18yIHw+CiAgbXV0YXRlKGFndWEgPSByZWNvZGUoSU5GMjY0X0EsICcxJyA9ICcxJywgJzInID0gJzEnLCAnMycgPSAnMScsICc0JyA9ICcwJykpCmBgYAoKYGBge3J9CmNvbWkxN18yID0gY29taTE3XzIgfD4KICBtdXRhdGUobHV6ID0gcmVjb2RlKElORjI2NF9CLCAnMScgPSAnMScsICcyJyA9ICcxJywgJzMnID0gJzEnLCAnNCcgPSAnMCcpKQpgYGAKCmBgYHtyfQpjb21pMTdfMiA9IGNvbWkxN18yIHw+CiAgbXV0YXRlKHRlbGVmb25vID0gcmVjb2RlKElORjI2NF9DLCAnMScgPSAnMScsICcyJyA9ICcxJywgJzMnID0gJzEnLCAnNCcgPSAnMCcpKQpgYGAKCmBgYHtyfQpjb21pMTdfMiA9IGNvbWkxN18yIHw+CiAgbXV0YXRlKGludGVybmV0ID0gcmVjb2RlKElORjI2NF9FLCAnMScgPSAnMScsICcyJyA9ICcxJywgJzMnID0gJzEnLCAnNCcgPSAnMCcpKQpgYGAKCmBgYHtyfQpjb21pMTdfMiA9IGNvbWkxN18yIHw+CiAgbXV0YXRlKGludGVybmV0ID0gZmFjdG9yKGludGVybmV0LCBsYWJlbHM9YygiTm8iLCAiU8OtIikpKQpgYGAKCmBgYHtyfQp0YWJsYTIgPSBjb21pMTdfMiB8PgogIGNvdW50KFRpZW5lID0gaW50ZXJuZXQsIG5hbWU9IkZyZWN1ZW5jaWEiKSB8PgogIG11dGF0ZShQb3JjZW50YWplID0gKEZyZWN1ZW5jaWEgLyBzdW0oRnJlY3VlbmNpYSkqMTAwICkpCnRhYmxhMgpgYGAKCmBgYHtyfQpnZ3Bsb3QodGFibGEyLCBhZXMoeD1UaWVuZSwgeT1Qb3JjZW50YWplKSkgKyAKICBnZW9tX2JhcihzdGF0ID0gImlkZW50aXR5IikgKwogIGdndGl0bGUoIkNvbWlzYXLDrWEgdGllbmUgaW50ZXJuZXQiKSArCiAgeGxhYigiQ3VlbnRhIGNvbiBzZXJ2aWNpbyBkZSBpbnRlcm5ldCIpICsKICBnZW9tX3RleHQoYWVzKGxhYmVsPXJvdW5kKFBvcmNlbnRhamUsMSkpLCB2anVzdD0xLjMwLCBjb2xvcj0id2hpdGUiLCBzaXplPTMpKwogIHRoZW1lX21pbmltYWwoKQpgYGAKCiMgQmlibGlvZ3JhZsOtYQo=</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("clase2.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
