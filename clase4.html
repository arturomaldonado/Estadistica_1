<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Arturo Maldonado" />


<title>Clase 4: Recapitulación e Intervalos de Confianza</title>

<script src="site_libs/header-attrs-2.21/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script src="site_libs/navigation-1.1/codefolding.js"></script>
<script src="site_libs/navigation-1.1/sourceembed.js"></script>
<link href="site_libs/highlightjs-9.12.0/textmate.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<link href="site_libs/font-awesome-6.4.0/css/all.min.css" rel="stylesheet" />
<link href="site_libs/font-awesome-6.4.0/css/v4-shims.min.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>

<style type="text/css">
/* for pandoc --citeproc since 2.11 */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}
</style>




<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Estadística_1</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="intro.html">Introducción</a>
</li>
<li>
  <a href="basico.html">Procedimientos básicos</a>
</li>
<li>
  <a href="clase1.html">Clase 1</a>
</li>
<li>
  <a href="clase2.html">Clase 2</a>
</li>
<li>
  <a href="clase3.html">Clase 3</a>
</li>
<li>
  <a href="clase4.html">Clase 4</a>
</li>
<li>
  <a href="clase5.html">Clase 5</a>
</li>
<li>
  <a href="clase6.html">Clase 6</a>
</li>
<li>
  <a href="repaso.html">Repaso</a>
</li>
<li>
  <a href="clase7.html">Clase 10</a>
</li>
<li>
  <a href="clase9.html">Clase 11</a>
</li>
<li>
  <a href="clase12.html">Clase 12</a>
</li>
<li>
  <a href="clase13.html">Clase 13</a>
</li>
<li>
  <a href="clase14.html">Clase 14</a>
</li>
<li>
  <a href="about.html">About</a>
</li>
<li>
  <a href="https://github.com/arturomaldonado/Estadistica_1.0">
    <span class="fab fa-github"></span>
     
  </a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Clase 4: Recapitulación e Intervalos de
Confianza</h1>
<h4 class="author">Arturo Maldonado</h4>
<h4 class="date">9/04/2024</h4>

</div>


<div id="caso-1-efectivos-en-las-comisarias-del-perú"
class="section level1">
<h1>Caso 1: Efectivos en las Comisarias del Perú</h1>
<p><em>Pregunta: ¿los policías en el Perú están distribuidos
equitativamente entre las comisarías del Perú?</em></p>
<p><em>¿Cómo cree que es esta distribución de datos?</em></p>
<p>Para responder a esta pregunta se usa la base de datos de comisarías
del Perú de 2017. Esta base de datos está disponible en la sección <a
href="https://proyectos.inei.gob.pe/microdatos/">Microdatos</a> del
INEI.</p>
<pre class="r"><code>library(rio) 
comi17 = import(&quot;bases/comi2017.sav&quot;)</code></pre>
<p>Esta base de datos incluye la pregunta sobre el número total de
efectivos en cada comisaría. Esta variable se importa en R como una
variable numérica, y efectivamente es el tipo de variable correcto.</p>
<pre class="r"><code>class(comi17$INF110_TOT)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>Como esta es una variable numérica, se puede describir mediante la
media y la mediana.</p>
<p>¿Qué nos indican estos resultados?</p>
<pre class="r"><code>library(tidyverse)
comi17 |&gt;
  summarise(Mínimo = min(INF110_TOT), 
            Mediana = median(INF110_TOT), 
            Promedio = mean(INF110_TOT),
            Máximo = max(INF110_TOT))</code></pre>
<pre><code>##   Mínimo Mediana Promedio Máximo
## 1      3      19 31.61538    259</code></pre>
<p>Se puede graficar la distribución del número de efectivos por
comisarias mediante un histograma. ¿Qué nos indica el gráfico?</p>
<pre class="r"><code>library(ggplot2)
ggplot(comi17, aes(x=INF110_TOT))+
  geom_histogram()+
  xlab(&quot;Número de efectivos&quot;) +
  ylab(&quot;Frecuencia&quot;)+
  theme_light()</code></pre>
<pre><code>## `stat_bin()` using `bins = 30`.
## Pick better value with
## `binwidth`.</code></pre>
<p><img src="clase4_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Se puede incluir el dato de la media y la mediana en este gráfico.
¿Cómo se interpreta la posición relativa de ambas medidas?</p>
<pre class="r"><code>ggplot(comi17, aes(x=INF110_TOT))+
  geom_histogram()+
  geom_vline(xintercept = 19, color = &quot;red&quot;)+
  geom_vline(xintercept = 31.6, color = &quot;green&quot;)+
  xlab(&quot;Número de efectivos&quot;) +
  ylab(&quot;Frecuencia&quot;)+
  theme_light()</code></pre>
<pre><code>## `stat_bin()` using `bins = 30`.
## Pick better value with
## `binwidth`.</code></pre>
<p><img src="clase4_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>Ahora se quiere ver si existen diferencias en el número promedio de
efectivos policiales en las comisarías del Perú entre departamentos o
entre regiones. A pesar que en formulario se recoge el dato de
Departamento, Provincia y Distrito, en la base de datos no se cuenta con
esa información. Lo que se tiene es una variable llamada “ubigeo”. Esta
variable está estandarizada de tal manera que los dos primeros dígitos
corresponden al departamento, los segundos dos dígitos a las provincias
y los últimos dos dígitos al distrito. Por lo tanto, para saber en qué
departamento está la comisaría se requiere separar los primeros dos
dígitos y guardarlos en una nueva variable.</p>
<pre class="r"><code>comi17 &lt;- comi17 %&gt;%
  mutate(dpto = str_sub(UBIGEO, 1, 2))</code></pre>
<p>Copiamos el código usado para el voto 2016 y lo adaptamos a las
necesidades de esta base de datos. La variable “dpto” es una variable de
tipo “character” y sabemos que va desde el “01” al “25”, representando
cada “número” un departamento del Perú, que hemos asociado a Costa = 1,
Sierra = 2 o Selva = 3.</p>
<p>Entonces lo que tenemos que hallar es el código ubigeo de cada
departamento y reemplazarlo por el nombre del departamento en el código
original. La clasificación la guardamos en otra variable “region”.</p>
<pre class="r"><code>comi17 = comi17 %&gt;%
  mutate(region = case_when(
    dpto==&quot;01&quot;~3,
    dpto==&quot;02&quot;~2,
    dpto==&quot;03&quot;~2,
    dpto==&quot;04&quot;~2,
    dpto==&quot;05&quot;~2,
    dpto==&quot;06&quot;~2,
    dpto==&quot;08&quot;~2,
    dpto==&quot;07&quot;~1,
    dpto==&quot;09&quot;~2,
    dpto==&quot;10&quot;~3,
    dpto==&quot;11&quot;~1,
    dpto==&quot;12&quot;~2,
    dpto==&quot;13&quot;~1,
    dpto==&quot;14&quot;~1,
    dpto==&quot;15&quot;~1,
    dpto==&quot;16&quot;~3,
    dpto==&quot;17&quot;~3,
    dpto==&quot;18&quot;~1,
    dpto==&quot;19&quot;~2,
    dpto==&quot;20&quot;~1,
    dpto==&quot;21&quot;~2,
    dpto==&quot;22&quot;~3,
    dpto==&quot;23&quot;~1,
    dpto==&quot;24&quot;~1,
    dpto==&quot;25&quot;~3
  )) </code></pre>
<p>Esta variable “region” es de tipo numérico, pero los códigos (1, 2 y
3) no son números, sino códigos para Costa, Sierra y Selva, por lo que
tenemos que crear otra variable, “region2” que sea de tipo “factor” con
las etiquetas correspondientes.</p>
<pre class="r"><code>library(forcats)
comi17 = comi17 %&gt;%
  mutate(region2 = factor(region, labels=c(&quot;Costa&quot;, &quot;Sierra&quot;, &quot;Selva&quot;)))</code></pre>
<p>Podemos usar esta variable para calcular los descriptivos del número
de efectivos por región. ¿Qué conclusión saca de la tabla?</p>
<pre class="r"><code>tabla1 = comi17 %&gt;%
  group_by(region2) %&gt;%
  summarise(Mínimo = min(INF110_TOT), 
            Mediana = median(INF110_TOT), 
            Promedio = mean(INF110_TOT),
            Desv = sd(INF110_TOT),
            Máximo = max(INF110_TOT))
tabla1</code></pre>
<pre><code>## # A tibble: 3 × 6
##   region2 Mínimo Mediana Promedio  Desv Máximo
##   &lt;fct&gt;    &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1 Costa        4      28     44.3  38.3    259
## 2 Sierra       3      16     24.2  24.8    190
## 3 Selva        4      16     24.0  26.5    165</code></pre>
<p>Esta tabla sirve para comparar los datos descriptivos por grupos de
otra variable. Algo similar se puede hacer con el gráfico de cajas, pero
comparando medianas y rangos intercuartiles.</p>
<pre class="r"><code>ggplot(comi17, aes(y=INF110_TOT, x=region2))+
  geom_boxplot()+
  ylab(&quot;Número de efectivos&quot;)+
  xlab(&quot;Región&quot;)+
  theme_get()</code></pre>
<p><img src="clase4_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
</div>
<div id="caso-2-servicios-básicos-en-las-comisarías-del-perú"
class="section level1">
<h1>Caso 2: Servicios básicos en las comisarías del Perú</h1>
<p><em>Pregunta: ¿Las comisarías del Perú cuentan con los servicios
básicos? ¿Cuentan con internet?</em></p>
<p>Para responder estas preguntas, la Encuesta Nacional de Comisarías de
2017 tiene otro módulo sobre infraestructura. Cargamos esa base de
datos.</p>
<pre class="r"><code>comi17_2 = import(&quot;bases/comi2017_2.sav&quot;)</code></pre>
<p>Esta base incluye la pregunta INF216 sobre luz eléctrica, la pregunta
INF225 sobre agua potable, la pregunta INF230 sobre desagüe y la
pregunta INF264_E sobre el servicio de internet.</p>
<p>En primer lugar verificamos cómo se importan las variables. Vemos que
se importan como variables numéricas. La variable sobre luz tiene
opciones Si = 1 y No = 2. Esta variable es en realidad una de tipo
factor.</p>
<pre class="r"><code>class(comi17_2$INF216)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>table(comi17_2$INF216)</code></pre>
<pre><code>## 
##    1    2 
## 1485    9</code></pre>
<p>Se procede a crear otra variable “luz”, como la factorización de
INF216 con etiquetas Sí y No.</p>
<pre class="r"><code>comi17_2 = comi17_2 %&gt;%
  mutate(luz = factor(INF216, labels=c(&quot;Sí&quot;, &quot;No&quot;)))</code></pre>
<p>Esta variable incluye algunas comisarías donde no se tiene el dato,
por lo que cuando se calcula la tabla, se filtra solo las respuestas Sí
y No. Se guarda los resultados en un objeto “tabla2”.</p>
<pre class="r"><code>tabla2 = comi17_2 %&gt;%
  filter(luz == &quot;Sí&quot; | luz == &quot;No&quot;) %&gt;%
  count(Luz = luz, name=&quot;Frecuencia&quot;)
tabla2</code></pre>
<pre><code>##   Luz Frecuencia
## 1  Sí       1485
## 2  No          9</code></pre>
<p>Se añade a este mismo objeto los porcentajes. ¿Qué conclusiones saca
de estos resultados?</p>
<pre class="r"><code>tabla2 = tabla2 %&gt;%
  mutate(Porcentaje = (Frecuencia / sum(Frecuencia)*100 ))
tabla2</code></pre>
<pre><code>##   Luz Frecuencia Porcentaje
## 1  Sí       1485 99.3975904
## 2  No          9  0.6024096</code></pre>
<p>Se hace el mismo procedimiento con la variable sobre agua potable. En
este caso, la variable tiene cinco valores.</p>
<pre class="r"><code>class(comi17_2$INF225)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>table(comi17_2$INF225)</code></pre>
<pre><code>## 
##    1    3    4    5    6 
## 1424   28   30   12    1</code></pre>
<pre class="r"><code>comi17_2 = comi17_2 %&gt;%
  mutate(agua = factor(INF225, labels=c(&quot;Red pública dentro del local&quot;, 
                                        &quot;Camión cisterna&quot;,
                                        &quot;Pozo&quot;,
                                        &quot;Río, acequia o manantial&quot;,
                                        &quot;Otro&quot;)))
table(comi17_2$agua)</code></pre>
<pre><code>## 
## Red pública dentro del local              Camión cisterna 
##                         1424                           28 
##                         Pozo     Río, acequia o manantial 
##                           30                           12 
##                         Otro 
##                            1</code></pre>
<p>Se calcula la tabla de distribución de frecuencias, con el cálculo de
los porcentajes en el mismo código. ¿Qué conclusiones saca de estos
resultados?</p>
<pre class="r"><code>tabla3 = comi17_2 %&gt;%
  count(Agua = agua, name=&quot;Frecuencia&quot;) %&gt;%
  mutate(Porcentaje = (Frecuencia / sum(Frecuencia)*100 ))
tabla3</code></pre>
<pre><code>##                           Agua Frecuencia  Porcentaje
## 1 Red pública dentro del local       1424 95.25083612
## 2              Camión cisterna         28  1.87290970
## 3                         Pozo         30  2.00668896
## 4     Río, acequia o manantial         12  0.80267559
## 5                         Otro          1  0.06688963</code></pre>
<p>Se hace el mismo procedimiento con la variable sobre desagüe.</p>
<pre class="r"><code>class(comi17_2$INF230)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>table(comi17_2$INF230)</code></pre>
<pre><code>## 
##    1    2    3    4    5 
## 1394   64   28    4    5</code></pre>
<pre class="r"><code>comi17_2 = comi17_2 %&gt;%
  mutate(desague = factor(INF230, labels=c(&quot;Red pública dentro del local&quot;, 
                                        &quot;Pozo séptico&quot;,
                                        &quot;Letrina&quot;,
                                        &quot;Otro&quot;,
                                        &quot;No tiene baño&quot;)))
table(comi17_2$desague)</code></pre>
<pre><code>## 
## Red pública dentro del local                 Pozo séptico 
##                         1394                           64 
##                      Letrina                         Otro 
##                           28                            4 
##                No tiene baño 
##                            5</code></pre>
<p>¿Qué conclusiones saca de estos resultados?</p>
<pre class="r"><code>tabla4 = comi17_2 %&gt;%
  count(Desague = desague, name=&quot;Frecuencia&quot;) %&gt;%
  mutate(Porcentaje = (Frecuencia / sum(Frecuencia)*100 ))
tabla4</code></pre>
<pre><code>##                        Desague Frecuencia Porcentaje
## 1 Red pública dentro del local       1394 93.2441472
## 2                 Pozo séptico         64  4.2809365
## 3                      Letrina         28  1.8729097
## 4                         Otro          4  0.2675585
## 5                No tiene baño          5  0.3344482</code></pre>
<p>Finalmente, se hace lo mismo para la pregunta sobre internet.</p>
<pre class="r"><code>class(comi17_2$INF264_E)</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<pre class="r"><code>table(comi17_2$INF264_E)</code></pre>
<pre><code>## 
##   1   2   3   4 
## 127 950 132 286</code></pre>
<pre class="r"><code>comi17_2 = comi17_2 %&gt;%
  mutate(internet = factor(INF264_E, labels=c(&quot;Sí, pago pendiente&quot;, 
                                        &quot;Sí, pago al día&quot;,
                                        &quot;Sí, no sabe del pago&quot;,
                                        &quot;No cuenta con el servicio&quot;)))
table(comi17_2$internet)</code></pre>
<pre><code>## 
##        Sí, pago pendiente           Sí, pago al día      Sí, no sabe del pago 
##                       127                       950                       132 
## No cuenta con el servicio 
##                       286</code></pre>
<p>¿Qué conclusiones saca sobre estos resultados?</p>
<pre class="r"><code>tabla5 = comi17_2 %&gt;%
  count(Internet = internet, name=&quot;Frecuencia&quot;) %&gt;%
  mutate(Porcentaje = (Frecuencia / sum(Frecuencia)*100 ))
tabla5</code></pre>
<pre><code>##                    Internet Frecuencia Porcentaje
## 1        Sí, pago pendiente        127   8.494983
## 2           Sí, pago al día        950  63.545151
## 3      Sí, no sabe del pago        132   8.829431
## 4 No cuenta con el servicio        286  19.130435</code></pre>
<p>Este tipo de variables, de tipo factor, se puede visualizar con
gráficos de barras.</p>
<pre class="r"><code>graf1 = ggplot(tabla5, aes(x=Internet, y=Porcentaje))+
  geom_bar(stat=&quot;identity&quot;)+
  geom_text(aes(label=paste(round(Porcentaje, 1))), vjust=-1, size=3)+
  labs(x=&quot;Internet&quot;, y=&quot;Porcentaje&quot;)+
  theme_classic()
graf1</code></pre>
<p><img src="clase4_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<div id="tarea" class="section level2">
<h2>Tarea</h2>
<p>Calcule las tablas de distribución de frecuencias de luz y de
internet por regiones. Grafique.</p>
</div>
</div>
<div id="pruebas-de-significancia" class="section level1">
<h1>Pruebas de significancia</h1>
<p>Es una de las técnicas más usadas para el análisis en ciencias
sociales. Sirve, por ejemplo, para comparar entre grupos:</p>
<ul>
<li><p>Comparar la media de ingresos de hombres y mujeres</p></li>
<li><p>Comparar la proporción de personas que votarán a candidato X en
Lima y en Regiones</p></li>
<li><p>Comparar los ingresos de profesores en la gestión pública y en la
gestión privada</p></li>
</ul>
<p>La idea es comparar las estimaciones puntuales entre ambos grupos y
también poder extrapolar estas diferencias a la población.</p>
<p>Vamos a comenzar por comparaciones entre solo 2 grupos (por el
momento), que corresponde a una variable binaria o dicotómica, como sexo
(hombres/mujeres), ámbito (urbano/rural), gestión educativa
(pública/privada).</p>
<p>Para mostrar un ejemplo, vamos a usar el trabajo de <span
class="citation">(Galarza, Kogan, and Yamada 2012)</span> que evalúa la
discriminación en el mercado laborar entre hombres y mujeres. Estos
autores enviaron CVs con exactas cualificaciones a ofertas reales de
trabajo, variando solo el nombre del aplicante, con nombres de hombres y
mujeres. La variable de respuesta es la tasa de respuesta a estos CVs,
es decir, de cuántos CVs enviados se recibió una llamada para una
entrevista.</p>
<p>En cualquier prueba de significancia se tiene que presentar una
hipótesis nula, que generalmente es la hipótesis de no diferencias o de
no efectos. Este trabajo parte de una idea que existe una discriminación
de género en el mercado laboral, por lo que la hipótesis nula indicaría
lo contrario. En el caso de este trabajo se tendría:</p>
<p>H0: Tasa de respuesta a CVs de hombres = Tasa de respuesta a CVs de
mujeres</p>
<p>o lo que es lo mismo</p>
<p>H0: Tasa de respuesta a CVs de hombres - Tasa de respuesta a CVs de
mujeres = 0</p>
<p>En ese trabajo se presenta el siguiente cuadro de resultados:</p>
<p><img src="Galarza.png" width="435" /></p>
<p>En la muestra total de 2,228 CVs enviados, mitad de CVs con nombres
de hombres y la otra mitad con nombres de mujeres, todos con las mismas
cualificacions, se tiene que la tasa de respuesta para los CVs de
hombres es 13.4% y para los CVs de mujeres es 11.1%.</p>
<p>De acuerdo a las estimaciones puntuales, efectivamente, los hombres
tienen una mayor tasa de respuesta a sus CVs que las mujeres, a iguales
cualificaciones. Esta conclusión, sin embargo, es solo para las 2,228
observaciones de la muestra. ¿Cómo extrapolar esta conclusión a la
población? ¿Toda diferencia puntual se validaría en la población?</p>
</div>
<div id="comparación-de-intervalos-de-confianza-por-grupos"
class="section level1">
<h1>Comparación de intervalos de confianza por grupos</h1>
<p>Una primera forma “informal” para extrapolar las diferencias en las
estimaciones puntuales de la muestra a la población es construyendo los
intervalos de confianza para la media o para la proporción por cada uno
de los subgrupos.</p>
<p>En este caso, por ejemplo, significaría construir el IC de la tasa de
respuesta para hombre y mujeres.</p>
<p>Pregunta: ¿Se pueden construir los IC de cada grupo con los datos de
la tabla?</p>
<p>Cada IC sería una extrapolación del parámetro, es decir, el rango de
valores de la tasa de respuesta a los CVs de hombres para todo el
mercado laboral al 95% de confianza. Lo mismo para la tasa de respuesta
de las mujeres.</p>
<p>Una vez construidos los IC, se analiza si estos intervalos se cruzan
o no se cruzan. La regla de decisión “informal” es:</p>
<ul>
<li><p>Si los IC de ambos grupos se cruzan, entonces no se puede afirmar
que el parámetro de un grupo sea mayor o menos que el parámetro del otro
grupo.</p></li>
<li><p>Si los IC de ambos grupos NO se cruzan, entonces se puede
afirmar, al 95% de confianza, que el parámetro de un grupo es
mayor/menor al parámetro del otro grupo.</p></li>
</ul>
</div>
<div id="ejemplo-1-para-una-variable-numérica-endo"
class="section level1">
<h1>Ejemplo 1 para una variable numérica: ENDO</h1>
<p><em>Pregunta: ¿a cuántos alumnos en promedio atiende un profesor
peruano? ¿Existen diferencias de género?</em></p>
<p>Usando el ejemplo de la ENDO 2020, la hipótesis que se puede evaluar
es si los profesores atienden a diferente número de alumnos de acuerdo a
su sexo. Como vimos antes, las comparaciones puntuales sugieren
diferencias, donde los docentes hombres atienden a más alumnos que las
docentes mujeres.</p>
<p>La hipótesis cero sería:</p>
<p>Ho: Promedio de alumnos que acompaña un docente hombre = Promedio de
alumnos que acompaña una docente mujer.</p>
<pre class="r"><code>library(rio)
endo2020 = import(&quot;bases/ENDO_REMOTO_2020.dta&quot;)</code></pre>
<p>La variable P1_1 (sexo del docente) está definida originalmente como
una variable numérica (esto se puede comprobar con el código
<code>str(endo2020$P1_1)</code>. Esta variable, sin embargo es de tipo
factor.</p>
<p>Se puede crear una nueva variable “sexo” con la variable transformada
y etiquetada.</p>
<pre class="r"><code>library(dplyr)
library(tidyverse)
endo2020 = endo2020 |&gt;
  mutate(sexo = factor(P1_1, labels=c(&quot;Hombre&quot;, &quot;Mujer&quot;)))</code></pre>
<pre class="r"><code>alumxsexo = endo2020 |&gt; 
  group_by(sexo) |&gt;
  summarize(Media = mean(P1_6, na.rm = T), 
            Desv.Std = sd(P1_6, na.rm = T))
alumxsexo</code></pre>
<pre><code>## # A tibble: 3 × 3
##   sexo   Media Desv.Std
##   &lt;fct&gt;  &lt;dbl&gt;    &lt;dbl&gt;
## 1 Hombre  52.2     60.4
## 2 Mujer   34.1     44.2
## 3 &lt;NA&gt;   NaN       NA</code></pre>
<p>Se encuentra que los docentes hombres acompañan a 52 alumnos en
promedio, en comparación con las docentes mujeres que acompañan a 34
alumnos en promedio, es decir 18 alumnos menos en promedio.</p>
<p>Recordemos que el cálculo del intervalo de confianza de una media
es:</p>
<p><span class="math display">\[
IC =  \bar{X} \pm 1.96 * \frac{s} {\sqrt{n}}
\]</span></p>
<p>Para una comparación usando los intervalos de confianza, se puede
usar el comando <code>ciMean</code> de la librería <code>lsr</code>.
Este comando regresa el límite inferior y el límite superior del
intervalo de confianza. Por lo tanto, para guardar solo el mínimo se
tiene que especificar <code>lsr::ciMean(P1_6, na.rm=T)[1]</code> y para
el máximo cambiaría a <code>[2]</code>.</p>
<pre class="r"><code>library(lsr)
ci_alumxsexo = endo2020 |&gt;
  group_by(sexo) |&gt;
  summarise(media = mean(P1_6, na.rm=T),
            liminf = ciMean(P1_6, na.rm=T)[1],
            limsup = ciMean(P1_6, na.rm=T)[2]
            )
ci_alumxsexo</code></pre>
<pre><code>## # A tibble: 3 × 4
##   sexo   media liminf limsup
##   &lt;fct&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 Hombre  52.2   50.7   53.8
## 2 Mujer   34.1   33.3   34.8
## 3 &lt;NA&gt;   NaN     NA     NA</code></pre>
<ul>
<li><p>El IC al 95% de confianza, el promedio de alumnos que acompañan
los docentes hombre está en el siguiente intervalo <span
class="math display">\[50.7 - 53.8\]</span></p></li>
<li><p>El IC al 95% de confianza el promedio de alumnos que acompañan
las docentes mujeres está en el siguiente intervalo <span
class="math display">\[33.3 - 34.8\]</span></p></li>
</ul>
<p>Como ambos intervalos NO se traslapan (el mayor valor del segundo IC,
34.8 , es menor al mejor valor del primer IC, 50.7), entonces se puede
afirmar que esas diferencias se pueden extrapolar la población.</p>
<p>Si los IC se traslapan, entonces, no se puede afirmar que existan
diferencias en el número de alumnos que acompañan docentes hombres o
mujeres (sería un “empate técnico”).</p>
<div id="gráfico-de-ic-para-comparar-medias" class="section level2">
<h2>Gráfico de IC para comparar medias</h2>
<p>Se puede graficar ambos intervalos de confianza. Para hacer esto,
usaremos la tabla que guarda los datos de los intervalos de
confianza.</p>
<p>Esta tabla, sin embargo, tiene una fila de resultados para los
valores perdidos. Esta fila no tiene datos por graficar, por lo que
tenemos que eliminarla.</p>
<p>Los dataframes se organizan en filas y columnas. La table
“ci_alumxsexo” tiene 3 filas y 3 columnas. La tercera fila es la que no
tiene datos que graficar. Para eliminar se tiene que especificar la
tabla y con los brackets <code>[filas, columnas]</code> definir los
datos a eliminar <code>[-3, ]</code>. Se elimina con el signo “-” y como
no hay datos luego de la “,”, se indica que no se cambia ninguna
columna.</p>
<pre class="r"><code>ci_alumxsexo = ci_alumxsexo[-3,]
ci_alumxsexo</code></pre>
<pre><code>## # A tibble: 2 × 4
##   sexo   media liminf limsup
##   &lt;fct&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 Hombre  52.2   50.7   53.8
## 2 Mujer   34.1   33.3   34.8</code></pre>
<p>Esta tabla se puede usar para crear un gráfico que compare ambos IC
con la librería <code>ggplot2</code> y con la geometría
<code>geom_errorbar</code>. Se agrega <code>geom_text</code> para
incluir el “texto” con los valores promedio de ambos grupos.</p>
<pre class="r"><code>library(ggplot2)
graf1 = ggplot(ci_alumxsexo, aes(x=sexo, y=media))+
  geom_bar(stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=liminf, ymax=limsup), width=0.2)+
  geom_text(aes(label=paste(round(media, 1))), vjust=-1, size=4)+
  xlab(&quot;Sexo del docente&quot;) + ylab(&quot;Alumnos atendidos&quot;)+
  ylim(0, 60)
graf1</code></pre>
<p><img src="clase4_files/figure-html/grafico1-1.png" width="672" /></p>
<p>En este gráfico queda más claro que ambos IC no se traslapan por lo
que se puede decir que sí existen diferencias entre docentes hombre y
mujeres en el número de alumnos que acompañan en el Perú.</p>
<p>Este tipo de gráfico es bastante usual en los reportes estadísticos.
Por ejemplo, se pueden ver este tipo de gráficos en los reportes de <a
href="https://www.vanderbilt.edu/lapop/ab2021/2021_LAPOP_AmericasBarometer_2021_Pulse_of_Democracy_SPA.pdf">El
Pulso de la Democracia</a> del proyecto LAPOP. En el último reporte para
Perú se presenta el siguiente gráfico que muestra los niveles de
satisfacción con la democracia entre grupos de satisfacción con los
servicios públicos. Estos gráficos son construidos de la misma manera
que se ha construido el gráfico de arriba.</p>
<p><img src="graf6.6.png" width="635" /></p>
<p>¿Por qué?. .. Aquí viene la interpretación del politólogo .</p>
<p>OJO: no se debe confundir este gráfico con un gráfico de cajas.</p>
<p>TAREA: Analizar si existen diferencias en el número de alumnos entre
docentes con diferentes condiciones laborales (P1_7).</p>
</div>
</div>
<div id="ejemplo-2-para-una-variable-numérica-lapop"
class="section level1">
<h1>Ejemplo 2 para una variable numérica: LAPOP</h1>
<pre class="r"><code>library(rio)
lapop = import(&quot;bases/PER_2006-2021.dta&quot;)</code></pre>
<div id="ejemplo-para-variable-numérica-con-índice-aditivo"
class="section level2">
<h2>Ejemplo para variable numérica con índice aditivo</h2>
<p>El cuestionario de LAPOP incluye dos preguntas sobre las fuerzas del
orden. B12. ¿Hasta qué punto tiene usted confianza en las Fuerzas
Armadas? y B18. ¿Hasta qué punto tiene usted confianza en la policía
nacional?</p>
<p>Ambas preguntas están medidas en una escala de 1 a 7, donde 1
significa “Nada” y 7 significa “Mucho”. Una persona que tenga
desconfianza de las fuerzas del orden en general, seguramente reportará
puntajes bajos en ambas preguntas. Por el contrario, una persona que
tenga alta confianza en las fuerzas del orden en general, puede reportar
puntajes altos en ambas preguntas.</p>
<p>Se pueden combinar ambas preguntas para generar un índice aditivo de
confianza general en las fuerzas del orden, como la suma de ambas. Como
cada pregunta puede ser respondida entre 1 y 7, la suma puede variar
entre 2 y 14. Un puntaje de 2 expresará la más baja confianza en las
fuerzas del orden. Un puntaje de 14, la más alta confianza en las
fuerzas del orden. Cualquier puntaje intermedio, expresará una confianza
intermedia.</p>
<p>Como NO es intuitivo tener un índice que varíe entre 2 y 14, se puede
restar dos a la suma para que el índice varíe entre 0 y 12. Como esta
variación tampoco es intuitiva, se puede dividir todo entre 12 para que
el índice varíe entre 0 y 1.</p>
<table>
<colgroup>
<col width="16%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
<col width="13%" />
</colgroup>
<thead>
<tr class="header">
<th></th>
<th align="center">Confianza en FFAA</th>
<th align="center">Confianza en policía</th>
<th align="center">Confianza general</th>
<th align="center">Confianza general - 2</th>
<th align="center">(Confianza general - 2) / 12</th>
<th align="center">(Confianza general - 2) / 12*100</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Persona con mucha desconfianza en las fuerzas del orden</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr class="even">
<td>Persona con mucha confianza en las fuerzas del orden</td>
<td align="center">7</td>
<td align="center">7</td>
<td align="center">14</td>
<td align="center">12</td>
<td align="center">1</td>
<td align="center">100</td>
</tr>
<tr class="odd">
<td>Persona con confianza media en las fuerzas del orden</td>
<td align="center">4</td>
<td align="center">5</td>
<td align="center">9</td>
<td align="center">7</td>
<td align="center">0.58</td>
<td align="center">58</td>
</tr>
<tr class="even">
<td>Persona con confianza media en las fuerzas del orden</td>
<td align="center">6</td>
<td align="center">4</td>
<td align="center">10</td>
<td align="center">8</td>
<td align="center">0.66</td>
<td align="center">66</td>
</tr>
</tbody>
</table>
<p>De esta manera cada persona tiene un puntaje que puede variar entre 0
y 1, dependiendo de las respuestas que dio a cada una de las preguntas
individuales.</p>
<p>Esto se puede calcular en R.</p>
<pre class="r"><code>library(dplyr)
lapop = lapop |&gt;
  mutate(indice = (b12+b18-2)/12*100)</code></pre>
<p>Podemos asumir que este índice es una variable cuantitativa, por lo
que podemos calcular la media y el intervalo de confianza de la
media.</p>
<pre class="r"><code>library(lsr)
lapop |&gt;
  summarise(media = mean(indice, na.rm=T),
            liminf = ciMean(indice, na.rm=T)[1],
            limsup = ciMean(indice, na.rm=T)[2]
            )</code></pre>
<pre><code>##      media   liminf   limsup
## 1 48.67959 48.25316 49.10602</code></pre>
<p>Mejor aún, podemos calcular el índice de confianza en las fuerzas del
orden por año de la encuesta.</p>
<pre class="r"><code>indicexwave = lapop |&gt;
  group_by(wave) |&gt;
  summarise(media = mean(indice, na.rm=T),
            liminf = ciMean(indice, na.rm=T)[1],
            limsup = ciMean(indice, na.rm=T)[2]
            )
indicexwave</code></pre>
<pre><code>## # A tibble: 8 × 4
##    wave media liminf limsup
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1  2006  46.1   44.9   47.4
## 2  2008  45.5   44.2   46.7
## 3  2010  47.4   46.3   48.6
## 4  2012  46.1   45.0   47.2
## 5  2014  45.6   44.4   46.8
## 6  2016  53.5   52.6   54.4
## 7  2018  51.1   49.9   52.3
## 8  2021  55.5   52.9   58.2</code></pre>
<p>Con lo que podemos comparar el índice de apoyo a las fuerzas del
orden por año para sacar conclusiones acerca de diferencias.</p>
<pre class="r"><code>library(ggplot2)
graf3 = ggplot(indicexwave, aes(x=wave, y=media))+
  geom_bar(stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=liminf, ymax=limsup), width=0.2)+
  geom_text(aes(label=paste(round(media, 1))), vjust=-1, size=4)+
  xlab(&quot;Año de encuestas&quot;) + ylab(&quot;Índice de confianza en las fuerzas del orden&quot;)+
  ylim(0, 60)
graf3</code></pre>
<p><img src="clase4_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
</div>
<div id="section" class="section level2">
<h2></h2>
</div>
</div>
<div id="ejemplo-1-para-una-variable-categórica-endo"
class="section level1">
<h1>Ejemplo 1 para una variable categórica: ENDO</h1>
<p>Siguiendo con el ejemplo de la ENDO 2020, la hipótesis que se puede
evaluar es si existen diferencias en si los docentes han recibido apoyo
psicológico o emocional por sexo (P1_13).</p>
<p>La hipótesis cero sería: La proporción de docentes que han recibido
apoyo psicológico entre docentes hombres = Proporción de docentes que
han recibido apoyo psicológico entre docentes mujeres.</p>
<p>Lo primero es transformar la variable P1_13 que es importada como
numérica, como una variable de factor y con sus etiquetas.</p>
<pre class="r"><code>endo2020 = endo2020 |&gt;
  mutate(apoyo = factor(P1_13, labels=c(&quot;Sí&quot;, &quot;No&quot;)))</code></pre>
<p>Ahora tenemos que producir la tabla de distribución de frecuencias.
Si calculamos las frecuencias con <code>count</code> directamente, esta
tabla incluiría una fila de los NAs y luego calculará los porcentajes
incluyendo a este grupo. Es por esto que antes de calcular las
frecuencias, tenemos que filtrar para que solo cuente los “Sí” y “No”.
Luego de las frecuencias, incluimos el porcentaje con
<code>mutate</code>.</p>
<pre class="r"><code>tabla = endo2020 |&gt;
  filter(apoyo ==&quot;Sí&quot; | apoyo == &quot;No&quot;) |&gt;
  count(Apoyo = apoyo, name=&quot;N&quot;)|&gt;
  mutate(total = sum(N), 
         Por = N / total * 100)
tabla</code></pre>
<pre><code>##   Apoyo    N total      Por
## 1    Sí 9476 18930 50.05811
## 2    No 9454 18930 49.94189</code></pre>
<p>Por ejemplo, para hallar el IC de la proporción de aquellos docentes
que reportaron haber recibido apoyo psicológico, podemos usar el comando
<code>prop.test</code>. Este comando requiere el n de la opción “Sí” de
la tabla y el total de casos. Por defecto nos calcula el IC al 95% de
confianza.</p>
<pre class="r"><code>prop.test(9476,18930)</code></pre>
<pre><code>## 
##  1-sample proportions test with continuity correction
## 
## data:  9476 out of 18930, null probability 0.5
## X-squared = 0.023296, df = 1, p-value = 0.8787
## alternative hypothesis: true p is not equal to 0.5
## 95 percent confidence interval:
##  0.4934326 0.5077293
## sample estimates:
##         p 
## 0.5005811</code></pre>
<p>Se estima que el la proporción de docentes que recibieron apoyo
psicológico está entre 49.3% y 50.8%.</p>
<p>Luego, para responder a la pregunta de si esta proporción varía entre
docentes hombres y mujeres, tenemos que crear otra tabla con las
frecuencias y porcentajes por cada grupo de la variable “sexo”. Para
esto, al código anterior le agregamos el comando
<code>group_by</code>.</p>
<pre class="r"><code>tabla2 = endo2020 |&gt;
  filter(apoyo ==&quot;Sí&quot; | apoyo == &quot;No&quot;) |&gt;
  group_by(sexo) |&gt;
  count(Apoyo = apoyo, name=&quot;N&quot;)|&gt;
  mutate(total = sum(N), 
         Por = N / total * 100, 
         err = sqrt(Por*(100-Por)/N), 
         liminf = Por - 1.96*err, 
         limsup = Por + 1.96*err)
tabla2</code></pre>
<pre><code>## # A tibble: 4 × 8
## # Groups:   sexo [2]
##   sexo   Apoyo     N total   Por   err liminf limsup
##   &lt;fct&gt;  &lt;fct&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 Hombre Sí     2777  6163  45.1 0.944   43.2   46.9
## 2 Hombre No     3386  6163  54.9 0.855   53.3   56.6
## 3 Mujer  Sí     6699 12767  52.5 0.610   51.3   53.7
## 4 Mujer  No     6068 12767  47.5 0.641   46.3   48.8</code></pre>
<p>El mismo comando <code>prop.test</code> permite hacer la prueba para
la diferencia de proporciones. Para esto, los valores tanto de hombres,
como de mujeres, se concatenan con la especificación <code>c(…)</code>,
tanto para el n de “Sí” de cada grupo, como para el total de casos de
cada grupo.</p>
<pre class="r"><code>prop.test(c(2777, 6699), c(6163,12767))</code></pre>
<pre><code>## 
##  2-sample test for equality of proportions with continuity correction
## 
## data:  c(2777, 6699) out of c(6163, 12767)
## X-squared = 91.044, df = 1, p-value &lt; 2.2e-16
## alternative hypothesis: two.sided
## 95 percent confidence interval:
##  -0.08938432 -0.05885549
## sample estimates:
##    prop 1    prop 2 
## 0.4505922 0.5247121</code></pre>
<p>Según los resultados, se encuentra que el 52.5% de docentes mujeres
recibieron apoyo psicológico versus el 45.1% de docentes hombres. Este
comando no nos brinda directamente los límites inferior y superior de
los IC de cada grupo, pero nos brinda el IC de la diferencia de
proporciones al 95% de confianza. Este IC de la diferencia de
proporciones varía entre -8.9% y -5.9%.</p>
<p>Como este IC va solo entre valores negativos; es decir, como el IC no
incluye al cero, se puede concluir que la diferencia de proporciones no
puede ser cero, por lo tanto, que existe una diferencia estadísticamente
significativa en las proporciones entre ambos grupos.</p>
<p>La tabla 2 se puede usar para graficar. Como nos interesa comparar
los porcentajes de docentes que reportaron haber recibido atención
psicológica por sexo, se puede eliminar las filas de aquellos que no
recibieron atención psicológica en la tabla 2.</p>
<pre class="r"><code>tabla2 = tabla2[-c(2,4),]</code></pre>
<p>Luego, con esta tabla podemos seguir el mismo procedimiento que con
el cálculo de las barras de error para la media, pero esta vez para los
porcentajes.</p>
<pre class="r"><code>graf2 = ggplot(tabla2, aes(x=sexo, y=Por))+
  geom_bar(stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=liminf, ymax=limsup), width=0.2)+
  geom_text(aes(label=paste(round(Por, 1))), vjust=-1, size=4)+
  xlab(&quot;Sexo del docente&quot;) + ylab(&quot;Porcentaje que recibió atención psicológica&quot;)+
  ylim(0, 60)
graf2</code></pre>
<p><img src="clase4_files/figure-html/unnamed-chunk-39-1.png" width="672" /></p>
<p>De este gráfico se puede concluir que existen diferencias
estadísticamente significativas en el porcentaje de docentes que
buscaron atención psicológica entre hombres y mujeres, debido a que los
intervalos de confianza no se traslapan.</p>
<p>De manera más específica, se puede afirmar que las docentes peruanas
reciben más atención psicológica que los docentes hombres.</p>
<div id="ejemplo-para-variable-categórica" class="section level2">
<h2>Ejemplo para variable categórica</h2>
<p>En la página 21 del reporte <em>Cultura política de la democracia en
Perú y en las Américas 2021: Tomándole el pulso a la democracia</em> se
presenta el gráfico que muestra el porcentaje de apoyo a la democracia
en Perú (línea magenta) a lo largo del tiempo, en comparación con
América Latina (línea morada).</p>
<p>El apoyo a la democracia, variable “ING4”, está medida en una escala
del 1 al 7, donde 1 significa “muy en desacuerdo” y 7 significa “muy de
acuerdo”. Esta variable se tiene que recodificar. De acuerdo al reporte
“Las respuestas van de 1 (muy en desacuerdo) a 7 (muy de acuerdo). Para
este análisis, se codificaron las respuestas en el extremo”de acuerdo”
de la escala (valores que van de 5 a 7) como apoyo a la democracia.”
(p.7).</p>
<p><img src="apoyo_peru.png" /></p>
<p>Para recodificar la variable se usa el siguiente código. El resultado
es una variable dicotómica (0=No, 1=Sí), que es una variable categórica,
aunque incluye un grupo que no tiene respuesta en esta variable y está
como NAs.</p>
<pre class="r"><code>lapop = lapop |&gt;
  mutate(ing4rec=recode(ing4, &#39;5&#39; = 1, &#39;6&#39; = 1, &#39;7&#39; = 1,  .default = 0))</code></pre>
<p>Se verifica la recodificación.</p>
<pre class="r"><code>lapop |&gt;
  count(ing4, name=&quot;Frecuencia&quot;)</code></pre>
<pre><code>##   ing4 Frecuencia
## 1    1        768
## 2    2        885
## 3    3       1811
## 4    4       3095
## 5    5       3349
## 6    6       2284
## 7    7       2121
## 8   NA        393</code></pre>
<p>Lo que queremos es encontrar el intervalo de confianza de la
proporción (o porcentaje) de aquellos que responden “Sí” (las 7754
personas con un 1). Ojo que la tabla muestra a 393 personas con NAs.</p>
<pre class="r"><code>lapop |&gt;
  count(ing4rec, name=&quot;Frecuencia&quot;)</code></pre>
<pre><code>##   ing4rec Frecuencia
## 1       0       6559
## 2       1       7754
## 3      NA        393</code></pre>
<p>Y queremos calcular el porcentaje de aquellos que responden “Sí” por
año de la encuesta. La variable que registra el año de la encuesta es
“wave”. Esta variable se carga como una numérica (por este motivo, en el
gráfico anterior el eje X del gráfico aparece como una variable
continua) y se tiene que transformar a una de factor llamada
“ronda”.</p>
<pre class="r"><code>lapop = lapop |&gt;
  mutate(ronda = factor(wave))</code></pre>
<p>Se calcula el apoyo a la democracia por años. Para el cálculo de esta
tabla queremos excluir a aquellos que no tienen respuesta en la variable
apoyo a la democracia (los 393 NAs anteriores). Esto lo podemos hacer
con el comando <code>filter</code>, donde especificamos que solo
queremos calcular los porcentajes de aquellos que respondieron No (o 0
en la variable) y aquellos que respondieron Sí (o 1 en la variable).</p>
<p>En cada grupo se quiere calcular el intervalo de confianza de la
proporción. Recuerden que la fórmula que se tiene que usar es la de
intervalos de confianza de la proporción.</p>
<p>Dentro del comando <code>mutate</code> calculamos el total en cada
grupo (total), la proporción (Por), el error estándar (err que es igual
a la raíz cuadrada del porcentaje por 100-porcentaje entre N) y el
límite inferior y superior del intervalo de confianza.</p>
<pre class="r"><code>tabla3 = lapop |&gt;
  filter(ing4rec ==0 | ing4rec == 1) |&gt;
  group_by(ronda) |&gt;
  count(Apoyo = ing4rec, name=&quot;N&quot;)|&gt;
  mutate(total = sum(N), 
         Por = N / total * 100, 
         err = sqrt(Por*(100-Por)/N), 
         liminf = Por - 1.96*err, 
         limsup = Por + 1.96*err)
tabla3</code></pre>
<pre><code>## # A tibble: 16 × 8
## # Groups:   ronda [8]
##    ronda Apoyo     N total   Por   err liminf limsup
##    &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 2006      0   663  1422  46.6  1.94   42.8   50.4
##  2 2006      1   759  1422  53.4  1.81   49.8   56.9
##  3 2008      0   541  1443  37.5  2.08   33.4   41.6
##  4 2008      1   902  1443  62.5  1.61   59.3   65.7
##  5 2010      0   693  1439  48.2  1.90   44.4   51.9
##  6 2010      1   746  1439  51.8  1.83   48.3   55.4
##  7 2012      0   589  1461  40.3  2.02   36.4   44.3
##  8 2012      1   872  1461  59.7  1.66   56.4   62.9
##  9 2014      0   593  1434  41.4  2.02   37.4   45.3
## 10 2014      1   841  1434  58.6  1.70   55.3   62.0
## 11 2016      0  1261  2596  48.6  1.41   45.8   51.3
## 12 2016      1  1335  2596  51.4  1.37   48.7   54.1
## 13 2018      0   759  1496  50.7  1.81   47.2   54.3
## 14 2018      1   737  1496  49.3  1.84   45.7   52.9
## 15 2021      0  1460  3022  48.3  1.31   45.7   50.9
## 16 2021      1  1562  3022  51.7  1.26   49.2   54.2</code></pre>
<p>La tabla muestra los datos de los que no apoyan a la democracia
(filas donde Apoyo=0) y de los que sí apoyan a la democracia (filas
donde Apoyo=1) por cada ronda.</p>
<p>Como solo se quiere graficar a los que sí apoyan a la democracia, se
deben eliminar todas las filas impares.</p>
<pre class="r"><code>tabla3 = tabla3[-c(1,3,5,7,9,11,13,15),]
tabla3</code></pre>
<pre><code>## # A tibble: 8 × 8
## # Groups:   ronda [8]
##   ronda Apoyo     N total   Por   err liminf limsup
##   &lt;fct&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1 2006      1   759  1422  53.4  1.81   49.8   56.9
## 2 2008      1   902  1443  62.5  1.61   59.3   65.7
## 3 2010      1   746  1439  51.8  1.83   48.3   55.4
## 4 2012      1   872  1461  59.7  1.66   56.4   62.9
## 5 2014      1   841  1434  58.6  1.70   55.3   62.0
## 6 2016      1  1335  2596  51.4  1.37   48.7   54.1
## 7 2018      1   737  1496  49.3  1.84   45.7   52.9
## 8 2021      1  1562  3022  51.7  1.26   49.2   54.2</code></pre>
<p>Ahora, tenemos los datos para graficar.</p>
<pre class="r"><code>graf4 = ggplot(tabla3, aes(x=ronda, y=Por))+
  geom_bar(stat=&quot;identity&quot;)+
  geom_errorbar(aes(ymin=liminf, ymax=limsup), width=0.2)+
  geom_text(aes(label=paste(round(Por, 1))), vjust=-1, size=4)+
  xlab(&quot;Ronda&quot;) + ylab(&quot;Porcentaje que apoya a la democracia&quot;)+
  ylim(0, 70)
graf4</code></pre>
<p><img src="clase4_files/figure-html/unnamed-chunk-46-1.png" width="672" /></p>
</div>
</div>
<div id="nota-final" class="section level1">
<h1>Nota final</h1>
<p>La comparación de IC, ya sea calculando los valores para cada grupo o
ya sea de manera gráfica, es una primera manera de analizar si las
diferencias entre grupos se pueden extrapolar a la población.</p>
<p>Pero esta es una manera “informal” de hacer esta comparación. Para
formalizar esta comparación existe una prueba estadística llamada prueba
t de diferencias de medias o la prueba de proporciones, que se verán en
la siguiente sesión.</p>
</div>
<div id="bibliografía" class="section level1 unnumbered">
<h1 class="unnumbered">Bibliografía</h1>
<div id="refs" class="references csl-bib-body hanging-indent">
<div id="ref-galarzaDetectandoDiscriminacionSexual2012"
class="csl-entry">
Galarza, Francisco, Liuba Kogan, and Gustavo Yamada. 2012.
<span>“Detectando Discriminación Sexual y Racial En El Mercado Laboral
de <span>Lima</span>.”</span> In <em>Chapters of
<span>Books</span></em>, 1:103–35. <span>Fondo Editorial, Universidad
del Pacífico</span>.
</div>
</div>
</div>

<div id="rmd-source-code">LS0tCnRpdGxlOiAiQ2xhc2UgNDogUmVjYXBpdHVsYWNpw7NuIGUgSW50ZXJ2YWxvcyBkZSBDb25maWFuemEiCmF1dGhvcjogIkFydHVybyBNYWxkb25hZG8iCmRhdGU6ICI5LzA0LzIwMjQiCm91dHB1dDoKICBodG1sX2RvY3VtZW50OgogICAgdG9jOiB0cnVlCiAgICB0b2NfZmxvYXQ6IHRydWUKICAgIGNvbGxhcHNlZDogZmFsc2UKICAgIG51bWJlcl9zZWN0aW9uczogZmFsc2UKICAgIHRvY19kZXB0aDogMQogICAgY29kZV9kb3dubG9hZDogdHJ1ZQogICAgdGhlbWU6IGNvc21vCiAgICBoaWdobGlnaHQ6IHRleHRtYXRlCmVkaXRvcl9vcHRpb25zOgogIG1hcmtkb3duOgogICAgd3JhcDogc2VudGVuY2UKYmlibGlvZ3JhcGh5OiByZWZlcmVuY2VzLmJpYgotLS0KCmBgYHtyIHNldHVwLCBpbmNsdWRlPUZBTFNFfQprbml0cjo6b3B0c19jaHVuayRzZXQoZWNobyA9IFRSVUUpCmBgYAoKIyBDYXNvIDE6IEVmZWN0aXZvcyBlbiBsYXMgQ29taXNhcmlhcyBkZWwgUGVyw7oKCipQcmVndW50YTogwr9sb3MgcG9saWPDrWFzIGVuIGVsIFBlcsO6IGVzdMOhbiBkaXN0cmlidWlkb3MgZXF1aXRhdGl2YW1lbnRlIGVudHJlIGxhcyBjb21pc2Fyw61hcyBkZWwgUGVyw7o/KgoKKsK/Q8OzbW8gY3JlZSBxdWUgZXMgZXN0YSBkaXN0cmlidWNpw7NuIGRlIGRhdG9zPyoKClBhcmEgcmVzcG9uZGVyIGEgZXN0YSBwcmVndW50YSBzZSB1c2EgbGEgYmFzZSBkZSBkYXRvcyBkZSBjb21pc2Fyw61hcyBkZWwgUGVyw7ogZGUgMjAxNy4KRXN0YSBiYXNlIGRlIGRhdG9zIGVzdMOhIGRpc3BvbmlibGUgZW4gbGEgc2VjY2nDs24gW01pY3JvZGF0b3NdKGh0dHBzOi8vcHJveWVjdG9zLmluZWkuZ29iLnBlL21pY3JvZGF0b3MvKSBkZWwgSU5FSS4KCmBgYHtyfQpsaWJyYXJ5KHJpbykgCmNvbWkxNyA9IGltcG9ydCgiYmFzZXMvY29taTIwMTcuc2F2IikKYGBgCgpFc3RhIGJhc2UgZGUgZGF0b3MgaW5jbHV5ZSBsYSBwcmVndW50YSBzb2JyZSBlbCBuw7ptZXJvIHRvdGFsIGRlIGVmZWN0aXZvcyBlbiBjYWRhIGNvbWlzYXLDrWEuCkVzdGEgdmFyaWFibGUgc2UgaW1wb3J0YSBlbiBSIGNvbW8gdW5hIHZhcmlhYmxlIG51bcOpcmljYSwgeSBlZmVjdGl2YW1lbnRlIGVzIGVsIHRpcG8gZGUgdmFyaWFibGUgY29ycmVjdG8uCgpgYGB7cn0KY2xhc3MoY29taTE3JElORjExMF9UT1QpCmBgYAoKQ29tbyBlc3RhIGVzIHVuYSB2YXJpYWJsZSBudW3DqXJpY2EsIHNlIHB1ZWRlIGRlc2NyaWJpciBtZWRpYW50ZSBsYSBtZWRpYSB5IGxhIG1lZGlhbmEuCgrCv1F1w6kgbm9zIGluZGljYW4gZXN0b3MgcmVzdWx0YWRvcz8KCmBgYHtyfQpsaWJyYXJ5KHRpZHl2ZXJzZSkKY29taTE3IHw+CiAgc3VtbWFyaXNlKE3DrW5pbW8gPSBtaW4oSU5GMTEwX1RPVCksIAogICAgICAgICAgICBNZWRpYW5hID0gbWVkaWFuKElORjExMF9UT1QpLCAKICAgICAgICAgICAgUHJvbWVkaW8gPSBtZWFuKElORjExMF9UT1QpLAogICAgICAgICAgICBNw6F4aW1vID0gbWF4KElORjExMF9UT1QpKQpgYGAKClNlIHB1ZWRlIGdyYWZpY2FyIGxhIGRpc3RyaWJ1Y2nDs24gZGVsIG7Dum1lcm8gZGUgZWZlY3Rpdm9zIHBvciBjb21pc2FyaWFzIG1lZGlhbnRlIHVuIGhpc3RvZ3JhbWEuCsK/UXXDqSBub3MgaW5kaWNhIGVsIGdyw6FmaWNvPwoKYGBge3J9CmxpYnJhcnkoZ2dwbG90MikKZ2dwbG90KGNvbWkxNywgYWVzKHg9SU5GMTEwX1RPVCkpKwogIGdlb21faGlzdG9ncmFtKCkrCiAgeGxhYigiTsO6bWVybyBkZSBlZmVjdGl2b3MiKSArCiAgeWxhYigiRnJlY3VlbmNpYSIpKwogIHRoZW1lX2xpZ2h0KCkKYGBgCgpTZSBwdWVkZSBpbmNsdWlyIGVsIGRhdG8gZGUgbGEgbWVkaWEgeSBsYSBtZWRpYW5hIGVuIGVzdGUgZ3LDoWZpY28uCsK/Q8OzbW8gc2UgaW50ZXJwcmV0YSBsYSBwb3NpY2nDs24gcmVsYXRpdmEgZGUgYW1iYXMgbWVkaWRhcz8KCmBgYHtyfQpnZ3Bsb3QoY29taTE3LCBhZXMoeD1JTkYxMTBfVE9UKSkrCiAgZ2VvbV9oaXN0b2dyYW0oKSsKICBnZW9tX3ZsaW5lKHhpbnRlcmNlcHQgPSAxOSwgY29sb3IgPSAicmVkIikrCiAgZ2VvbV92bGluZSh4aW50ZXJjZXB0ID0gMzEuNiwgY29sb3IgPSAiZ3JlZW4iKSsKICB4bGFiKCJOw7ptZXJvIGRlIGVmZWN0aXZvcyIpICsKICB5bGFiKCJGcmVjdWVuY2lhIikrCiAgdGhlbWVfbGlnaHQoKQpgYGAKCkFob3JhIHNlIHF1aWVyZSB2ZXIgc2kgZXhpc3RlbiBkaWZlcmVuY2lhcyBlbiBlbCBuw7ptZXJvIHByb21lZGlvIGRlIGVmZWN0aXZvcyBwb2xpY2lhbGVzIGVuIGxhcyBjb21pc2Fyw61hcyBkZWwgUGVyw7ogZW50cmUgZGVwYXJ0YW1lbnRvcyBvIGVudHJlIHJlZ2lvbmVzLgpBIHBlc2FyIHF1ZSBlbiBmb3JtdWxhcmlvIHNlIHJlY29nZSBlbCBkYXRvIGRlIERlcGFydGFtZW50bywgUHJvdmluY2lhIHkgRGlzdHJpdG8sIGVuIGxhIGJhc2UgZGUgZGF0b3Mgbm8gc2UgY3VlbnRhIGNvbiBlc2EgaW5mb3JtYWNpw7NuLgpMbyBxdWUgc2UgdGllbmUgZXMgdW5hIHZhcmlhYmxlIGxsYW1hZGEgInViaWdlbyIuCkVzdGEgdmFyaWFibGUgZXN0w6EgZXN0YW5kYXJpemFkYSBkZSB0YWwgbWFuZXJhIHF1ZSBsb3MgZG9zIHByaW1lcm9zIGTDrWdpdG9zIGNvcnJlc3BvbmRlbiBhbCBkZXBhcnRhbWVudG8sIGxvcyBzZWd1bmRvcyBkb3MgZMOtZ2l0b3MgYSBsYXMgcHJvdmluY2lhcyB5IGxvcyDDumx0aW1vcyBkb3MgZMOtZ2l0b3MgYWwgZGlzdHJpdG8uClBvciBsbyB0YW50bywgcGFyYSBzYWJlciBlbiBxdcOpIGRlcGFydGFtZW50byBlc3TDoSBsYSBjb21pc2Fyw61hIHNlIHJlcXVpZXJlIHNlcGFyYXIgbG9zIHByaW1lcm9zIGRvcyBkw61naXRvcyB5IGd1YXJkYXJsb3MgZW4gdW5hIG51ZXZhIHZhcmlhYmxlLgoKYGBge3J9CmNvbWkxNyA8LSBjb21pMTcgJT4lCiAgbXV0YXRlKGRwdG8gPSBzdHJfc3ViKFVCSUdFTywgMSwgMikpCmBgYAoKQ29waWFtb3MgZWwgY8OzZGlnbyB1c2FkbyBwYXJhIGVsIHZvdG8gMjAxNiB5IGxvIGFkYXB0YW1vcyBhIGxhcyBuZWNlc2lkYWRlcyBkZSBlc3RhIGJhc2UgZGUgZGF0b3MuCkxhIHZhcmlhYmxlICJkcHRvIiBlcyB1bmEgdmFyaWFibGUgZGUgdGlwbyAiY2hhcmFjdGVyIiB5IHNhYmVtb3MgcXVlIHZhIGRlc2RlIGVsICIwMSIgYWwgIjI1IiwgcmVwcmVzZW50YW5kbyBjYWRhICJuw7ptZXJvIiB1biBkZXBhcnRhbWVudG8gZGVsIFBlcsO6LCBxdWUgaGVtb3MgYXNvY2lhZG8gYSBDb3N0YSA9IDEsIFNpZXJyYSA9IDIgbyBTZWx2YSA9IDMuCgpFbnRvbmNlcyBsbyBxdWUgdGVuZW1vcyBxdWUgaGFsbGFyIGVzIGVsIGPDs2RpZ28gdWJpZ2VvIGRlIGNhZGEgZGVwYXJ0YW1lbnRvIHkgcmVlbXBsYXphcmxvIHBvciBlbCBub21icmUgZGVsIGRlcGFydGFtZW50byBlbiBlbCBjw7NkaWdvIG9yaWdpbmFsLgpMYSBjbGFzaWZpY2FjacOzbiBsYSBndWFyZGFtb3MgZW4gb3RyYSB2YXJpYWJsZSAicmVnaW9uIi4KCmBgYHtyfQpjb21pMTcgPSBjb21pMTcgJT4lCiAgbXV0YXRlKHJlZ2lvbiA9IGNhc2Vfd2hlbigKICAgIGRwdG89PSIwMSJ+MywKICAgIGRwdG89PSIwMiJ+MiwKICAgIGRwdG89PSIwMyJ+MiwKICAgIGRwdG89PSIwNCJ+MiwKICAgIGRwdG89PSIwNSJ+MiwKICAgIGRwdG89PSIwNiJ+MiwKICAgIGRwdG89PSIwOCJ+MiwKICAgIGRwdG89PSIwNyJ+MSwKICAgIGRwdG89PSIwOSJ+MiwKICAgIGRwdG89PSIxMCJ+MywKICAgIGRwdG89PSIxMSJ+MSwKICAgIGRwdG89PSIxMiJ+MiwKICAgIGRwdG89PSIxMyJ+MSwKICAgIGRwdG89PSIxNCJ+MSwKICAgIGRwdG89PSIxNSJ+MSwKICAgIGRwdG89PSIxNiJ+MywKICAgIGRwdG89PSIxNyJ+MywKICAgIGRwdG89PSIxOCJ+MSwKICAgIGRwdG89PSIxOSJ+MiwKICAgIGRwdG89PSIyMCJ+MSwKICAgIGRwdG89PSIyMSJ+MiwKICAgIGRwdG89PSIyMiJ+MywKICAgIGRwdG89PSIyMyJ+MSwKICAgIGRwdG89PSIyNCJ+MSwKICAgIGRwdG89PSIyNSJ+MwogICkpIApgYGAKCkVzdGEgdmFyaWFibGUgInJlZ2lvbiIgZXMgZGUgdGlwbyBudW3DqXJpY28sIHBlcm8gbG9zIGPDs2RpZ29zICgxLCAyIHkgMykgbm8gc29uIG7Dum1lcm9zLCBzaW5vIGPDs2RpZ29zIHBhcmEgQ29zdGEsIFNpZXJyYSB5IFNlbHZhLCBwb3IgbG8gcXVlIHRlbmVtb3MgcXVlIGNyZWFyIG90cmEgdmFyaWFibGUsICJyZWdpb24yIiBxdWUgc2VhIGRlIHRpcG8gImZhY3RvciIgY29uIGxhcyBldGlxdWV0YXMgY29ycmVzcG9uZGllbnRlcy4KCmBgYHtyfQpsaWJyYXJ5KGZvcmNhdHMpCmNvbWkxNyA9IGNvbWkxNyAlPiUKICBtdXRhdGUocmVnaW9uMiA9IGZhY3RvcihyZWdpb24sIGxhYmVscz1jKCJDb3N0YSIsICJTaWVycmEiLCAiU2VsdmEiKSkpCmBgYAoKUG9kZW1vcyB1c2FyIGVzdGEgdmFyaWFibGUgcGFyYSBjYWxjdWxhciBsb3MgZGVzY3JpcHRpdm9zIGRlbCBuw7ptZXJvIGRlIGVmZWN0aXZvcyBwb3IgcmVnacOzbi4Kwr9RdcOpIGNvbmNsdXNpw7NuIHNhY2EgZGUgbGEgdGFibGE/CgpgYGB7cn0KdGFibGExID0gY29taTE3ICU+JQogIGdyb3VwX2J5KHJlZ2lvbjIpICU+JQogIHN1bW1hcmlzZShNw61uaW1vID0gbWluKElORjExMF9UT1QpLCAKICAgICAgICAgICAgTWVkaWFuYSA9IG1lZGlhbihJTkYxMTBfVE9UKSwgCiAgICAgICAgICAgIFByb21lZGlvID0gbWVhbihJTkYxMTBfVE9UKSwKICAgICAgICAgICAgRGVzdiA9IHNkKElORjExMF9UT1QpLAogICAgICAgICAgICBNw6F4aW1vID0gbWF4KElORjExMF9UT1QpKQp0YWJsYTEKYGBgCgpFc3RhIHRhYmxhIHNpcnZlIHBhcmEgY29tcGFyYXIgbG9zIGRhdG9zIGRlc2NyaXB0aXZvcyBwb3IgZ3J1cG9zIGRlIG90cmEgdmFyaWFibGUuCkFsZ28gc2ltaWxhciBzZSBwdWVkZSBoYWNlciBjb24gZWwgZ3LDoWZpY28gZGUgY2FqYXMsIHBlcm8gY29tcGFyYW5kbyBtZWRpYW5hcyB5IHJhbmdvcyBpbnRlcmN1YXJ0aWxlcy4KCmBgYHtyfQpnZ3Bsb3QoY29taTE3LCBhZXMoeT1JTkYxMTBfVE9ULCB4PXJlZ2lvbjIpKSsKICBnZW9tX2JveHBsb3QoKSsKICB5bGFiKCJOw7ptZXJvIGRlIGVmZWN0aXZvcyIpKwogIHhsYWIoIlJlZ2nDs24iKSsKICB0aGVtZV9nZXQoKQpgYGAKCiMgQ2FzbyAyOiBTZXJ2aWNpb3MgYsOhc2ljb3MgZW4gbGFzIGNvbWlzYXLDrWFzIGRlbCBQZXLDugoKKlByZWd1bnRhOiDCv0xhcyBjb21pc2Fyw61hcyBkZWwgUGVyw7ogY3VlbnRhbiBjb24gbG9zIHNlcnZpY2lvcyBiw6FzaWNvcz8gwr9DdWVudGFuIGNvbiBpbnRlcm5ldD8qCgpQYXJhIHJlc3BvbmRlciBlc3RhcyBwcmVndW50YXMsIGxhIEVuY3Vlc3RhIE5hY2lvbmFsIGRlIENvbWlzYXLDrWFzIGRlIDIwMTcgdGllbmUgb3RybyBtw7NkdWxvIHNvYnJlIGluZnJhZXN0cnVjdHVyYS4KQ2FyZ2Ftb3MgZXNhIGJhc2UgZGUgZGF0b3MuCgpgYGB7cn0KY29taTE3XzIgPSBpbXBvcnQoImJhc2VzL2NvbWkyMDE3XzIuc2F2IikKYGBgCgpFc3RhIGJhc2UgaW5jbHV5ZSBsYSBwcmVndW50YSBJTkYyMTYgc29icmUgbHV6IGVsw6ljdHJpY2EsIGxhIHByZWd1bnRhIElORjIyNSBzb2JyZSBhZ3VhIHBvdGFibGUsIGxhIHByZWd1bnRhIElORjIzMCBzb2JyZSBkZXNhZ8O8ZSB5IGxhIHByZWd1bnRhIElORjI2NF9FIHNvYnJlIGVsIHNlcnZpY2lvIGRlIGludGVybmV0LgoKRW4gcHJpbWVyIGx1Z2FyIHZlcmlmaWNhbW9zIGPDs21vIHNlIGltcG9ydGFuIGxhcyB2YXJpYWJsZXMuClZlbW9zIHF1ZSBzZSBpbXBvcnRhbiBjb21vIHZhcmlhYmxlcyBudW3DqXJpY2FzLgpMYSB2YXJpYWJsZSBzb2JyZSBsdXogdGllbmUgb3BjaW9uZXMgU2kgPSAxIHkgTm8gPSAyLgpFc3RhIHZhcmlhYmxlIGVzIGVuIHJlYWxpZGFkIHVuYSBkZSB0aXBvIGZhY3Rvci4KCmBgYHtyfQpjbGFzcyhjb21pMTdfMiRJTkYyMTYpCnRhYmxlKGNvbWkxN18yJElORjIxNikKYGBgCgpTZSBwcm9jZWRlIGEgY3JlYXIgb3RyYSB2YXJpYWJsZSAibHV6IiwgY29tbyBsYSBmYWN0b3JpemFjacOzbiBkZSBJTkYyMTYgY29uIGV0aXF1ZXRhcyBTw60geSBOby4KCmBgYHtyfQpjb21pMTdfMiA9IGNvbWkxN18yICU+JQogIG11dGF0ZShsdXogPSBmYWN0b3IoSU5GMjE2LCBsYWJlbHM9YygiU8OtIiwgIk5vIikpKQpgYGAKCkVzdGEgdmFyaWFibGUgaW5jbHV5ZSBhbGd1bmFzIGNvbWlzYXLDrWFzIGRvbmRlIG5vIHNlIHRpZW5lIGVsIGRhdG8sIHBvciBsbyBxdWUgY3VhbmRvIHNlIGNhbGN1bGEgbGEgdGFibGEsIHNlIGZpbHRyYSBzb2xvIGxhcyByZXNwdWVzdGFzIFPDrSB5IE5vLgpTZSBndWFyZGEgbG9zIHJlc3VsdGFkb3MgZW4gdW4gb2JqZXRvICJ0YWJsYTIiLgoKYGBge3J9CnRhYmxhMiA9IGNvbWkxN18yICU+JQogIGZpbHRlcihsdXogPT0gIlPDrSIgfCBsdXogPT0gIk5vIikgJT4lCiAgY291bnQoTHV6ID0gbHV6LCBuYW1lPSJGcmVjdWVuY2lhIikKdGFibGEyCmBgYAoKU2UgYcOxYWRlIGEgZXN0ZSBtaXNtbyBvYmpldG8gbG9zIHBvcmNlbnRhamVzLgrCv1F1w6kgY29uY2x1c2lvbmVzIHNhY2EgZGUgZXN0b3MgcmVzdWx0YWRvcz8KCmBgYHtyfQp0YWJsYTIgPSB0YWJsYTIgJT4lCiAgbXV0YXRlKFBvcmNlbnRhamUgPSAoRnJlY3VlbmNpYSAvIHN1bShGcmVjdWVuY2lhKSoxMDAgKSkKdGFibGEyCmBgYAoKU2UgaGFjZSBlbCBtaXNtbyBwcm9jZWRpbWllbnRvIGNvbiBsYSB2YXJpYWJsZSBzb2JyZSBhZ3VhIHBvdGFibGUuCkVuIGVzdGUgY2FzbywgbGEgdmFyaWFibGUgdGllbmUgY2luY28gdmFsb3Jlcy4KCmBgYHtyfQpjbGFzcyhjb21pMTdfMiRJTkYyMjUpCnRhYmxlKGNvbWkxN18yJElORjIyNSkKYGBgCgpgYGB7cn0KY29taTE3XzIgPSBjb21pMTdfMiAlPiUKICBtdXRhdGUoYWd1YSA9IGZhY3RvcihJTkYyMjUsIGxhYmVscz1jKCJSZWQgcMO6YmxpY2EgZGVudHJvIGRlbCBsb2NhbCIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkNhbWnDs24gY2lzdGVybmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlBvem8iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlLDrW8sIGFjZXF1aWEgbyBtYW5hbnRpYWwiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIk90cm8iKSkpCnRhYmxlKGNvbWkxN18yJGFndWEpCmBgYAoKU2UgY2FsY3VsYSBsYSB0YWJsYSBkZSBkaXN0cmlidWNpw7NuIGRlIGZyZWN1ZW5jaWFzLCBjb24gZWwgY8OhbGN1bG8gZGUgbG9zIHBvcmNlbnRhamVzIGVuIGVsIG1pc21vIGPDs2RpZ28uCsK/UXXDqSBjb25jbHVzaW9uZXMgc2FjYSBkZSBlc3RvcyByZXN1bHRhZG9zPwoKYGBge3J9CnRhYmxhMyA9IGNvbWkxN18yICU+JQogIGNvdW50KEFndWEgPSBhZ3VhLCBuYW1lPSJGcmVjdWVuY2lhIikgJT4lCiAgbXV0YXRlKFBvcmNlbnRhamUgPSAoRnJlY3VlbmNpYSAvIHN1bShGcmVjdWVuY2lhKSoxMDAgKSkKdGFibGEzCmBgYAoKU2UgaGFjZSBlbCBtaXNtbyBwcm9jZWRpbWllbnRvIGNvbiBsYSB2YXJpYWJsZSBzb2JyZSBkZXNhZ8O8ZS4KCmBgYHtyfQpjbGFzcyhjb21pMTdfMiRJTkYyMzApCnRhYmxlKGNvbWkxN18yJElORjIzMCkKYGBgCgpgYGB7cn0KY29taTE3XzIgPSBjb21pMTdfMiAlPiUKICBtdXRhdGUoZGVzYWd1ZSA9IGZhY3RvcihJTkYyMzAsIGxhYmVscz1jKCJSZWQgcMO6YmxpY2EgZGVudHJvIGRlbCBsb2NhbCIsIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlBvem8gc8OpcHRpY28iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIkxldHJpbmEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIk90cm8iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIk5vIHRpZW5lIGJhw7FvIikpKQp0YWJsZShjb21pMTdfMiRkZXNhZ3VlKQpgYGAKCsK/UXXDqSBjb25jbHVzaW9uZXMgc2FjYSBkZSBlc3RvcyByZXN1bHRhZG9zPwoKYGBge3J9CnRhYmxhNCA9IGNvbWkxN18yICU+JQogIGNvdW50KERlc2FndWUgPSBkZXNhZ3VlLCBuYW1lPSJGcmVjdWVuY2lhIikgJT4lCiAgbXV0YXRlKFBvcmNlbnRhamUgPSAoRnJlY3VlbmNpYSAvIHN1bShGcmVjdWVuY2lhKSoxMDAgKSkKdGFibGE0CmBgYAoKRmluYWxtZW50ZSwgc2UgaGFjZSBsbyBtaXNtbyBwYXJhIGxhIHByZWd1bnRhIHNvYnJlIGludGVybmV0LgoKYGBge3J9CmNsYXNzKGNvbWkxN18yJElORjI2NF9FKQp0YWJsZShjb21pMTdfMiRJTkYyNjRfRSkKYGBgCgpgYGB7cn0KY29taTE3XzIgPSBjb21pMTdfMiAlPiUKICBtdXRhdGUoaW50ZXJuZXQgPSBmYWN0b3IoSU5GMjY0X0UsIGxhYmVscz1jKCJTw60sIHBhZ28gcGVuZGllbnRlIiwgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiU8OtLCBwYWdvIGFsIGTDrWEiLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIlPDrSwgbm8gc2FiZSBkZWwgcGFnbyIsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAiTm8gY3VlbnRhIGNvbiBlbCBzZXJ2aWNpbyIpKSkKdGFibGUoY29taTE3XzIkaW50ZXJuZXQpCmBgYAoKwr9RdcOpIGNvbmNsdXNpb25lcyBzYWNhIHNvYnJlIGVzdG9zIHJlc3VsdGFkb3M/CgpgYGB7cn0KdGFibGE1ID0gY29taTE3XzIgJT4lCiAgY291bnQoSW50ZXJuZXQgPSBpbnRlcm5ldCwgbmFtZT0iRnJlY3VlbmNpYSIpICU+JQogIG11dGF0ZShQb3JjZW50YWplID0gKEZyZWN1ZW5jaWEgLyBzdW0oRnJlY3VlbmNpYSkqMTAwICkpCnRhYmxhNQpgYGAKCkVzdGUgdGlwbyBkZSB2YXJpYWJsZXMsIGRlIHRpcG8gZmFjdG9yLCBzZSBwdWVkZSB2aXN1YWxpemFyIGNvbiBncsOhZmljb3MgZGUgYmFycmFzLgoKYGBge3J9CmdyYWYxID0gZ2dwbG90KHRhYmxhNSwgYWVzKHg9SW50ZXJuZXQsIHk9UG9yY2VudGFqZSkpKwogIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5IikrCiAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZShyb3VuZChQb3JjZW50YWplLCAxKSkpLCB2anVzdD0tMSwgc2l6ZT0zKSsKICBsYWJzKHg9IkludGVybmV0IiwgeT0iUG9yY2VudGFqZSIpKwogIHRoZW1lX2NsYXNzaWMoKQpncmFmMQpgYGAKCiMjIFRhcmVhCgpDYWxjdWxlIGxhcyB0YWJsYXMgZGUgZGlzdHJpYnVjacOzbiBkZSBmcmVjdWVuY2lhcyBkZSBsdXogeSBkZSBpbnRlcm5ldCBwb3IgcmVnaW9uZXMuCkdyYWZpcXVlLgoKIyBQcnVlYmFzIGRlIHNpZ25pZmljYW5jaWEKCkVzIHVuYSBkZSBsYXMgdMOpY25pY2FzIG3DoXMgdXNhZGFzIHBhcmEgZWwgYW7DoWxpc2lzIGVuIGNpZW5jaWFzIHNvY2lhbGVzLgpTaXJ2ZSwgcG9yIGVqZW1wbG8sIHBhcmEgY29tcGFyYXIgZW50cmUgZ3J1cG9zOgoKLSAgIENvbXBhcmFyIGxhIG1lZGlhIGRlIGluZ3Jlc29zIGRlIGhvbWJyZXMgeSBtdWplcmVzCgotICAgQ29tcGFyYXIgbGEgcHJvcG9yY2nDs24gZGUgcGVyc29uYXMgcXVlIHZvdGFyw6FuIGEgY2FuZGlkYXRvIFggZW4gTGltYSB5IGVuIFJlZ2lvbmVzCgotICAgQ29tcGFyYXIgbG9zIGluZ3Jlc29zIGRlIHByb2Zlc29yZXMgZW4gbGEgZ2VzdGnDs24gcMO6YmxpY2EgeSBlbiBsYSBnZXN0acOzbiBwcml2YWRhCgpMYSBpZGVhIGVzIGNvbXBhcmFyIGxhcyBlc3RpbWFjaW9uZXMgcHVudHVhbGVzIGVudHJlIGFtYm9zIGdydXBvcyB5IHRhbWJpw6luIHBvZGVyIGV4dHJhcG9sYXIgZXN0YXMgZGlmZXJlbmNpYXMgYSBsYSBwb2JsYWNpw7NuLgoKVmFtb3MgYSBjb21lbnphciBwb3IgY29tcGFyYWNpb25lcyBlbnRyZSBzb2xvIDIgZ3J1cG9zIChwb3IgZWwgbW9tZW50byksIHF1ZSBjb3JyZXNwb25kZSBhIHVuYSB2YXJpYWJsZSBiaW5hcmlhIG8gZGljb3TDs21pY2EsIGNvbW8gc2V4byAoaG9tYnJlcy9tdWplcmVzKSwgw6FtYml0byAodXJiYW5vL3J1cmFsKSwgZ2VzdGnDs24gZWR1Y2F0aXZhIChww7pibGljYS9wcml2YWRhKS4KClBhcmEgbW9zdHJhciB1biBlamVtcGxvLCB2YW1vcyBhIHVzYXIgZWwgdHJhYmFqbyBkZSBbQGdhbGFyemFEZXRlY3RhbmRvRGlzY3JpbWluYWNpb25TZXh1YWwyMDEyXSBxdWUgZXZhbMO6YSBsYSBkaXNjcmltaW5hY2nDs24gZW4gZWwgbWVyY2FkbyBsYWJvcmFyIGVudHJlIGhvbWJyZXMgeSBtdWplcmVzLgpFc3RvcyBhdXRvcmVzIGVudmlhcm9uIENWcyBjb24gZXhhY3RhcyBjdWFsaWZpY2FjaW9uZXMgYSBvZmVydGFzIHJlYWxlcyBkZSB0cmFiYWpvLCB2YXJpYW5kbyBzb2xvIGVsIG5vbWJyZSBkZWwgYXBsaWNhbnRlLCBjb24gbm9tYnJlcyBkZSBob21icmVzIHkgbXVqZXJlcy4KTGEgdmFyaWFibGUgZGUgcmVzcHVlc3RhIGVzIGxhIHRhc2EgZGUgcmVzcHVlc3RhIGEgZXN0b3MgQ1ZzLCBlcyBkZWNpciwgZGUgY3XDoW50b3MgQ1ZzIGVudmlhZG9zIHNlIHJlY2liacOzIHVuYSBsbGFtYWRhIHBhcmEgdW5hIGVudHJldmlzdGEuCgpFbiBjdWFscXVpZXIgcHJ1ZWJhIGRlIHNpZ25pZmljYW5jaWEgc2UgdGllbmUgcXVlIHByZXNlbnRhciB1bmEgaGlww7N0ZXNpcyBudWxhLCBxdWUgZ2VuZXJhbG1lbnRlIGVzIGxhIGhpcMOzdGVzaXMgZGUgbm8gZGlmZXJlbmNpYXMgbyBkZSBubyBlZmVjdG9zLgpFc3RlIHRyYWJham8gcGFydGUgZGUgdW5hIGlkZWEgcXVlIGV4aXN0ZSB1bmEgZGlzY3JpbWluYWNpw7NuIGRlIGfDqW5lcm8gZW4gZWwgbWVyY2FkbyBsYWJvcmFsLCBwb3IgbG8gcXVlIGxhIGhpcMOzdGVzaXMgbnVsYSBpbmRpY2Fyw61hIGxvIGNvbnRyYXJpby4KRW4gZWwgY2FzbyBkZSBlc3RlIHRyYWJham8gc2UgdGVuZHLDrWE6CgpIMDogVGFzYSBkZSByZXNwdWVzdGEgYSBDVnMgZGUgaG9tYnJlcyA9IFRhc2EgZGUgcmVzcHVlc3RhIGEgQ1ZzIGRlIG11amVyZXMKCm8gbG8gcXVlIGVzIGxvIG1pc21vCgpIMDogVGFzYSBkZSByZXNwdWVzdGEgYSBDVnMgZGUgaG9tYnJlcyAtIFRhc2EgZGUgcmVzcHVlc3RhIGEgQ1ZzIGRlIG11amVyZXMgPSAwCgpFbiBlc2UgdHJhYmFqbyBzZSBwcmVzZW50YSBlbCBzaWd1aWVudGUgY3VhZHJvIGRlIHJlc3VsdGFkb3M6CgohW10oR2FsYXJ6YS5wbmcpe3dpZHRoPSI0MzUifQoKRW4gbGEgbXVlc3RyYSB0b3RhbCBkZSAyLDIyOCBDVnMgZW52aWFkb3MsIG1pdGFkIGRlIENWcyBjb24gbm9tYnJlcyBkZSBob21icmVzIHkgbGEgb3RyYSBtaXRhZCBjb24gbm9tYnJlcyBkZSBtdWplcmVzLCB0b2RvcyBjb24gbGFzIG1pc21hcyBjdWFsaWZpY2FjaW9ucywgc2UgdGllbmUgcXVlIGxhIHRhc2EgZGUgcmVzcHVlc3RhIHBhcmEgbG9zIENWcyBkZSBob21icmVzIGVzIDEzLjQlIHkgcGFyYSBsb3MgQ1ZzIGRlIG11amVyZXMgZXMgMTEuMSUuCgpEZSBhY3VlcmRvIGEgbGFzIGVzdGltYWNpb25lcyBwdW50dWFsZXMsIGVmZWN0aXZhbWVudGUsIGxvcyBob21icmVzIHRpZW5lbiB1bmEgbWF5b3IgdGFzYSBkZSByZXNwdWVzdGEgYSBzdXMgQ1ZzIHF1ZSBsYXMgbXVqZXJlcywgYSBpZ3VhbGVzIGN1YWxpZmljYWNpb25lcy4KRXN0YSBjb25jbHVzacOzbiwgc2luIGVtYmFyZ28sIGVzIHNvbG8gcGFyYSBsYXMgMiwyMjggb2JzZXJ2YWNpb25lcyBkZSBsYSBtdWVzdHJhLgrCv0PDs21vIGV4dHJhcG9sYXIgZXN0YSBjb25jbHVzacOzbiBhIGxhIHBvYmxhY2nDs24/CsK/VG9kYSBkaWZlcmVuY2lhIHB1bnR1YWwgc2UgdmFsaWRhcsOtYSBlbiBsYSBwb2JsYWNpw7NuPwoKIyBDb21wYXJhY2nDs24gZGUgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgcG9yIGdydXBvcwoKVW5hIHByaW1lcmEgZm9ybWEgImluZm9ybWFsIiBwYXJhIGV4dHJhcG9sYXIgbGFzIGRpZmVyZW5jaWFzIGVuIGxhcyBlc3RpbWFjaW9uZXMgcHVudHVhbGVzIGRlIGxhIG11ZXN0cmEgYSBsYSBwb2JsYWNpw7NuIGVzIGNvbnN0cnV5ZW5kbyBsb3MgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgcGFyYSBsYSBtZWRpYSBvIHBhcmEgbGEgcHJvcG9yY2nDs24gcG9yIGNhZGEgdW5vIGRlIGxvcyBzdWJncnVwb3MuCgpFbiBlc3RlIGNhc28sIHBvciBlamVtcGxvLCBzaWduaWZpY2Fyw61hIGNvbnN0cnVpciBlbCBJQyBkZSBsYSB0YXNhIGRlIHJlc3B1ZXN0YSBwYXJhIGhvbWJyZSB5IG11amVyZXMuCgpQcmVndW50YTogwr9TZSBwdWVkZW4gY29uc3RydWlyIGxvcyBJQyBkZSBjYWRhIGdydXBvIGNvbiBsb3MgZGF0b3MgZGUgbGEgdGFibGE/CgpDYWRhIElDIHNlcsOtYSB1bmEgZXh0cmFwb2xhY2nDs24gZGVsIHBhcsOhbWV0cm8sIGVzIGRlY2lyLCBlbCByYW5nbyBkZSB2YWxvcmVzIGRlIGxhIHRhc2EgZGUgcmVzcHVlc3RhIGEgbG9zIENWcyBkZSBob21icmVzIHBhcmEgdG9kbyBlbCBtZXJjYWRvIGxhYm9yYWwgYWwgOTUlIGRlIGNvbmZpYW56YS4KTG8gbWlzbW8gcGFyYSBsYSB0YXNhIGRlIHJlc3B1ZXN0YSBkZSBsYXMgbXVqZXJlcy4KClVuYSB2ZXogY29uc3RydWlkb3MgbG9zIElDLCBzZSBhbmFsaXphIHNpIGVzdG9zIGludGVydmFsb3Mgc2UgY3J1emFuIG8gbm8gc2UgY3J1emFuLgpMYSByZWdsYSBkZSBkZWNpc2nDs24gImluZm9ybWFsIiBlczoKCi0gICBTaSBsb3MgSUMgZGUgYW1ib3MgZ3J1cG9zIHNlIGNydXphbiwgZW50b25jZXMgbm8gc2UgcHVlZGUgYWZpcm1hciBxdWUgZWwgcGFyw6FtZXRybyBkZSB1biBncnVwbyBzZWEgbWF5b3IgbyBtZW5vcyBxdWUgZWwgcGFyw6FtZXRybyBkZWwgb3RybyBncnVwby4KCi0gICBTaSBsb3MgSUMgZGUgYW1ib3MgZ3J1cG9zIE5PIHNlIGNydXphbiwgZW50b25jZXMgc2UgcHVlZGUgYWZpcm1hciwgYWwgOTUlIGRlIGNvbmZpYW56YSwgcXVlIGVsIHBhcsOhbWV0cm8gZGUgdW4gZ3J1cG8gZXMgbWF5b3IvbWVub3IgYWwgcGFyw6FtZXRybyBkZWwgb3RybyBncnVwby4KCiMgRWplbXBsbyAxIHBhcmEgdW5hIHZhcmlhYmxlIG51bcOpcmljYTogRU5ETwoKKlByZWd1bnRhOiDCv2EgY3XDoW50b3MgYWx1bW5vcyBlbiBwcm9tZWRpbyBhdGllbmRlIHVuIHByb2Zlc29yIHBlcnVhbm8/IMK/RXhpc3RlbiBkaWZlcmVuY2lhcyBkZSBnw6luZXJvPyoKClVzYW5kbyBlbCBlamVtcGxvIGRlIGxhIEVORE8gMjAyMCwgbGEgaGlww7N0ZXNpcyBxdWUgc2UgcHVlZGUgZXZhbHVhciBlcyBzaSBsb3MgcHJvZmVzb3JlcyBhdGllbmRlbiBhIGRpZmVyZW50ZSBuw7ptZXJvIGRlIGFsdW1ub3MgZGUgYWN1ZXJkbyBhIHN1IHNleG8uCkNvbW8gdmltb3MgYW50ZXMsIGxhcyBjb21wYXJhY2lvbmVzIHB1bnR1YWxlcyBzdWdpZXJlbiBkaWZlcmVuY2lhcywgZG9uZGUgbG9zIGRvY2VudGVzIGhvbWJyZXMgYXRpZW5kZW4gYSBtw6FzIGFsdW1ub3MgcXVlIGxhcyBkb2NlbnRlcyBtdWplcmVzLgoKTGEgaGlww7N0ZXNpcyBjZXJvIHNlcsOtYToKCkhvOiBQcm9tZWRpbyBkZSBhbHVtbm9zIHF1ZSBhY29tcGHDsWEgdW4gZG9jZW50ZSBob21icmUgPSBQcm9tZWRpbyBkZSBhbHVtbm9zIHF1ZSBhY29tcGHDsWEgdW5hIGRvY2VudGUgbXVqZXIuCgpgYGB7ciBlbmRvLCBtZXNzYWdlPUZBTFNFLCB3YXJuaW5nPUZBTFNFfQpsaWJyYXJ5KHJpbykKZW5kbzIwMjAgPSBpbXBvcnQoImJhc2VzL0VORE9fUkVNT1RPXzIwMjAuZHRhIikKYGBgCgpMYSB2YXJpYWJsZSBQMV8xIChzZXhvIGRlbCBkb2NlbnRlKSBlc3TDoSBkZWZpbmlkYSBvcmlnaW5hbG1lbnRlIGNvbW8gdW5hIHZhcmlhYmxlIG51bcOpcmljYSAoZXN0byBzZSBwdWVkZSBjb21wcm9iYXIgY29uIGVsIGPDs2RpZ28gYHN0cihlbmRvMjAyMCRQMV8xKWAuCkVzdGEgdmFyaWFibGUsIHNpbiBlbWJhcmdvIGVzIGRlIHRpcG8gZmFjdG9yLgoKU2UgcHVlZGUgY3JlYXIgdW5hIG51ZXZhIHZhcmlhYmxlICJzZXhvIiBjb24gbGEgdmFyaWFibGUgdHJhbnNmb3JtYWRhIHkgZXRpcXVldGFkYS4KCmBgYHtyIG1lZGlhcywgbWVzc2FnZT1GQUxTRSwgd2FybmluZz1GQUxTRX0KbGlicmFyeShkcGx5cikKbGlicmFyeSh0aWR5dmVyc2UpCmVuZG8yMDIwID0gZW5kbzIwMjAgfD4KICBtdXRhdGUoc2V4byA9IGZhY3RvcihQMV8xLCBsYWJlbHM9YygiSG9tYnJlIiwgIk11amVyIikpKQpgYGAKCmBgYHtyfQphbHVteHNleG8gPSBlbmRvMjAyMCB8PiAKICBncm91cF9ieShzZXhvKSB8PgogIHN1bW1hcml6ZShNZWRpYSA9IG1lYW4oUDFfNiwgbmEucm0gPSBUKSwgCiAgICAgICAgICAgIERlc3YuU3RkID0gc2QoUDFfNiwgbmEucm0gPSBUKSkKYWx1bXhzZXhvCmBgYAoKU2UgZW5jdWVudHJhIHF1ZSBsb3MgZG9jZW50ZXMgaG9tYnJlcyBhY29tcGHDsWFuIGEgNTIgYWx1bW5vcyBlbiBwcm9tZWRpbywgZW4gY29tcGFyYWNpw7NuIGNvbiBsYXMgZG9jZW50ZXMgbXVqZXJlcyBxdWUgYWNvbXBhw7FhbiBhIDM0IGFsdW1ub3MgZW4gcHJvbWVkaW8sIGVzIGRlY2lyIDE4IGFsdW1ub3MgbWVub3MgZW4gcHJvbWVkaW8uCgpSZWNvcmRlbW9zIHF1ZSBlbCBjw6FsY3VsbyBkZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBkZSB1bmEgbWVkaWEgZXM6CgokJApJQyA9ICBcYmFye1h9IFxwbSAxLjk2ICogXGZyYWN7c30ge1xzcXJ0e259fQokJAoKUGFyYSB1bmEgY29tcGFyYWNpw7NuIHVzYW5kbyBsb3MgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEsIHNlIHB1ZWRlIHVzYXIgZWwgY29tYW5kbyBgY2lNZWFuYCBkZSBsYSBsaWJyZXLDrWEgYGxzcmAuCkVzdGUgY29tYW5kbyByZWdyZXNhIGVsIGzDrW1pdGUgaW5mZXJpb3IgeSBlbCBsw61taXRlIHN1cGVyaW9yIGRlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphLgpQb3IgbG8gdGFudG8sIHBhcmEgZ3VhcmRhciBzb2xvIGVsIG3DrW5pbW8gc2UgdGllbmUgcXVlIGVzcGVjaWZpY2FyIGBsc3I6OmNpTWVhbihQMV82LCBuYS5ybT1UKVsxXWAgeSBwYXJhIGVsIG3DoXhpbW8gY2FtYmlhcsOtYSBhIGBbMl1gLgoKYGBge3J9CmxpYnJhcnkobHNyKQpjaV9hbHVteHNleG8gPSBlbmRvMjAyMCB8PgogIGdyb3VwX2J5KHNleG8pIHw+CiAgc3VtbWFyaXNlKG1lZGlhID0gbWVhbihQMV82LCBuYS5ybT1UKSwKICAgICAgICAgICAgbGltaW5mID0gY2lNZWFuKFAxXzYsIG5hLnJtPVQpWzFdLAogICAgICAgICAgICBsaW1zdXAgPSBjaU1lYW4oUDFfNiwgbmEucm09VClbMl0KICAgICAgICAgICAgKQpjaV9hbHVteHNleG8KYGBgCgotICAgRWwgSUMgYWwgOTUlIGRlIGNvbmZpYW56YSwgZWwgcHJvbWVkaW8gZGUgYWx1bW5vcyBxdWUgYWNvbXBhw7FhbiBsb3MgZG9jZW50ZXMgaG9tYnJlIGVzdMOhIGVuIGVsIHNpZ3VpZW50ZSBpbnRlcnZhbG8gJCQ1MC43IC0gNTMuOCQkCgotICAgRWwgSUMgYWwgOTUlIGRlIGNvbmZpYW56YSBlbCBwcm9tZWRpbyBkZSBhbHVtbm9zIHF1ZSBhY29tcGHDsWFuIGxhcyBkb2NlbnRlcyBtdWplcmVzIGVzdMOhIGVuIGVsIHNpZ3VpZW50ZSBpbnRlcnZhbG8gJCQzMy4zIC0gMzQuOCQkCgpDb21vIGFtYm9zIGludGVydmFsb3MgTk8gc2UgdHJhc2xhcGFuIChlbCBtYXlvciB2YWxvciBkZWwgc2VndW5kbyBJQywgMzQuOCAsIGVzIG1lbm9yIGFsIG1lam9yIHZhbG9yIGRlbCBwcmltZXIgSUMsIDUwLjcpLCBlbnRvbmNlcyBzZSBwdWVkZSBhZmlybWFyIHF1ZSBlc2FzIGRpZmVyZW5jaWFzIHNlIHB1ZWRlbiBleHRyYXBvbGFyIGxhIHBvYmxhY2nDs24uCgpTaSBsb3MgSUMgc2UgdHJhc2xhcGFuLCBlbnRvbmNlcywgbm8gc2UgcHVlZGUgYWZpcm1hciBxdWUgZXhpc3RhbiBkaWZlcmVuY2lhcyBlbiBlbCBuw7ptZXJvIGRlIGFsdW1ub3MgcXVlIGFjb21wYcOxYW4gZG9jZW50ZXMgaG9tYnJlcyBvIG11amVyZXMgKHNlcsOtYSB1biAiZW1wYXRlIHTDqWNuaWNvIikuCgojIyBHcsOhZmljbyBkZSBJQyBwYXJhIGNvbXBhcmFyIG1lZGlhcwoKU2UgcHVlZGUgZ3JhZmljYXIgYW1ib3MgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEuClBhcmEgaGFjZXIgZXN0bywgdXNhcmVtb3MgbGEgdGFibGEgcXVlIGd1YXJkYSBsb3MgZGF0b3MgZGUgbG9zIGludGVydmFsb3MgZGUgY29uZmlhbnphLgoKRXN0YSB0YWJsYSwgc2luIGVtYmFyZ28sIHRpZW5lIHVuYSBmaWxhIGRlIHJlc3VsdGFkb3MgcGFyYSBsb3MgdmFsb3JlcyBwZXJkaWRvcy4KRXN0YSBmaWxhIG5vIHRpZW5lIGRhdG9zIHBvciBncmFmaWNhciwgcG9yIGxvIHF1ZSB0ZW5lbW9zIHF1ZSBlbGltaW5hcmxhLgoKTG9zIGRhdGFmcmFtZXMgc2Ugb3JnYW5pemFuIGVuIGZpbGFzIHkgY29sdW1uYXMuCkxhIHRhYmxlICJjaV9hbHVteHNleG8iIHRpZW5lIDMgZmlsYXMgeSAzIGNvbHVtbmFzLgpMYSB0ZXJjZXJhIGZpbGEgZXMgbGEgcXVlIG5vIHRpZW5lIGRhdG9zIHF1ZSBncmFmaWNhci4KUGFyYSBlbGltaW5hciBzZSB0aWVuZSBxdWUgZXNwZWNpZmljYXIgbGEgdGFibGEgeSBjb24gbG9zIGJyYWNrZXRzIGBbZmlsYXMsIGNvbHVtbmFzXWAgZGVmaW5pciBsb3MgZGF0b3MgYSBlbGltaW5hciBgWy0zLCBdYC4KU2UgZWxpbWluYSBjb24gZWwgc2lnbm8gIi0iIHkgY29tbyBubyBoYXkgZGF0b3MgbHVlZ28gZGUgbGEgIiwiLCBzZSBpbmRpY2EgcXVlIG5vIHNlIGNhbWJpYSBuaW5ndW5hIGNvbHVtbmEuCgpgYGB7ciBjaSB4IHNleG99CmNpX2FsdW14c2V4byA9IGNpX2FsdW14c2V4b1stMyxdCmNpX2FsdW14c2V4bwpgYGAKCkVzdGEgdGFibGEgc2UgcHVlZGUgdXNhciBwYXJhIGNyZWFyIHVuIGdyw6FmaWNvIHF1ZSBjb21wYXJlIGFtYm9zIElDIGNvbiBsYSBsaWJyZXLDrWEgYGdncGxvdDJgIHkgY29uIGxhIGdlb21ldHLDrWEgYGdlb21fZXJyb3JiYXJgLgpTZSBhZ3JlZ2EgYGdlb21fdGV4dGAgcGFyYSBpbmNsdWlyIGVsICJ0ZXh0byIgY29uIGxvcyB2YWxvcmVzIHByb21lZGlvIGRlIGFtYm9zIGdydXBvcy4KCmBgYHtyIGdyYWZpY28xfQpsaWJyYXJ5KGdncGxvdDIpCmdyYWYxID0gZ2dwbG90KGNpX2FsdW14c2V4bywgYWVzKHg9c2V4bywgeT1tZWRpYSkpKwogIGdlb21fYmFyKHN0YXQ9ImlkZW50aXR5IikrCiAgZ2VvbV9lcnJvcmJhcihhZXMoeW1pbj1saW1pbmYsIHltYXg9bGltc3VwKSwgd2lkdGg9MC4yKSsKICBnZW9tX3RleHQoYWVzKGxhYmVsPXBhc3RlKHJvdW5kKG1lZGlhLCAxKSkpLCB2anVzdD0tMSwgc2l6ZT00KSsKICB4bGFiKCJTZXhvIGRlbCBkb2NlbnRlIikgKyB5bGFiKCJBbHVtbm9zIGF0ZW5kaWRvcyIpKwogIHlsaW0oMCwgNjApCmdyYWYxCmBgYAoKRW4gZXN0ZSBncsOhZmljbyBxdWVkYSBtw6FzIGNsYXJvIHF1ZSBhbWJvcyBJQyBubyBzZSB0cmFzbGFwYW4gcG9yIGxvIHF1ZSBzZSBwdWVkZSBkZWNpciBxdWUgc8OtIGV4aXN0ZW4gZGlmZXJlbmNpYXMgZW50cmUgZG9jZW50ZXMgaG9tYnJlIHkgbXVqZXJlcyBlbiBlbCBuw7ptZXJvIGRlIGFsdW1ub3MgcXVlIGFjb21wYcOxYW4gZW4gZWwgUGVyw7ouCgpFc3RlIHRpcG8gZGUgZ3LDoWZpY28gZXMgYmFzdGFudGUgdXN1YWwgZW4gbG9zIHJlcG9ydGVzIGVzdGFkw61zdGljb3MuClBvciBlamVtcGxvLCBzZSBwdWVkZW4gdmVyIGVzdGUgdGlwbyBkZSBncsOhZmljb3MgZW4gbG9zIHJlcG9ydGVzIGRlIFtFbCBQdWxzbyBkZSBsYSBEZW1vY3JhY2lhXShodHRwczovL3d3dy52YW5kZXJiaWx0LmVkdS9sYXBvcC9hYjIwMjEvMjAyMV9MQVBPUF9BbWVyaWNhc0Jhcm9tZXRlcl8yMDIxX1B1bHNlX29mX0RlbW9jcmFjeV9TUEEucGRmKSBkZWwgcHJveWVjdG8gTEFQT1AuCkVuIGVsIMO6bHRpbW8gcmVwb3J0ZSBwYXJhIFBlcsO6IHNlIHByZXNlbnRhIGVsIHNpZ3VpZW50ZSBncsOhZmljbyBxdWUgbXVlc3RyYSBsb3Mgbml2ZWxlcyBkZSBzYXRpc2ZhY2Npw7NuIGNvbiBsYSBkZW1vY3JhY2lhIGVudHJlIGdydXBvcyBkZSBzYXRpc2ZhY2Npw7NuIGNvbiBsb3Mgc2VydmljaW9zIHDDumJsaWNvcy4KRXN0b3MgZ3LDoWZpY29zIHNvbiBjb25zdHJ1aWRvcyBkZSBsYSBtaXNtYSBtYW5lcmEgcXVlIHNlIGhhIGNvbnN0cnVpZG8gZWwgZ3LDoWZpY28gZGUgYXJyaWJhLgoKIVtdKGdyYWY2LjYucG5nKXt3aWR0aD0iNjM1In0KCsK/UG9yIHF1w6k/LgouLgpBcXXDrSB2aWVuZSBsYSBpbnRlcnByZXRhY2nDs24gZGVsIHBvbGl0w7Nsb2dvIC4KCk9KTzogbm8gc2UgZGViZSBjb25mdW5kaXIgZXN0ZSBncsOhZmljbyBjb24gdW4gZ3LDoWZpY28gZGUgY2FqYXMuCgpUQVJFQTogQW5hbGl6YXIgc2kgZXhpc3RlbiBkaWZlcmVuY2lhcyBlbiBlbCBuw7ptZXJvIGRlIGFsdW1ub3MgZW50cmUgZG9jZW50ZXMgY29uIGRpZmVyZW50ZXMgY29uZGljaW9uZXMgbGFib3JhbGVzIChQMV83KS4KCiMgRWplbXBsbyAyIHBhcmEgdW5hIHZhcmlhYmxlIG51bcOpcmljYTogTEFQT1AKCmBgYHtyfQpsaWJyYXJ5KHJpbykKbGFwb3AgPSBpbXBvcnQoImJhc2VzL1BFUl8yMDA2LTIwMjEuZHRhIikKYGBgCgojIyBFamVtcGxvIHBhcmEgdmFyaWFibGUgbnVtw6lyaWNhIGNvbiDDrW5kaWNlIGFkaXRpdm8KCkVsIGN1ZXN0aW9uYXJpbyBkZSBMQVBPUCBpbmNsdXllIGRvcyBwcmVndW50YXMgc29icmUgbGFzIGZ1ZXJ6YXMgZGVsIG9yZGVuLgpCMTIuCsK/SGFzdGEgcXXDqSBwdW50byB0aWVuZSB1c3RlZCBjb25maWFuemEgZW4gbGFzIEZ1ZXJ6YXMgQXJtYWRhcz8KeSBCMTguCsK/SGFzdGEgcXXDqSBwdW50byB0aWVuZSB1c3RlZCBjb25maWFuemEgZW4gbGEgcG9saWPDrWEgbmFjaW9uYWw/CgpBbWJhcyBwcmVndW50YXMgZXN0w6FuIG1lZGlkYXMgZW4gdW5hIGVzY2FsYSBkZSAxIGEgNywgZG9uZGUgMSBzaWduaWZpY2EgIk5hZGEiIHkgNyBzaWduaWZpY2EgIk11Y2hvIi4KVW5hIHBlcnNvbmEgcXVlIHRlbmdhIGRlc2NvbmZpYW56YSBkZSBsYXMgZnVlcnphcyBkZWwgb3JkZW4gZW4gZ2VuZXJhbCwgc2VndXJhbWVudGUgcmVwb3J0YXLDoSBwdW50YWplcyBiYWpvcyBlbiBhbWJhcyBwcmVndW50YXMuClBvciBlbCBjb250cmFyaW8sIHVuYSBwZXJzb25hIHF1ZSB0ZW5nYSBhbHRhIGNvbmZpYW56YSBlbiBsYXMgZnVlcnphcyBkZWwgb3JkZW4gZW4gZ2VuZXJhbCwgcHVlZGUgcmVwb3J0YXIgcHVudGFqZXMgYWx0b3MgZW4gYW1iYXMgcHJlZ3VudGFzLgoKU2UgcHVlZGVuIGNvbWJpbmFyIGFtYmFzIHByZWd1bnRhcyBwYXJhIGdlbmVyYXIgdW4gw61uZGljZSBhZGl0aXZvIGRlIGNvbmZpYW56YSBnZW5lcmFsIGVuIGxhcyBmdWVyemFzIGRlbCBvcmRlbiwgY29tbyBsYSBzdW1hIGRlIGFtYmFzLgpDb21vIGNhZGEgcHJlZ3VudGEgcHVlZGUgc2VyIHJlc3BvbmRpZGEgZW50cmUgMSB5IDcsIGxhIHN1bWEgcHVlZGUgdmFyaWFyIGVudHJlIDIgeSAxNC4KVW4gcHVudGFqZSBkZSAyIGV4cHJlc2Fyw6EgbGEgbcOhcyBiYWphIGNvbmZpYW56YSBlbiBsYXMgZnVlcnphcyBkZWwgb3JkZW4uClVuIHB1bnRhamUgZGUgMTQsIGxhIG3DoXMgYWx0YSBjb25maWFuemEgZW4gbGFzIGZ1ZXJ6YXMgZGVsIG9yZGVuLgpDdWFscXVpZXIgcHVudGFqZSBpbnRlcm1lZGlvLCBleHByZXNhcsOhIHVuYSBjb25maWFuemEgaW50ZXJtZWRpYS4KCkNvbW8gTk8gZXMgaW50dWl0aXZvIHRlbmVyIHVuIMOtbmRpY2UgcXVlIHZhcsOtZSBlbnRyZSAyIHkgMTQsIHNlIHB1ZWRlIHJlc3RhciBkb3MgYSBsYSBzdW1hIHBhcmEgcXVlIGVsIMOtbmRpY2UgdmFyw61lIGVudHJlIDAgeSAxMi4KQ29tbyBlc3RhIHZhcmlhY2nDs24gdGFtcG9jbyBlcyBpbnR1aXRpdmEsIHNlIHB1ZWRlIGRpdmlkaXIgdG9kbyBlbnRyZSAxMiBwYXJhIHF1ZSBlbCDDrW5kaWNlIHZhcsOtZSBlbnRyZSAwIHkgMS4KCnwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IENvbmZpYW56YSBlbiBGRkFBIHwgQ29uZmlhbnphIGVuIHBvbGljw61hIHwgQ29uZmlhbnphIGdlbmVyYWwgfCBDb25maWFuemEgZ2VuZXJhbCAtIDIgfCAoQ29uZmlhbnphIGdlbmVyYWwgLSAyKSAvIDEyIHwgKENvbmZpYW56YSBnZW5lcmFsIC0gMikgLyAxMlwqMTAwIHwKfC0tLS0tLS0tLS0tLXw6LS0tLS0tLS06fDotLS0tLS0tLTp8Oi0tLS0tLS0tOnw6LS0tLS0tLS06fDotLS0tLS0tLTp8Oi0tLS0tLS0tOnwKfCBQZXJzb25hIGNvbiBtdWNoYSBkZXNjb25maWFuemEgZW4gbGFzIGZ1ZXJ6YXMgZGVsIG9yZGVuIHwgICAgICAgICAxICAgICAgICAgfCAgICAgICAgICAxICAgICAgICAgICB8ICAgICAgICAgMiAgICAgICAgIHwgICAgICAgICAgIDAgICAgICAgICAgIHwgICAgICAgICAgICAgIDAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAwICAgICAgICAgICAgICAgICB8CnwgUGVyc29uYSBjb24gbXVjaGEgY29uZmlhbnphIGVuIGxhcyBmdWVyemFzIGRlbCBvcmRlbiAgICB8ICAgICAgICAgNyAgICAgICAgIHwgICAgICAgICAgNyAgICAgICAgICAgfCAgICAgICAgMTQgICAgICAgICB8ICAgICAgICAgIDEyICAgICAgICAgICB8ICAgICAgICAgICAgICAxICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAxMDAgICAgICAgICAgICAgICAgfAp8IFBlcnNvbmEgY29uIGNvbmZpYW56YSBtZWRpYSBlbiBsYXMgZnVlcnphcyBkZWwgb3JkZW4gICAgfCAgICAgICAgIDQgICAgICAgICB8ICAgICAgICAgIDUgICAgICAgICAgIHwgICAgICAgICA5ICAgICAgICAgfCAgICAgICAgICAgNyAgICAgICAgICAgfCAgICAgICAgICAgICAwLjU4ICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgNTggICAgICAgICAgICAgICAgIHwKfCBQZXJzb25hIGNvbiBjb25maWFuemEgbWVkaWEgZW4gbGFzIGZ1ZXJ6YXMgZGVsIG9yZGVuICAgIHwgICAgICAgICA2ICAgICAgICAgfCAgICAgICAgICA0ICAgICAgICAgICB8ICAgICAgICAxMCAgICAgICAgIHwgICAgICAgICAgIDggICAgICAgICAgIHwgICAgICAgICAgICAgMC42NiAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgIDY2ICAgICAgICAgICAgICAgICB8CgpEZSBlc3RhIG1hbmVyYSBjYWRhIHBlcnNvbmEgdGllbmUgdW4gcHVudGFqZSBxdWUgcHVlZGUgdmFyaWFyIGVudHJlIDAgeSAxLCBkZXBlbmRpZW5kbyBkZSBsYXMgcmVzcHVlc3RhcyBxdWUgZGlvIGEgY2FkYSB1bmEgZGUgbGFzIHByZWd1bnRhcyBpbmRpdmlkdWFsZXMuCgpFc3RvIHNlIHB1ZWRlIGNhbGN1bGFyIGVuIFIuCgpgYGB7cn0KbGlicmFyeShkcGx5cikKbGFwb3AgPSBsYXBvcCB8PgogIG11dGF0ZShpbmRpY2UgPSAoYjEyK2IxOC0yKS8xMioxMDApCmBgYAoKUG9kZW1vcyBhc3VtaXIgcXVlIGVzdGUgw61uZGljZSBlcyB1bmEgdmFyaWFibGUgY3VhbnRpdGF0aXZhLCBwb3IgbG8gcXVlIHBvZGVtb3MgY2FsY3VsYXIgbGEgbWVkaWEgeSBlbCBpbnRlcnZhbG8gZGUgY29uZmlhbnphIGRlIGxhIG1lZGlhLgoKYGBge3J9CmxpYnJhcnkobHNyKQpsYXBvcCB8PgogIHN1bW1hcmlzZShtZWRpYSA9IG1lYW4oaW5kaWNlLCBuYS5ybT1UKSwKICAgICAgICAgICAgbGltaW5mID0gY2lNZWFuKGluZGljZSwgbmEucm09VClbMV0sCiAgICAgICAgICAgIGxpbXN1cCA9IGNpTWVhbihpbmRpY2UsIG5hLnJtPVQpWzJdCiAgICAgICAgICAgICkKYGBgCgpNZWpvciBhw7puLCBwb2RlbW9zIGNhbGN1bGFyIGVsIMOtbmRpY2UgZGUgY29uZmlhbnphIGVuIGxhcyBmdWVyemFzIGRlbCBvcmRlbiBwb3IgYcOxbyBkZSBsYSBlbmN1ZXN0YS4KCmBgYHtyfQppbmRpY2V4d2F2ZSA9IGxhcG9wIHw+CiAgZ3JvdXBfYnkod2F2ZSkgfD4KICBzdW1tYXJpc2UobWVkaWEgPSBtZWFuKGluZGljZSwgbmEucm09VCksCiAgICAgICAgICAgIGxpbWluZiA9IGNpTWVhbihpbmRpY2UsIG5hLnJtPVQpWzFdLAogICAgICAgICAgICBsaW1zdXAgPSBjaU1lYW4oaW5kaWNlLCBuYS5ybT1UKVsyXQogICAgICAgICAgICApCmluZGljZXh3YXZlCmBgYAoKQ29uIGxvIHF1ZSBwb2RlbW9zIGNvbXBhcmFyIGVsIMOtbmRpY2UgZGUgYXBveW8gYSBsYXMgZnVlcnphcyBkZWwgb3JkZW4gcG9yIGHDsW8gcGFyYSBzYWNhciBjb25jbHVzaW9uZXMgYWNlcmNhIGRlIGRpZmVyZW5jaWFzLgoKYGBge3J9CmxpYnJhcnkoZ2dwbG90MikKZ3JhZjMgPSBnZ3Bsb3QoaW5kaWNleHdhdmUsIGFlcyh4PXdhdmUsIHk9bWVkaWEpKSsKICBnZW9tX2JhcihzdGF0PSJpZGVudGl0eSIpKwogIGdlb21fZXJyb3JiYXIoYWVzKHltaW49bGltaW5mLCB5bWF4PWxpbXN1cCksIHdpZHRoPTAuMikrCiAgZ2VvbV90ZXh0KGFlcyhsYWJlbD1wYXN0ZShyb3VuZChtZWRpYSwgMSkpKSwgdmp1c3Q9LTEsIHNpemU9NCkrCiAgeGxhYigiQcOxbyBkZSBlbmN1ZXN0YXMiKSArIHlsYWIoIsONbmRpY2UgZGUgY29uZmlhbnphIGVuIGxhcyBmdWVyemFzIGRlbCBvcmRlbiIpKwogIHlsaW0oMCwgNjApCmdyYWYzCmBgYAoKIyMgCgojIEVqZW1wbG8gMSBwYXJhIHVuYSB2YXJpYWJsZSBjYXRlZ8OzcmljYTogRU5ETwoKU2lndWllbmRvIGNvbiBlbCBlamVtcGxvIGRlIGxhIEVORE8gMjAyMCwgbGEgaGlww7N0ZXNpcyBxdWUgc2UgcHVlZGUgZXZhbHVhciBlcyBzaSBleGlzdGVuIGRpZmVyZW5jaWFzIGVuIHNpIGxvcyBkb2NlbnRlcyBoYW4gcmVjaWJpZG8gYXBveW8gcHNpY29sw7NnaWNvIG8gZW1vY2lvbmFsIHBvciBzZXhvIChQMV8xMykuCgpMYSBoaXDDs3Rlc2lzIGNlcm8gc2Vyw61hOiBMYSBwcm9wb3JjacOzbiBkZSBkb2NlbnRlcyBxdWUgaGFuIHJlY2liaWRvIGFwb3lvIHBzaWNvbMOzZ2ljbyBlbnRyZSBkb2NlbnRlcyBob21icmVzID0gUHJvcG9yY2nDs24gZGUgZG9jZW50ZXMgcXVlIGhhbiByZWNpYmlkbyBhcG95byBwc2ljb2zDs2dpY28gZW50cmUgZG9jZW50ZXMgbXVqZXJlcy4KCkxvIHByaW1lcm8gZXMgdHJhbnNmb3JtYXIgbGEgdmFyaWFibGUgUDFfMTMgcXVlIGVzIGltcG9ydGFkYSBjb21vIG51bcOpcmljYSwgY29tbyB1bmEgdmFyaWFibGUgZGUgZmFjdG9yIHkgY29uIHN1cyBldGlxdWV0YXMuCgpgYGB7cn0KZW5kbzIwMjAgPSBlbmRvMjAyMCB8PgogIG11dGF0ZShhcG95byA9IGZhY3RvcihQMV8xMywgbGFiZWxzPWMoIlPDrSIsICJObyIpKSkKYGBgCgpBaG9yYSB0ZW5lbW9zIHF1ZSBwcm9kdWNpciBsYSB0YWJsYSBkZSBkaXN0cmlidWNpw7NuIGRlIGZyZWN1ZW5jaWFzLgpTaSBjYWxjdWxhbW9zIGxhcyBmcmVjdWVuY2lhcyBjb24gYGNvdW50YCBkaXJlY3RhbWVudGUsIGVzdGEgdGFibGEgaW5jbHVpcsOtYSB1bmEgZmlsYSBkZSBsb3MgTkFzIHkgbHVlZ28gY2FsY3VsYXLDoSBsb3MgcG9yY2VudGFqZXMgaW5jbHV5ZW5kbyBhIGVzdGUgZ3J1cG8uCkVzIHBvciBlc3RvIHF1ZSBhbnRlcyBkZSBjYWxjdWxhciBsYXMgZnJlY3VlbmNpYXMsIHRlbmVtb3MgcXVlIGZpbHRyYXIgcGFyYSBxdWUgc29sbyBjdWVudGUgbG9zICJTw60iIHkgIk5vIi4KTHVlZ28gZGUgbGFzIGZyZWN1ZW5jaWFzLCBpbmNsdWltb3MgZWwgcG9yY2VudGFqZSBjb24gYG11dGF0ZWAuCgpgYGB7cn0KdGFibGEgPSBlbmRvMjAyMCB8PgogIGZpbHRlcihhcG95byA9PSJTw60iIHwgYXBveW8gPT0gIk5vIikgfD4KICBjb3VudChBcG95byA9IGFwb3lvLCBuYW1lPSJOIil8PgogIG11dGF0ZSh0b3RhbCA9IHN1bShOKSwgCiAgICAgICAgIFBvciA9IE4gLyB0b3RhbCAqIDEwMCkKdGFibGEKYGBgCgpQb3IgZWplbXBsbywgcGFyYSBoYWxsYXIgZWwgSUMgZGUgbGEgcHJvcG9yY2nDs24gZGUgYXF1ZWxsb3MgZG9jZW50ZXMgcXVlIHJlcG9ydGFyb24gaGFiZXIgcmVjaWJpZG8gYXBveW8gcHNpY29sw7NnaWNvLCBwb2RlbW9zIHVzYXIgZWwgY29tYW5kbyBgcHJvcC50ZXN0YC4KRXN0ZSBjb21hbmRvIHJlcXVpZXJlIGVsIG4gZGUgbGEgb3BjacOzbiAiU8OtIiBkZSBsYSB0YWJsYSB5IGVsIHRvdGFsIGRlIGNhc29zLgpQb3IgZGVmZWN0byBub3MgY2FsY3VsYSBlbCBJQyBhbCA5NSUgZGUgY29uZmlhbnphLgoKYGBge3J9CnByb3AudGVzdCg5NDc2LDE4OTMwKQpgYGAKClNlIGVzdGltYSBxdWUgZWwgbGEgcHJvcG9yY2nDs24gZGUgZG9jZW50ZXMgcXVlIHJlY2liaWVyb24gYXBveW8gcHNpY29sw7NnaWNvIGVzdMOhIGVudHJlIDQ5LjMlIHkgNTAuOCUuCgpMdWVnbywgcGFyYSByZXNwb25kZXIgYSBsYSBwcmVndW50YSBkZSBzaSBlc3RhIHByb3BvcmNpw7NuIHZhcsOtYSBlbnRyZSBkb2NlbnRlcyBob21icmVzIHkgbXVqZXJlcywgdGVuZW1vcyBxdWUgY3JlYXIgb3RyYSB0YWJsYSBjb24gbGFzIGZyZWN1ZW5jaWFzIHkgcG9yY2VudGFqZXMgcG9yIGNhZGEgZ3J1cG8gZGUgbGEgdmFyaWFibGUgInNleG8iLgpQYXJhIGVzdG8sIGFsIGPDs2RpZ28gYW50ZXJpb3IgbGUgYWdyZWdhbW9zIGVsIGNvbWFuZG8gYGdyb3VwX2J5YC4KCmBgYHtyfQp0YWJsYTIgPSBlbmRvMjAyMCB8PgogIGZpbHRlcihhcG95byA9PSJTw60iIHwgYXBveW8gPT0gIk5vIikgfD4KICBncm91cF9ieShzZXhvKSB8PgogIGNvdW50KEFwb3lvID0gYXBveW8sIG5hbWU9Ik4iKXw+CiAgbXV0YXRlKHRvdGFsID0gc3VtKE4pLCAKICAgICAgICAgUG9yID0gTiAvIHRvdGFsICogMTAwLCAKICAgICAgICAgZXJyID0gc3FydChQb3IqKDEwMC1Qb3IpL04pLCAKICAgICAgICAgbGltaW5mID0gUG9yIC0gMS45NiplcnIsIAogICAgICAgICBsaW1zdXAgPSBQb3IgKyAxLjk2KmVycikKdGFibGEyCmBgYAoKRWwgbWlzbW8gY29tYW5kbyBgcHJvcC50ZXN0YCBwZXJtaXRlIGhhY2VyIGxhIHBydWViYSBwYXJhIGxhIGRpZmVyZW5jaWEgZGUgcHJvcG9yY2lvbmVzLgpQYXJhIGVzdG8sIGxvcyB2YWxvcmVzIHRhbnRvIGRlIGhvbWJyZXMsIGNvbW8gZGUgbXVqZXJlcywgc2UgY29uY2F0ZW5hbiBjb24gbGEgZXNwZWNpZmljYWNpw7NuIGBjKOKApilgLCB0YW50byBwYXJhIGVsIG4gZGUgIlPDrSIgZGUgY2FkYSBncnVwbywgY29tbyBwYXJhIGVsIHRvdGFsIGRlIGNhc29zIGRlIGNhZGEgZ3J1cG8uCgpgYGB7cn0KcHJvcC50ZXN0KGMoMjc3NywgNjY5OSksIGMoNjE2MywxMjc2NykpCmBgYAoKU2Vnw7puIGxvcyByZXN1bHRhZG9zLCBzZSBlbmN1ZW50cmEgcXVlIGVsIDUyLjUlIGRlIGRvY2VudGVzIG11amVyZXMgcmVjaWJpZXJvbiBhcG95byBwc2ljb2zDs2dpY28gdmVyc3VzIGVsIDQ1LjElIGRlIGRvY2VudGVzIGhvbWJyZXMuCkVzdGUgY29tYW5kbyBubyBub3MgYnJpbmRhIGRpcmVjdGFtZW50ZSBsb3MgbMOtbWl0ZXMgaW5mZXJpb3IgeSBzdXBlcmlvciBkZSBsb3MgSUMgZGUgY2FkYSBncnVwbywgcGVybyBub3MgYnJpbmRhIGVsIElDIGRlIGxhIGRpZmVyZW5jaWEgZGUgcHJvcG9yY2lvbmVzIGFsIDk1JSBkZSBjb25maWFuemEuCkVzdGUgSUMgZGUgbGEgZGlmZXJlbmNpYSBkZSBwcm9wb3JjaW9uZXMgdmFyw61hIGVudHJlIC04LjklIHkgLTUuOSUuCgpDb21vIGVzdGUgSUMgdmEgc29sbyBlbnRyZSB2YWxvcmVzIG5lZ2F0aXZvczsgZXMgZGVjaXIsIGNvbW8gZWwgSUMgbm8gaW5jbHV5ZSBhbCBjZXJvLCBzZSBwdWVkZSBjb25jbHVpciBxdWUgbGEgZGlmZXJlbmNpYSBkZSBwcm9wb3JjaW9uZXMgbm8gcHVlZGUgc2VyIGNlcm8sIHBvciBsbyB0YW50bywgcXVlIGV4aXN0ZSB1bmEgZGlmZXJlbmNpYSBlc3RhZMOtc3RpY2FtZW50ZSBzaWduaWZpY2F0aXZhIGVuIGxhcyBwcm9wb3JjaW9uZXMgZW50cmUgYW1ib3MgZ3J1cG9zLgoKTGEgdGFibGEgMiBzZSBwdWVkZSB1c2FyIHBhcmEgZ3JhZmljYXIuCkNvbW8gbm9zIGludGVyZXNhIGNvbXBhcmFyIGxvcyBwb3JjZW50YWplcyBkZSBkb2NlbnRlcyBxdWUgcmVwb3J0YXJvbiBoYWJlciByZWNpYmlkbyBhdGVuY2nDs24gcHNpY29sw7NnaWNhIHBvciBzZXhvLCBzZSBwdWVkZSBlbGltaW5hciBsYXMgZmlsYXMgZGUgYXF1ZWxsb3MgcXVlIG5vIHJlY2liaWVyb24gYXRlbmNpw7NuIHBzaWNvbMOzZ2ljYSBlbiBsYSB0YWJsYSAyLgoKYGBge3J9CnRhYmxhMiA9IHRhYmxhMlstYygyLDQpLF0KYGBgCgpMdWVnbywgY29uIGVzdGEgdGFibGEgcG9kZW1vcyBzZWd1aXIgZWwgbWlzbW8gcHJvY2VkaW1pZW50byBxdWUgY29uIGVsIGPDoWxjdWxvIGRlIGxhcyBiYXJyYXMgZGUgZXJyb3IgcGFyYSBsYSBtZWRpYSwgcGVybyBlc3RhIHZleiBwYXJhIGxvcyBwb3JjZW50YWplcy4KCmBgYHtyfQpncmFmMiA9IGdncGxvdCh0YWJsYTIsIGFlcyh4PXNleG8sIHk9UG9yKSkrCiAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiKSsKICBnZW9tX2Vycm9yYmFyKGFlcyh5bWluPWxpbWluZiwgeW1heD1saW1zdXApLCB3aWR0aD0wLjIpKwogIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUocm91bmQoUG9yLCAxKSkpLCB2anVzdD0tMSwgc2l6ZT00KSsKICB4bGFiKCJTZXhvIGRlbCBkb2NlbnRlIikgKyB5bGFiKCJQb3JjZW50YWplIHF1ZSByZWNpYmnDsyBhdGVuY2nDs24gcHNpY29sw7NnaWNhIikrCiAgeWxpbSgwLCA2MCkKZ3JhZjIKYGBgCgpEZSBlc3RlIGdyw6FmaWNvIHNlIHB1ZWRlIGNvbmNsdWlyIHF1ZSBleGlzdGVuIGRpZmVyZW5jaWFzIGVzdGFkw61zdGljYW1lbnRlIHNpZ25pZmljYXRpdmFzIGVuIGVsIHBvcmNlbnRhamUgZGUgZG9jZW50ZXMgcXVlIGJ1c2Nhcm9uIGF0ZW5jacOzbiBwc2ljb2zDs2dpY2EgZW50cmUgaG9tYnJlcyB5IG11amVyZXMsIGRlYmlkbyBhIHF1ZSBsb3MgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgbm8gc2UgdHJhc2xhcGFuLgoKRGUgbWFuZXJhIG3DoXMgZXNwZWPDrWZpY2EsIHNlIHB1ZWRlIGFmaXJtYXIgcXVlIGxhcyBkb2NlbnRlcyBwZXJ1YW5hcyByZWNpYmVuIG3DoXMgYXRlbmNpw7NuIHBzaWNvbMOzZ2ljYSBxdWUgbG9zIGRvY2VudGVzIGhvbWJyZXMuCgojIyBFamVtcGxvIHBhcmEgdmFyaWFibGUgY2F0ZWfDs3JpY2EKCkVuIGxhIHDDoWdpbmEgMjEgZGVsIHJlcG9ydGUgKkN1bHR1cmEgcG9sw610aWNhIGRlIGxhIGRlbW9jcmFjaWEgZW4gUGVyw7ogeSBlbiBsYXMgQW3DqXJpY2FzIDIwMjE6IFRvbcOhbmRvbGUgZWwgcHVsc28gYSBsYSBkZW1vY3JhY2lhKiBzZSBwcmVzZW50YSBlbCBncsOhZmljbyBxdWUgbXVlc3RyYSBlbCBwb3JjZW50YWplIGRlIGFwb3lvIGEgbGEgZGVtb2NyYWNpYSBlbiBQZXLDuiAobMOtbmVhIG1hZ2VudGEpIGEgbG8gbGFyZ28gZGVsIHRpZW1wbywgZW4gY29tcGFyYWNpw7NuIGNvbiBBbcOpcmljYSBMYXRpbmEgKGzDrW5lYSBtb3JhZGEpLgoKRWwgYXBveW8gYSBsYSBkZW1vY3JhY2lhLCB2YXJpYWJsZSAiSU5HNCIsIGVzdMOhIG1lZGlkYSBlbiB1bmEgZXNjYWxhIGRlbCAxIGFsIDcsIGRvbmRlIDEgc2lnbmlmaWNhICJtdXkgZW4gZGVzYWN1ZXJkbyIgeSA3IHNpZ25pZmljYSAibXV5IGRlIGFjdWVyZG8iLgpFc3RhIHZhcmlhYmxlIHNlIHRpZW5lIHF1ZSByZWNvZGlmaWNhci4KRGUgYWN1ZXJkbyBhbCByZXBvcnRlICJMYXMgcmVzcHVlc3RhcyB2YW4gZGUgMSAobXV5IGVuIGRlc2FjdWVyZG8pIGEgNyAobXV5IGRlIGFjdWVyZG8pLiBQYXJhIGVzdGUgYW7DoWxpc2lzLCBzZSBjb2RpZmljYXJvbiBsYXMgcmVzcHVlc3RhcyBlbiBlbCBleHRyZW1vImRlIGFjdWVyZG8iIGRlIGxhIGVzY2FsYSAodmFsb3JlcyBxdWUgdmFuIGRlIDUgYSA3KSBjb21vIGFwb3lvIGEgbGEgZGVtb2NyYWNpYS4iIChwLjcpLgoKIVtdKGFwb3lvX3BlcnUucG5nKQoKUGFyYSByZWNvZGlmaWNhciBsYSB2YXJpYWJsZSBzZSB1c2EgZWwgc2lndWllbnRlIGPDs2RpZ28uCkVsIHJlc3VsdGFkbyBlcyB1bmEgdmFyaWFibGUgZGljb3TDs21pY2EgKDA9Tm8sIDE9U8OtKSwgcXVlIGVzIHVuYSB2YXJpYWJsZSBjYXRlZ8OzcmljYSwgYXVucXVlIGluY2x1eWUgdW4gZ3J1cG8gcXVlIG5vIHRpZW5lIHJlc3B1ZXN0YSBlbiBlc3RhIHZhcmlhYmxlIHkgZXN0w6EgY29tbyBOQXMuCgpgYGB7cn0KbGFwb3AgPSBsYXBvcCB8PgogIG11dGF0ZShpbmc0cmVjPXJlY29kZShpbmc0LCAnNScgPSAxLCAnNicgPSAxLCAnNycgPSAxLCAgLmRlZmF1bHQgPSAwKSkKYGBgCgpTZSB2ZXJpZmljYSBsYSByZWNvZGlmaWNhY2nDs24uCgpgYGB7cn0KbGFwb3AgfD4KICBjb3VudChpbmc0LCBuYW1lPSJGcmVjdWVuY2lhIikKYGBgCgpMbyBxdWUgcXVlcmVtb3MgZXMgZW5jb250cmFyIGVsIGludGVydmFsbyBkZSBjb25maWFuemEgZGUgbGEgcHJvcG9yY2nDs24gKG8gcG9yY2VudGFqZSkgZGUgYXF1ZWxsb3MgcXVlIHJlc3BvbmRlbiAiU8OtIiAobGFzIDc3NTQgcGVyc29uYXMgY29uIHVuIDEpLgpPam8gcXVlIGxhIHRhYmxhIG11ZXN0cmEgYSAzOTMgcGVyc29uYXMgY29uIE5Bcy4KCmBgYHtyfQpsYXBvcCB8PgogIGNvdW50KGluZzRyZWMsIG5hbWU9IkZyZWN1ZW5jaWEiKQpgYGAKClkgcXVlcmVtb3MgY2FsY3VsYXIgZWwgcG9yY2VudGFqZSBkZSBhcXVlbGxvcyBxdWUgcmVzcG9uZGVuICJTw60iIHBvciBhw7FvIGRlIGxhIGVuY3Vlc3RhLgpMYSB2YXJpYWJsZSBxdWUgcmVnaXN0cmEgZWwgYcOxbyBkZSBsYSBlbmN1ZXN0YSBlcyAid2F2ZSIuCkVzdGEgdmFyaWFibGUgc2UgY2FyZ2EgY29tbyB1bmEgbnVtw6lyaWNhIChwb3IgZXN0ZSBtb3Rpdm8sIGVuIGVsIGdyw6FmaWNvIGFudGVyaW9yIGVsIGVqZSBYIGRlbCBncsOhZmljbyBhcGFyZWNlIGNvbW8gdW5hIHZhcmlhYmxlIGNvbnRpbnVhKSB5IHNlIHRpZW5lIHF1ZSB0cmFuc2Zvcm1hciBhIHVuYSBkZSBmYWN0b3IgbGxhbWFkYSAicm9uZGEiLgoKYGBge3J9CmxhcG9wID0gbGFwb3AgfD4KICBtdXRhdGUocm9uZGEgPSBmYWN0b3Iod2F2ZSkpCmBgYAoKU2UgY2FsY3VsYSBlbCBhcG95byBhIGxhIGRlbW9jcmFjaWEgcG9yIGHDsW9zLgpQYXJhIGVsIGPDoWxjdWxvIGRlIGVzdGEgdGFibGEgcXVlcmVtb3MgZXhjbHVpciBhIGFxdWVsbG9zIHF1ZSBubyB0aWVuZW4gcmVzcHVlc3RhIGVuIGxhIHZhcmlhYmxlIGFwb3lvIGEgbGEgZGVtb2NyYWNpYSAobG9zIDM5MyBOQXMgYW50ZXJpb3JlcykuCkVzdG8gbG8gcG9kZW1vcyBoYWNlciBjb24gZWwgY29tYW5kbyBgZmlsdGVyYCwgZG9uZGUgZXNwZWNpZmljYW1vcyBxdWUgc29sbyBxdWVyZW1vcyBjYWxjdWxhciBsb3MgcG9yY2VudGFqZXMgZGUgYXF1ZWxsb3MgcXVlIHJlc3BvbmRpZXJvbiBObyAobyAwIGVuIGxhIHZhcmlhYmxlKSB5IGFxdWVsbG9zIHF1ZSByZXNwb25kaWVyb24gU8OtIChvIDEgZW4gbGEgdmFyaWFibGUpLgoKRW4gY2FkYSBncnVwbyBzZSBxdWllcmUgY2FsY3VsYXIgZWwgaW50ZXJ2YWxvIGRlIGNvbmZpYW56YSBkZSBsYSBwcm9wb3JjacOzbi4KUmVjdWVyZGVuIHF1ZSBsYSBmw7NybXVsYSBxdWUgc2UgdGllbmUgcXVlIHVzYXIgZXMgbGEgZGUgaW50ZXJ2YWxvcyBkZSBjb25maWFuemEgZGUgbGEgcHJvcG9yY2nDs24uCgpEZW50cm8gZGVsIGNvbWFuZG8gYG11dGF0ZWAgY2FsY3VsYW1vcyBlbCB0b3RhbCBlbiBjYWRhIGdydXBvICh0b3RhbCksIGxhIHByb3BvcmNpw7NuIChQb3IpLCBlbCBlcnJvciBlc3TDoW5kYXIgKGVyciBxdWUgZXMgaWd1YWwgYSBsYSByYcOteiBjdWFkcmFkYSBkZWwgcG9yY2VudGFqZSBwb3IgMTAwLXBvcmNlbnRhamUgZW50cmUgTikgeSBlbCBsw61taXRlIGluZmVyaW9yIHkgc3VwZXJpb3IgZGVsIGludGVydmFsbyBkZSBjb25maWFuemEuCgpgYGB7cn0KdGFibGEzID0gbGFwb3AgfD4KICBmaWx0ZXIoaW5nNHJlYyA9PTAgfCBpbmc0cmVjID09IDEpIHw+CiAgZ3JvdXBfYnkocm9uZGEpIHw+CiAgY291bnQoQXBveW8gPSBpbmc0cmVjLCBuYW1lPSJOIil8PgogIG11dGF0ZSh0b3RhbCA9IHN1bShOKSwgCiAgICAgICAgIFBvciA9IE4gLyB0b3RhbCAqIDEwMCwgCiAgICAgICAgIGVyciA9IHNxcnQoUG9yKigxMDAtUG9yKS9OKSwgCiAgICAgICAgIGxpbWluZiA9IFBvciAtIDEuOTYqZXJyLCAKICAgICAgICAgbGltc3VwID0gUG9yICsgMS45NiplcnIpCnRhYmxhMwpgYGAKCkxhIHRhYmxhIG11ZXN0cmEgbG9zIGRhdG9zIGRlIGxvcyBxdWUgbm8gYXBveWFuIGEgbGEgZGVtb2NyYWNpYSAoZmlsYXMgZG9uZGUgQXBveW89MCkgeSBkZSBsb3MgcXVlIHPDrSBhcG95YW4gYSBsYSBkZW1vY3JhY2lhIChmaWxhcyBkb25kZSBBcG95bz0xKSBwb3IgY2FkYSByb25kYS4KCkNvbW8gc29sbyBzZSBxdWllcmUgZ3JhZmljYXIgYSBsb3MgcXVlIHPDrSBhcG95YW4gYSBsYSBkZW1vY3JhY2lhLCBzZSBkZWJlbiBlbGltaW5hciB0b2RhcyBsYXMgZmlsYXMgaW1wYXJlcy4KCmBgYHtyfQp0YWJsYTMgPSB0YWJsYTNbLWMoMSwzLDUsNyw5LDExLDEzLDE1KSxdCnRhYmxhMwpgYGAKCkFob3JhLCB0ZW5lbW9zIGxvcyBkYXRvcyBwYXJhIGdyYWZpY2FyLgoKYGBge3J9CmdyYWY0ID0gZ2dwbG90KHRhYmxhMywgYWVzKHg9cm9uZGEsIHk9UG9yKSkrCiAgZ2VvbV9iYXIoc3RhdD0iaWRlbnRpdHkiKSsKICBnZW9tX2Vycm9yYmFyKGFlcyh5bWluPWxpbWluZiwgeW1heD1saW1zdXApLCB3aWR0aD0wLjIpKwogIGdlb21fdGV4dChhZXMobGFiZWw9cGFzdGUocm91bmQoUG9yLCAxKSkpLCB2anVzdD0tMSwgc2l6ZT00KSsKICB4bGFiKCJSb25kYSIpICsgeWxhYigiUG9yY2VudGFqZSBxdWUgYXBveWEgYSBsYSBkZW1vY3JhY2lhIikrCiAgeWxpbSgwLCA3MCkKZ3JhZjQKYGBgCgojIE5vdGEgZmluYWwKCkxhIGNvbXBhcmFjacOzbiBkZSBJQywgeWEgc2VhIGNhbGN1bGFuZG8gbG9zIHZhbG9yZXMgcGFyYSBjYWRhIGdydXBvIG8geWEgc2VhIGRlIG1hbmVyYSBncsOhZmljYSwgZXMgdW5hIHByaW1lcmEgbWFuZXJhIGRlIGFuYWxpemFyIHNpIGxhcyBkaWZlcmVuY2lhcyBlbnRyZSBncnVwb3Mgc2UgcHVlZGVuIGV4dHJhcG9sYXIgYSBsYSBwb2JsYWNpw7NuLgoKUGVybyBlc3RhIGVzIHVuYSBtYW5lcmEgImluZm9ybWFsIiBkZSBoYWNlciBlc3RhIGNvbXBhcmFjacOzbi4KUGFyYSBmb3JtYWxpemFyIGVzdGEgY29tcGFyYWNpw7NuIGV4aXN0ZSB1bmEgcHJ1ZWJhIGVzdGFkw61zdGljYSBsbGFtYWRhIHBydWViYSB0IGRlIGRpZmVyZW5jaWFzIGRlIG1lZGlhcyBvIGxhIHBydWViYSBkZSBwcm9wb3JjaW9uZXMsIHF1ZSBzZSB2ZXLDoW4gZW4gbGEgc2lndWllbnRlIHNlc2nDs24uCgojIEJpYmxpb2dyYWbDrWEK</div>


</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("clase4.Rmd");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
